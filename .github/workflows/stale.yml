# This workflow warns and then closes issues and PRs that have had no activity for a specified amount of time.
#
# You can adjust the behavior by modifying this file.
# For more information, see:
# https://github.com/actions/stale
name: Mark stale issues and pull requests

on: /*
 *   This file is part of DroneBridge: https://github.com/seeul8er/DroneBridge
 *
 *   Copyright 2017 
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

#include <stdint.h>
#include <time.h>
#include <net/if.h>

#ifndef DB_PROTOCOL_H_INCLUDED
#define DB_PROTOCOL_H_INCLUDED

#define RADIOTAP_LENGTH         13
#define DB_RAW_V2_HEADER_LENGTH 10
#define DB_MAX_ADAPTERS 4

#define MSP_DATA_LENTH          34      // size of MSP v1
#define MSP_V2_DATA_LENGTH      37      // size of MSP v2 frame
#define DB_RC_DATA_LENGTH                16                // size of DB_RC frame
#define DATA_UNI_LENGTH         2048        // max payload length for raw protocol
#define DB_RAW_OFFSET                        14      // when adhering the 802.11 header the payload is offset to not be overwritten by SQN
#define MAX_DB_DATA_LENGTH                (RADIOTAP_LENGTH + DB_RAW_V2_HEADER_LENGTH + DATA_UNI_LENGTH) // max length of a db raw packet
#define ETHER_TYPE              0x88ab

#define DEFAULT_DB_MODE         'm'
#define DEFAULT_DB_IF           "18a6f716a511"
#define DEFAULT_V2_COMMID                0xc8

#define DB_FRAMETYPE_RTS        1
#define DB_FRAMETYPE_DATA       2
#define DB_FRAMETYPE_BEACON     3
#define DB_FRAMETYPE_DEFAULT    DB_FRAMETYPE_DATA

#define NUM_CHANNELS            14      // max number of channels sent over DroneBridge control module (ground)
#define DB_RC_NUM_CHANNELS      12      // number of channels supported by DroneBridge RC protocol

#define DB_PORT_CONTROLLER  0x01
#define DB_PORT_TELEMETRY   0x02  // deprecated. Use proxy port for bidirectional telemetry
#define DB_PORT_VIDEO       0x03
#define DB_PORT_COMM                0x04
#define DB_PORT_STATUS                0x05
#define DB_PORT_PROXY                0x06
#define DB_PORT_RC                        0x07

#define DB_DIREC_DRONE      0x01 // packet to/for drone
#define DB_DIREC_GROUND           0x03 // packet to/for ground station

#define APP_PORT_STATUS     1602 // for all kinds of status protocol messages. Same port on ground station and app
#define APP_PORT_COMM       1603
#define APP_PORT_TELEMETRY  1604 // accepts MAVLink and LTM telemetry messages. Non MAVLink telemetry messages get rerouted internally to APP_PORT_PROXY
#define PORT_TCP_SYSLOG_SERVER 1605
#define APP_PORT_PROXY                 5760 // use this port for all MAVLink messages (TCP)
#define APP_PORT_PROXY_UDP        14550 // use this port for all MAVLink messages (UDP)
#define APP_PORT_VIDEO      5000 // app accepts raw H.264 streams
#define APP_PORT_VIDEO_FEC  5001 // app accepts raw DroneBridge video stream data, performs FEC on Android device

#define DB_MAVLINK_SYS_ID        69
#define        MAX_PENUMBRA_INTERFACES 8

#define DB_UNIX_DOMAIN_VIDEO_PATH   "/tmp/db_video_out"
#define DB_AP_CLIENT_IP             "192.168.2.1"   // default IP address of GCS connected via WiFi AP

#define DB_SYS_HID_ESP32 1

#endif // DB_PROTOCOL_H_INCLUDED
  schedule: /*
 *   This file is part of DroneBridge: https://github.com/seeul8er/DroneBridge
 *
 *   Copyright 2018 
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

#ifndef DB_ESP32_GLOBALS_H
#define DB_ESP32_GLOBALS_H

#include <freertos/event_groups.h>

#define MAX_LTM_FRAMES_IN_BUFFER 5
#define BUILDVERSION 6    //v0.6

// can be set by user
extern uint8_t DEFAULT_SSID[32];
extern uint8_t DEFAULT_PWD[64];
extern uint8_t DEFAULT_CHANNEL;
extern uint8_t SERIAL_PROTOCOL;  // 1,2=MSP, 3,4,5=MAVLink/transparent
extern uint8_t DB_UART_PIN_TX;
extern uint8_t DB_UART_PIN_RX;
extern uint32_t DB_UART_BAUD_RATE;
extern uint16_t TRANSPARENT_BUF_SIZE;
extern uint8_t LTM_FRAME_NUM_BUFFER;    // Number of LTM frames per UDP packet (min = 1; max = 5)
extern EventGroupHandle_t wifi_event_group;

#endif //DB_ESP32_GLOBALS_H
  - cron: /*
 *   This file is part of DroneBridge: https://github.com/seeul8er/DroneBridge
 *
 *   Copyright 2018 
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

#include <sys/socket.h>
#include <freertos/event_groups.h>
#include <esp_log.h>
#include <string.h>
#include <nvs.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "globals.h"
#include <math.h>
#include <driver/gpio.h>

#define LISTENQ 2
#define REQUEST_BUF_SIZE 1024
#define WEBSITE_RESPONSE_BUFFER_SIZE 3072
#define TAG "TCP_SERVER"

const char *save_response = "HTTP/1.1 200 OK\r\n"
                            "Server: DroneBridgeESP32\r\n"
                            "Content-type: text/html, text, plain\r\n"
                            "\r\n"
                            "<!DOCTYPE html>\n"
                            "<html>\n"
                            "<head>\n"
                            "  <style>\n"
                            "  .mytext {\n"
                            "    font-family: Verdana, Geneva, sans-serif;\n"
                            "    color: #FFFFF;\n"
                            "  }\n"
                            "  h1 {\n"
                            "    font-family: Verdana, Geneva, sans-serif;\n"
                            "    color: #FF7900;\n"
                            "  }\n"
                            "  </style>\n"
                            "<title>DB for ESP32 Settings</title>\n"
                            "<meta name=\"viewport\" content=\"width=device-width, user-scalable=no\" />\n"
                            "</head>\n"
                            "<body>\n"
                            "  <h1>DroneBridge for ESP32</h1>\n"
                            "  <p class=\"mytext\">Saved settings!</p>\n"
                            "  <a class=\"mytext\" href=\"/\">Back to settings</a>\n"
                            "</body>\n"
                            "</html>\n"
                            "";

const char *bad_gateway = "HTTP/1.1 502 Bad Gateway \r\n"
                          "Server: DroneBridgeESP32 \r\n"
                          "Content-Type: text/html \r\n"
                          "\r\n";

/**
 * @brief Check if we got a simple request or new settings
 * @param request_buffer
 * @param length
 * @return 0 if GET-Request, 1 if new settings, -1 if none
 */
int http_request_type(uint8_t *request_buffer, uint length) {
    uint8_t http_get_header[] = {'G', 'E', 'T', ' ', '/', ' ', 'H', 'T', 'T', 'P'};
    uint8_t http_get_header_settings[] = {'G', 'E', 'T', ' ', '/', 's', 'e', 't', 't', 'i', 'n', 'g', 's'};
    uint8_t http_get_header_other_data[] = {'G', 'E', 'T', ' ', '/'};
    if (memcmp(request_buffer, http_get_header, sizeof(http_get_header)) == 0) return 0;
    if (memcmp(request_buffer, http_get_header_settings, sizeof(http_get_header_settings)) == 0) return 1;
    if (memcmp(request_buffer, http_get_header_other_data, sizeof(http_get_header_other_data)) == 0) return 2;
    return -1;
}


void write_settings_to_nvs() {
    ESP_LOGI(TAG, "Saving to NVS");
    nvs_handle my_handle;
    ESP_ERROR_CHECK(nvs_open("settings", NVS_READWRITE, &my_handle));
    ESP_ERROR_CHECK(nvs_set_str(my_handle, "ssid", (char *) DEFAULT_SSID));
    ESP_ERROR_CHECK(nvs_set_str(my_handle, "wifi_pass", (char *) DEFAULT_PWD));
    ESP_ERROR_CHECK(nvs_set_u8(my_handle, "wifi_chan", DEFAULT_CHANNEL));
    ESP_ERROR_CHECK(nvs_set_u32(my_handle, "baud", DB_UART_BAUD_RATE));
    ESP_ERROR_CHECK(nvs_set_u8(my_handle, "gpio_tx", DB_UART_PIN_TX));
    ESP_ERROR_CHECK(nvs_set_u8(my_handle, "gpio_rx", DB_UART_PIN_RX));
    ESP_ERROR_CHECK(nvs_set_u8(my_handle, "proto", SERIAL_PROTOCOL));
    ESP_ERROR_CHECK(nvs_set_u16(my_handle, "trans_pack_size", TRANSPARENT_BUF_SIZE));
    ESP_ERROR_CHECK(nvs_set_u8(my_handle, "ltm_per_packet", LTM_FRAME_NUM_BUFFER));
    ESP_ERROR_CHECK(nvs_commit(my_handle));
    nvs_close(my_handle);
}


void parse_save_get_parameters(char *request_buffer, uint length) {
    ESP_LOGI(TAG, "Parsing new settings:");
    char *ptr;
    char delimiter[] = "?=& ";
    ptr = strtok(request_buffer, delimiter);
    while (ptr != NULL) {
        if (strcmp(ptr, "ssid") == 0) {
            ptr = strtok(NULL, delimiter);
            if (strlen(ptr) >= 1) {
                strcpy((char *) DEFAULT_SSID, ptr);
                for(size_t i = 0; i <= strlen((char *) DEFAULT_SSID); i++)
                    if(DEFAULT_SSID[i] == '+'){ DEFAULT_SSID[i] = ' '; }  // replace + with space
                ESP_LOGI(TAG, "New ssid: %s", DEFAULT_SSID);
            }
        } else if (strcmp(ptr, "wifi_pass") == 0) {
            ptr = strtok(NULL, delimiter);
            if (strlen(ptr) >= 8) {
                strcpy((char *) DEFAULT_PWD, ptr);
                ESP_LOGI(TAG, "New password: %s", DEFAULT_PWD);
            }
        } else if (strcmp(ptr, "wifi_chan") == 0) {
            ptr = strtok(NULL, delimiter);
            if (atoi(ptr) <= 13) DEFAULT_CHANNEL = atoi(ptr);
            ESP_LOGI(TAG, "New wifi channel: %i", DEFAULT_CHANNEL);
        } else if (strcmp(ptr, "baud") == 0) {
            ptr = strtok(NULL, delimiter);
            if (atoi(ptr) > 2399)
                DB_UART_BAUD_RATE = atoi(ptr);
            ESP_LOGI(TAG, "New baud: %i", DB_UART_BAUD_RATE);
        } else if (strcmp(ptr, "gpio_tx") == 0) {
            ptr = strtok(NULL, delimiter);
            if (atoi(ptr) <= GPIO_NUM_MAX) DB_UART_PIN_TX = atoi(ptr);
            ESP_LOGI(TAG, "New gpio_tx: %i", DB_UART_PIN_TX);
        } else if (strcmp(ptr, "gpio_rx") == 0) {
            ptr = strtok(NULL, delimiter);
            if (atoi(ptr) <= GPIO_NUM_MAX) DB_UART_PIN_RX = atoi(ptr);
            ESP_LOGI(TAG, "New gpio_rx: %i", DB_UART_PIN_RX);
        } else if (strcmp(ptr, "proto") == 0) {
            ptr = strtok(NULL, delimiter);
            if (strcmp(ptr, "msp_ltm") == 0) {
                SERIAL_PROTOCOL = 2;
            } else {
                SERIAL_PROTOCOL = 4;
            }
            ESP_LOGI(TAG, "New proto: %i", SERIAL_PROTOCOL);
        } else if (strcmp(ptr, "trans_pack_size") == 0) {
            ptr = strtok(NULL, delimiter);
            TRANSPARENT_BUF_SIZE = atoi(ptr);
            ESP_LOGI(TAG, "New trans_pack_size: %i", TRANSPARENT_BUF_SIZE);
        } else if (strcmp(ptr, "ltm_per_packet") == 0) {
            ptr = strtok(NULL, delimiter);
            LTM_FRAME_NUM_BUFFER = atoi(ptr);
            ESP_LOGI(TAG, "New ltm_per_packet: %i", LTM_FRAME_NUM_BUFFER);
        } else {
            ptr = strtok(NULL, delimiter);
        }
    }
    write_settings_to_nvs();
}


char *create_response(char *website_response) {
    char baud_selection1[9] = "";
    char baud_selection2[9] = "";
    char baud_selection3[9] = "";
    char baud_selection4[9] = "";
    char baud_selection5[9] = "";
    char baud_selection6[9] = "";
    char baud_selection7[9] = "";
    char uart_serial_selection1[9] = "";
    char uart_serial_selection2[9] = "";
    char trans_pack_size_selection1[9] = "";
    char trans_pack_size_selection2[9] = "";
    char trans_pack_size_selection3[9] = "";
    char trans_pack_size_selection4[9] = "";
    char trans_pack_size_selection5[9] = "";
    char ltm_size_selection1[9] = "";
    char ltm_size_selection2[9] = "";
    char ltm_size_selection3[9] = "";
    char ltm_size_selection4[9] = "", ltm_size_selection5[9] = "";

    switch (SERIAL_PROTOCOL) {
        default:
        case 1:
        case 2:
            strcpy(uart_serial_selection1, "selected");
            break;
        case 3:
        case 4:
        case 5:
            strcpy(uart_serial_selection2, "selected");
            break;
    }
    switch (TRANSPARENT_BUF_SIZE) {
        case 16:
            strcpy(trans_pack_size_selection1, "selected");
            break;
        case 32:
            strcpy(trans_pack_size_selection2, "selected");
            break;
        default:
        case 64:
            strcpy(trans_pack_size_selection3, "selected");
            break;
        case 128:
            strcpy(trans_pack_size_selection4, "selected");
            break;
        case 256:
            strcpy(trans_pack_size_selection5, "selected");
            break;
    }
    switch (LTM_FRAME_NUM_BUFFER) {
        default:
        case 1:
            strcpy(ltm_size_selection1, "selected");
            break;
        case 2:
            strcpy(ltm_size_selection2, "selected");
            break;
        case 3:
            strcpy(ltm_size_selection3, "selected");
            break;
        case 4:
            strcpy(ltm_size_selection4, "selected");
            break;
        case 5:
            strcpy(ltm_size_selection5, "selected");
            break;
    }
    switch (DB_UART_BAUD_RATE) {
        default:
        case 115200:
            strcpy(baud_selection1, "selected");
            break;
        case 57600:
            strcpy(baud_selection2, "selected");
            break;
        case 38400:
            strcpy(baud_selection3, "selected");
            break;
        case 19200:
            strcpy(baud_selection4, "selected");
            break;
        case 9600:
            strcpy(baud_selection5, "selected");
            break;
        case 4800:
            strcpy(baud_selection6, "selected");
            break;
        case 2400:
            strcpy(baud_selection7, "selected");
            break;
    }
    char build_version[16];
    sprintf(build_version, "v%.2f", floorf(BUILDVERSION) / 100);
    sprintf(website_response, "HTTP/1.1 200 OK\r\n"
                              "Server: DroneBridgeESP32\r\n"
                              "Content-type: text/html, text, plain\r\n"
                              "\r\n"
                              "<!DOCTYPE html><html><head><title>DB for ESP32 Settings</title>"
                              "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">"
                              "<style> "
                              "h1 { font-family: Verdana, Geneva, sans-serif; color: #FF7900; } "
                              "table.DroneBridge { font-family: Verdana, Geneva, sans-serif; background-color: #145396; text-align: right; border-collapse: collapse; } "
                              "table.DroneBridge td, table.DroneBridge th { padding: 6px 0px; } "
                              "table.DroneBridge tbody td { font-size: 1rm; font-weight: bold; color: #FFFFFF; padding: 0.5em; } "
                              "table.DroneBridge td:nth-child(even) { background: #FF7900; }"
                              "@media only screen and (max-width:768px) { .DroneBridge {width:100%%; }}"
                              ".foot{color: #145396;font-family: Verdana, Geneva, sans-serif;font-size: 0.8em;}"
                              "</style>"
                              "</head>\n"
                              "<body><h1>DroneBridge for ESP32</h1>"
                              "<form action=\"/settings.html\" id=\"settings_form\" method=\"get\" target=\"_blank\">"
                              "<table class=\"DroneBridge\"><tbody>"
                              "<tr><td>Wifi SSID</td>"
                              "<td><input type=\"text\" name=\"ssid\" value=\"%s\"></td></tr>"
                              "<tr><td>Wifi password</td>"
                              "<td><input type=\"text\" name=\"wifi_pass\" value=\"%s\"></td></tr>"
                              "<tr><td>Wifi channel</td>"
                              "<td><input type=\"number\" name=\"wifi_chan\" min=\"0\" max=\"13\" value=\"%i\"></td></tr>"
                              "<tr><td>UART baud rate</td><td>"
                              "<select name=\"baud\" form=\"settings_form\">"
                              "<option %s value=\"115200\">115200</option>"
                              "<option %s value=\"57600\">57600</option>"
                              "<option %s value=\"38400\">38400</option>"
                              "<option %s value=\"19200\">19200</option>"
                              "<option %s value=\"9600\">9600</option>"
                              "<option %s value=\"4800\">4800</option>"
                              "<option %s value=\"2400\">2400</option>"
                              "</select>"
                              "</td></tr><tr><td>GPIO TX pin number</td>"
                              "<td><input type=\"text\" name=\"gpio_tx\" value=\"%i\"></td></tr>"
                              "<tr><td>GPIO RX pin number</td><td>"
                              "<input type=\"text\" name=\"gpio_rx\" value=\"%i\">"
                              "</td></tr><tr><td>UART serial protocol</td><td>"
                              "<select name=\"proto\" form=\"settings_form\">"
                              "<option %s value=\"msp_ltm\">MSP/LTM</option>"
                              "<option %s value=\"trans\">Transparent/MAVLink</option>"
                              "</select>"
                              "</td></tr><tr><td>Transparent packet size</td><td>"
                              "<select name=\"trans_pack_size\" form=\"settings_form\">"
                              "<option %s value=\"16\">16</option><option %s value=\"32\">32</option>"
                              "<option %s value=\"64\">64</option><option %s value=\"128\">128</option>"
                              "<option %s value=\"256\">256</option>"
                              "</select>"
                              "</td></tr><tr><td>LTM frames per packet</td><td>"
                              "<select name=\"ltm_per_packet\" form=\"settings_form\">"
                              "<option %s value=\"1\">1</option>"
                              "<option %s value=\"2\">2</option>"
                              "<option %s value=\"3\">3</option>"
                              "<option %s value=\"4\">4</option>"
                              "<option %s value=\"5\">5</option>"
                              "</select>"

                              "</td></tr><tr><td></td><td>"
                              "</td></tr></tbody></table><p></p>"

                              "<input target= \"_top\" type=\"submit\" value=\"Save\">"
                              "</form>"
                              "<p class=\"foot\">%s</p>\n"
                              "<p class=\"foot\">&copy; Wolfgang Christl 2018 - Apache 2.0 License</p>"
                              "</body></html>\n"
                              "", DEFAULT_SSID, DEFAULT_PWD, DEFAULT_CHANNEL, baud_selection1, baud_selection2, baud_selection3, baud_selection4,
            baud_selection5, baud_selection6, baud_selection7, DB_UART_PIN_TX, DB_UART_PIN_RX, uart_serial_selection1,
            uart_serial_selection2, trans_pack_size_selection1, trans_pack_size_selection2, trans_pack_size_selection3,
            trans_pack_size_selection4, trans_pack_size_selection5, ltm_size_selection1, ltm_size_selection2,
            ltm_size_selection3, ltm_size_selection4, ltm_size_selection5, build_version);
    return website_response;
}

void http_settings_server(void *parameter) {
    ESP_LOGI(TAG, "http_settings_server task started");
    struct sockaddr_in tcpServerAddr;
    tcpServerAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    tcpServerAddr.sin_family = AF_INET;
    tcpServerAddr.sin_port = htons(80);
    int tcp_socket, r;
    char recv_buf[64];
    static struct sockaddr_in remote_addr;
    static unsigned int socklen;
    socklen = sizeof(remote_addr);
    xEventGroupWaitBits(wifi_event_group, BIT2, false, true, portMAX_DELAY);
    while (1) {
        tcp_socket = socket(AF_INET, SOCK_STREAM, 0);
        if (tcp_socket < 0) {
            ESP_LOGE(TAG, "... Failed to allocate socket");
            vTaskDelay(1000 / portTICK_PERIOD_MS);
            continue;
        }
        if (bind(tcp_socket, (struct sockaddr *) &tcpServerAddr, sizeof(tcpServerAddr)) != 0) {
            ESP_LOGE(TAG, "... socket bind failed errno=%d", errno);
            close(tcp_socket);
            vTaskDelay(4000 / portTICK_PERIOD_MS);
            continue;
        }
        if (listen(tcp_socket, LISTENQ) != 0) {
            ESP_LOGE(TAG, "... socket listen failed errno=%d", errno);
            close(tcp_socket);
            vTaskDelay(4000 / portTICK_PERIOD_MS);
            continue;
        }
        uint8_t *request_buffer = malloc(REQUEST_BUF_SIZE * sizeof(uint8_t));
        // char *website_response = malloc(WEBSITE_RESPONSE_BUFFER_SIZE*sizeof(char));
        char website_response[WEBSITE_RESPONSE_BUFFER_SIZE];
        while (1) {
            int client_socket = accept(tcp_socket, (struct sockaddr *) &remote_addr, &socklen);
            fcntl(client_socket, F_SETFL, O_NONBLOCK);
            uint rec_length = 0;
            do {
                bzero(recv_buf, sizeof(recv_buf));
                r = recv(client_socket, recv_buf, sizeof(recv_buf) - 1, 0);
                if (r > 0) {
                    if (REQUEST_BUF_SIZE >= (rec_length + r)) {
                        memcpy(&request_buffer[rec_length], recv_buf, (size_t) r);
                        rec_length += r;
                    } else {
                        ESP_LOGE(TAG, "Request bigger than buffer");
                    }
                }
            } while (r > 0);
            // prints the requests for debugging
//            ESP_LOGI(TAG2,"New connection request,Request data:");
//            for(int i = 0; i < rec_length; i++) {
//                putchar(request_buffer[i]);
//            }
            int http_req = http_request_type(request_buffer, rec_length);
            if (http_req == 0) {
                char *response = create_response(website_response);
                if (write(client_socket, response, strlen(response)) < 0) {
                    ESP_LOGE(TAG, "... Send failed");
                    close(tcp_socket);
                    vTaskDelay(4000 / portTICK_PERIOD_MS);
                    continue;
                }
            } else if (http_req == 1) {
                parse_save_get_parameters((char *) request_buffer, rec_length);
                if (write(client_socket, save_response, strlen(save_response)) < 0) {
                    ESP_LOGE(TAG, "... Send failed");
                    close(tcp_socket);
                    vTaskDelay(4000 / portTICK_PERIOD_MS);
                    continue;
                }
            } else if (http_req == 2) {
                if (write(client_socket, bad_gateway, strlen(bad_gateway)) < 0) {
                    ESP_LOGE(TAG, "... Send failed");
                    close(tcp_socket);
                    vTaskDelay(4000 / portTICK_PERIOD_MS);
                    continue;
                }
            }
            close(client_socket);
        }
        //free(website_response);
        free(request_buffer);
        vTaskDelay(5000 / portTICK_PERIOD_MS);
    }
    ESP_LOGI(TAG, "...tcp_client task closed\n");
    vTaskDelete(NULL);
}


/**
 * @brief Starts a TCP server that serves the page to change settings & handles the changes
 */
void start_tcp_server() {
    xTaskCreate(&http_settings_server, "http_settings_server", 10240, NULL, 5, NULL);
} 

jobs: /*
 *   This file is part of DroneBridge: https://github.com/seeul8er/DroneBridge
 *
 *   Copyright 2018 
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

#ifndef DB_ESP32_HTTP_SERVER_H
#define DB_ESP32_HTTP_SERVER_H

void start_tcp_server();
void write_settings_to_nvs();

#endif //DB_ESP32_HTTP_SERVER_H
  stale: /*
 *   This file is part of DroneBridge: https://github.com/seeul8er/DroneBridge
 *
 *   Copyright 2018 
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

#include <stdio.h>
#include <nvs_flash.h>
#include <esp_wifi_types.h>
#include <mdns.h>
#include <string.h>
#include <driver/gpio.h>
#include "freertos/event_groups.h"
#include "esp_wifi.h"
#include "esp_log.h"
#include "esp_event.h"
#include "db_esp32_control.h"
#include "http_server.h"
#include "db_esp32_comm.h"
#include "db_protocol.h"

EventGroupHandle_t wifi_event_group;
static const char *TAG = "DB_ESP32";

uint8_t DEFAULT_SSID[32] = "DroneBridge ESP32";
uint8_t DEFAULT_PWD[64] = "dronebridge";
uint8_t DEFAULT_CHANNEL = 6;
uint8_t SERIAL_PROTOCOL = 2;  // 1,2=MSP, 3,4,5=MAVLink/transparent
uint8_t DB_UART_PIN_TX = GPIO_NUM_17;
uint8_t DB_UART_PIN_RX = GPIO_NUM_16;
uint32_t DB_UART_BAUD_RATE = 115200;
uint16_t TRANSPARENT_BUF_SIZE = 64;
uint8_t LTM_FRAME_NUM_BUFFER = 1;

static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)
{
    wifi_event_ap_staconnected_t *event;
    wifi_event_ap_stadisconnected_t* evente;
    switch (event_id) {
        case SYSTEM_EVENT_AP_START:
            ESP_LOGI(TAG, "Wifi AP started!");
            xEventGroupSetBits(wifi_event_group, BIT2);
            break;
        case SYSTEM_EVENT_AP_STOP:
            ESP_LOGI(TAG, "Wifi AP stopped!");
            break;
        case SYSTEM_EVENT_AP_STACONNECTED:
            event = (wifi_event_ap_staconnected_t *) event_data;
            ESP_LOGI(TAG, "Client connected - station:"MACSTR", AID=%d", MAC2STR(event->mac), event->aid);
            break;
        case SYSTEM_EVENT_AP_STADISCONNECTED:
            evente = (wifi_event_ap_stadisconnected_t*) event_data;
            ESP_LOGI(TAG, "Client disconnected - station:"MACSTR", AID=%d",
                     MAC2STR(evente->mac), evente->aid);
            break;
        default:
            break;
    }
}

void start_mdns_service()
{
    xEventGroupWaitBits(wifi_event_group, BIT2, false, true, portMAX_DELAY);
    //initialize mDNS service
    esp_err_t err = mdns_init();
    if (err) {
        printf("MDNS Init failed: %d\n", err);
        return;
    }
    ESP_ERROR_CHECK(mdns_hostname_set("dronebridge"));
    ESP_ERROR_CHECK(mdns_instance_name_set("DroneBridge for ESP32"));

    ESP_ERROR_CHECK(mdns_service_add(NULL, "_http", "_tcp", 80, NULL, 0));
    ESP_ERROR_CHECK(mdns_service_add(NULL, "_db_proxy", "_tcp", APP_PORT_PROXY, NULL, 0));
    ESP_ERROR_CHECK(mdns_service_add(NULL, "_db_comm", "_tcp", APP_PORT_COMM, NULL, 0));
    ESP_ERROR_CHECK(mdns_service_instance_name_set("_http", "_tcp", "DroneBridge for ESP32"));
}


void init_wifi(){
    wifi_event_group = xEventGroupCreate();
    tcpip_adapter_init();
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL));

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));
    wifi_config_t ap_config = {
            .ap = {
                    .ssid = "Init DroneBridge ESP32",
                    .ssid_len = 0,
                    .authmode = WIFI_AUTH_WPA_PSK,
                    .channel = DEFAULT_CHANNEL,
                    .ssid_hidden = 0,
                    .beacon_interval = 100,
                    .max_connection = 10
            },
    };
    xthal_memcpy(ap_config.ap.ssid, DEFAULT_SSID, 32);
    xthal_memcpy(ap_config.ap.password, DEFAULT_PWD, 64);
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_protocol(ESP_IF_WIFI_AP, WIFI_PROTOCOL_11B));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &ap_config));
    wifi_country_t wifi_country = {.cc = "XX", .schan = 1, .nchan = 13, .policy = WIFI_COUNTRY_POLICY_MANUAL};
    ESP_ERROR_CHECK(esp_wifi_set_country(&wifi_country));
    ESP_ERROR_CHECK(esp_wifi_start());
    ESP_ERROR_CHECK(tcpip_adapter_set_hostname(TCPIP_ADAPTER_IF_AP, "DBESP32"));

    ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));
    tcpip_adapter_ip_info_t ip_info;
    IP4_ADDR(&ip_info.ip, 192,168,2,1);
    IP4_ADDR(&ip_info.gw, 192,168,2,1);
    IP4_ADDR(&ip_info.netmask, 255,255,255,0);
    ESP_ERROR_CHECK(tcpip_adapter_set_ip_info(TCPIP_ADAPTER_IF_AP, &ip_info));
    ESP_ERROR_CHECK(tcpip_adapter_dhcps_start(TCPIP_ADAPTER_IF_AP));
}


void read_settings_nvs(){
    nvs_handle my_handle;
    if (nvs_open("settings", NVS_READONLY, &my_handle) == ESP_ERR_NVS_NOT_FOUND){
        // First start
        nvs_close(my_handle);
        write_settings_to_nvs();
    } else {
        ESP_LOGI(TAG, "Reading settings from NVS");
        size_t required_size = 0;
        ESP_ERROR_CHECK(nvs_get_str(my_handle, "ssid", NULL, &required_size));
        char* ssid = malloc(required_size);
        ESP_ERROR_CHECK(nvs_get_str(my_handle, "ssid", ssid, &required_size));
        memcpy(DEFAULT_SSID, ssid, required_size);

        ESP_ERROR_CHECK(nvs_get_str(my_handle, "wifi_pass", NULL, &required_size));
        char* wifi_pass = malloc(required_size);
        ESP_ERROR_CHECK(nvs_get_str(my_handle, "wifi_pass", wifi_pass, &required_size));
        memcpy(DEFAULT_PWD, wifi_pass, required_size);

        ESP_ERROR_CHECK(nvs_get_u8(my_handle, "wifi_chan", &DEFAULT_CHANNEL));
        ESP_ERROR_CHECK(nvs_get_u32(my_handle, "baud", &DB_UART_BAUD_RATE));
        ESP_ERROR_CHECK(nvs_get_u8(my_handle, "gpio_tx", &DB_UART_PIN_TX));
        ESP_ERROR_CHECK(nvs_get_u8(my_handle, "gpio_rx", &DB_UART_PIN_RX));
        ESP_ERROR_CHECK(nvs_get_u8(my_handle, "proto", &SERIAL_PROTOCOL));
        ESP_ERROR_CHECK(nvs_get_u16(my_handle, "trans_pack_size", &TRANSPARENT_BUF_SIZE));
        ESP_ERROR_CHECK(nvs_get_u8(my_handle, "ltm_per_packet", &LTM_FRAME_NUM_BUFFER));
        nvs_close(my_handle);
        free(wifi_pass);
        free(ssid);
    }
}


void app_main()
{
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    read_settings_nvs();
    esp_log_level_set("*", ESP_LOG_INFO);
    init_wifi();
    start_mdns_service();
    control_module();
    start_tcp_server();
    communication_module();
}

    runs-on: /*
 *   This file is part of DroneBridge: https://github.com/seeul8er/DroneBridge
 *
 *   Copyright 2018 
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

#include <stdbool.h>
#include <stdint.h>
#include "msp_ltm_serial.h"
#include "db_crc.h"

/**
 * This function is part of Cleanflight/iNAV.
 *
 * Optimized for crc performance in the DroneBridge project and ">" & "<" adjusted
 * LTM telemetry parsing added by Wolfgang Christl
 *
 * Cleanflight is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Cleanflight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Cleanflight.  If not, see <http://www.gnu.org/licenses/>.
 */
bool parse_msp_ltm_byte(msp_ltm_port_t *msp_ltm_port, uint8_t new_byte) {
    switch (msp_ltm_port->parse_state) {
        default:
        case IDLE:
            if (new_byte == '$') {
                msp_ltm_port->mspVersion = MSP_V1;
                msp_ltm_port->parse_state = HEADER_START;
                msp_ltm_port->ltm_frame_buffer[0] = '$';
            } else { return false; }
            msp_ltm_port->ltm_payload_cnt = 0;
            msp_ltm_port->checksum1 = 0;
            break;

        case HEADER_START:
            switch (new_byte) {
                case 'M':
                    msp_ltm_port->parse_state = MSP_HEADER_M;
                    break;
                case 'X':
                    msp_ltm_port->parse_state = MSP_HEADER_X;
                    break;
                case 'T':
                    msp_ltm_port->parse_state = LTM_HEADER;
                    msp_ltm_port->ltm_frame_buffer[1] = 'T';
                    break;
                default:
                    msp_ltm_port->parse_state = IDLE;
                    break;
            }
            break;

        case LTM_HEADER:
            switch (new_byte) {
                case 'A':
                    msp_ltm_port->ltm_type = LTM_TYPE_A;
                    msp_ltm_port->parse_state = LTM_TYPE_IDENT;
                    break;
                case 'G':
                    msp_ltm_port->ltm_type = LTM_TYPE_G;
                    msp_ltm_port->parse_state = LTM_TYPE_IDENT;
                    break;
                case 'N':
                    msp_ltm_port->ltm_type = LTM_TYPE_N;
                    msp_ltm_port->parse_state = LTM_TYPE_IDENT;
                    break;
                case 'O':
                    msp_ltm_port->ltm_type = LTM_TYPE_O;
                    msp_ltm_port->parse_state = LTM_TYPE_IDENT;
                    break;
                case 'S':
                    msp_ltm_port->ltm_type = LTM_TYPE_S;
                    msp_ltm_port->parse_state = LTM_TYPE_IDENT;
                    break;
                case 'X':
                    msp_ltm_port->ltm_type = LTM_TYPE_X;
                    msp_ltm_port->parse_state = LTM_TYPE_IDENT;
                    break;
                default:
                    msp_ltm_port->parse_state = IDLE;
                    break;
            }
            msp_ltm_port->ltm_frame_buffer[2] = new_byte;
            msp_ltm_port->ltm_payload_cnt = 0;
            break;

        case LTM_TYPE_IDENT:
            msp_ltm_port->ltm_payload_cnt++;
            msp_ltm_port->ltm_frame_buffer[2 + msp_ltm_port->ltm_payload_cnt] = new_byte;
            msp_ltm_port->checksum1 ^= new_byte;
            switch (msp_ltm_port->ltm_type) {
                case LTM_TYPE_A:
                case LTM_TYPE_N:
                case LTM_TYPE_X:
                    if (msp_ltm_port->ltm_payload_cnt == LTM_TYPE_A_PAYLOAD_SIZE) msp_ltm_port->parse_state = LTM_CRC;
                    break;
                case LTM_TYPE_G:
                case LTM_TYPE_O:
                    if (msp_ltm_port->ltm_payload_cnt == LTM_TYPE_G_PAYLOAD_SIZE) msp_ltm_port->parse_state = LTM_CRC;
                    break;
                case LTM_TYPE_S:
                    if (msp_ltm_port->ltm_payload_cnt == LTM_TYPE_S_PAYLOAD_SIZE) msp_ltm_port->parse_state = LTM_CRC;
                    break;
                default:
                    msp_ltm_port->parse_state = IDLE;
                    break;
            }
            break;

        case LTM_CRC:
            msp_ltm_port->ltm_frame_buffer[3 + msp_ltm_port->ltm_payload_cnt] = new_byte;
            if (msp_ltm_port->checksum1 == new_byte) {
                msp_ltm_port->parse_state = LTM_PACKET_RECEIVED;
            } else {
                msp_ltm_port->parse_state = IDLE;
            }
            break;

        case MSP_HEADER_M:
            if (new_byte == '>') {
                msp_ltm_port->offset = 0;
                msp_ltm_port->checksum1 = 0;
                msp_ltm_port->checksum2 = 0;
                msp_ltm_port->parse_state = MSP_HEADER_V1;
            } else {
                msp_ltm_port->parse_state = IDLE;
            }
            break;

        case MSP_HEADER_X:
            if (new_byte == '>') {
                msp_ltm_port->offset = 0;
                msp_ltm_port->checksum2 = 0;
                msp_ltm_port->mspVersion = MSP_V2_NATIVE;
                msp_ltm_port->parse_state = MSP_HEADER_V2_NATIVE;
            } else {
                msp_ltm_port->parse_state = IDLE;
            }
            break;

        case MSP_HEADER_V1:
            msp_ltm_port->inBuf[msp_ltm_port->offset++] = new_byte;
            msp_ltm_port->checksum1 ^= new_byte;
            if (msp_ltm_port->offset == sizeof(mspHeaderV1_t)) {
                mspHeaderV1_t *hdr = (mspHeaderV1_t *) &msp_ltm_port->inBuf[0];
                // Check incoming buffer size limit
                if (hdr->size > MSP_PORT_INBUF_SIZE) {
                    msp_ltm_port->parse_state = IDLE;
                } else if (hdr->cmd == MSP_V2_FRAME_ID) {
                    if (hdr->size >= sizeof(mspHeaderV2_t) + 1) {
                        msp_ltm_port->mspVersion = MSP_V2_OVER_V1;
                        msp_ltm_port->parse_state = MSP_HEADER_V2_OVER_V1;
                    } else {
                        msp_ltm_port->parse_state = IDLE;
                    }
                } else {
                    msp_ltm_port->dataSize = hdr->size;
                    msp_ltm_port->cmdMSP = hdr->cmd;
                    msp_ltm_port->cmdFlags = 0;
                    msp_ltm_port->offset = 0;
                    msp_ltm_port->parse_state = msp_ltm_port->dataSize > 0 ? MSP_PAYLOAD_V1 : MSP_CHECKSUM_V1;
                }
            }
            break;

        case MSP_PAYLOAD_V1:
            msp_ltm_port->inBuf[msp_ltm_port->offset++] = new_byte;
            msp_ltm_port->checksum1 ^= new_byte;
            if (msp_ltm_port->offset == msp_ltm_port->dataSize) {
                msp_ltm_port->parse_state = MSP_CHECKSUM_V1;
            }
            break;

        case MSP_CHECKSUM_V1:
            if (msp_ltm_port->checksum1 == new_byte) {
                msp_ltm_port->parse_state = MSP_PACKET_RECEIVED;
            } else {
                msp_ltm_port->parse_state = IDLE;
            }
            break;

        case MSP_HEADER_V2_OVER_V1:
            msp_ltm_port->inBuf[msp_ltm_port->offset++] = new_byte;
            msp_ltm_port->checksum1 ^= new_byte;
            msp_ltm_port->checksum2 = crc8_dvb_s2_table(msp_ltm_port->checksum2, new_byte);
            if (msp_ltm_port->offset == (sizeof(mspHeaderV2_t) + sizeof(mspHeaderV1_t))) {
                mspHeaderV2_t *hdrv2 = (mspHeaderV2_t *) &msp_ltm_port->inBuf[sizeof(mspHeaderV1_t)];
                msp_ltm_port->dataSize = hdrv2->size;
                if (hdrv2->size > MSP_PORT_INBUF_SIZE) {
                    msp_ltm_port->parse_state = IDLE;
                } else {
                    msp_ltm_port->cmdMSP = hdrv2->cmd;
                    msp_ltm_port->cmdFlags = hdrv2->flags;
                    msp_ltm_port->offset = 0;
                    msp_ltm_port->parse_state =
                            msp_ltm_port->dataSize > 0 ? MSP_PAYLOAD_V2_OVER_V1 : MSP_CHECKSUM_V2_OVER_V1;
                }
            }
            break;

        case MSP_PAYLOAD_V2_OVER_V1:
            msp_ltm_port->checksum2 = crc8_dvb_s2_table(msp_ltm_port->checksum2, new_byte);
            msp_ltm_port->checksum1 ^= new_byte;
            msp_ltm_port->inBuf[msp_ltm_port->offset++] = new_byte;

            if (msp_ltm_port->offset == msp_ltm_port->dataSize) {
                msp_ltm_port->parse_state = MSP_CHECKSUM_V2_OVER_V1;
            }
            break;

        case MSP_CHECKSUM_V2_OVER_V1:
            msp_ltm_port->checksum1 ^= new_byte;
            if (msp_ltm_port->checksum2 == new_byte) {
                msp_ltm_port->parse_state = MSP_CHECKSUM_V1;
            } else {
                msp_ltm_port->parse_state = IDLE;
            }
            break;

        case MSP_HEADER_V2_NATIVE:
            msp_ltm_port->inBuf[msp_ltm_port->offset++] = new_byte;
            msp_ltm_port->checksum2 = crc8_dvb_s2_table(msp_ltm_port->checksum2, new_byte);
            if (msp_ltm_port->offset == sizeof(mspHeaderV2_t)) {
                mspHeaderV2_t *hdrv2 = (mspHeaderV2_t *) &msp_ltm_port->inBuf[0];
                if (hdrv2->size > MSP_PORT_INBUF_SIZE) {
                    msp_ltm_port->parse_state = IDLE;
                } else {
                    msp_ltm_port->dataSize = hdrv2->size;
                    msp_ltm_port->cmdMSP = hdrv2->cmd;
                    msp_ltm_port->cmdFlags = hdrv2->flags;
                    msp_ltm_port->offset = 0;
                    msp_ltm_port->parse_state =
                            msp_ltm_port->dataSize > 0 ? MSP_PAYLOAD_V2_NATIVE : MSP_CHECKSUM_V2_NATIVE;
                }
            }
            break;

        case MSP_PAYLOAD_V2_NATIVE:
            msp_ltm_port->checksum2 = crc8_dvb_s2_table(msp_ltm_port->checksum2, new_byte);
            msp_ltm_port->inBuf[msp_ltm_port->offset++] = new_byte;

            if (msp_ltm_port->offset == msp_ltm_port->dataSize) {
                msp_ltm_port->parse_state = MSP_CHECKSUM_V2_NATIVE;
            }
            break;

        case MSP_CHECKSUM_V2_NATIVE:
            if (msp_ltm_port->checksum2 == new_byte) {
                msp_ltm_port->parse_state = MSP_PACKET_RECEIVED;
            } else {
                msp_ltm_port->parse_state = IDLE;
            }
            break;
    }
    return true;
}
    permissions:
      issues: write
      pull-requests: write

    steps:
    - uses: actions/stale@v5
      with:
        repo-token: ${{ secrets.GITHUB_TOKEN }}
        stale-issue-message: 'Stale issue message'
        stale-pr-message: 'Stale pull request message'
        stale-issue-label: 'no-issue-activity'
        stale-pr-label: 'no-pr-activity'

name: Jekyll site CI

on: # This lets you log in via `eb ssh` and access the docker daemon.
# If we don't add the ec2-user to the docker group, then calls to docker
# (like `docker ps`) will fail with `Cannot connect to the Docker daemon`
#
# See: https://blog.cloudinvaders.com/connect-to-docker-daemon-on-aws-beanstalk-ec2-instance/
commands:
  0_add_docker_group_to_ec2_user:
    command: gpasswd -a ec2-user docker
    test: groups ec2-user | grep -qv docker 
  push: {"__symbol_cache_version__":11} 
    branches: [ "main" ]
  pull_request: <?php

phutil_register_library('customlib', __FILE__); 
    branches: [ "main" ]

jobs: <?php

/**
 * This file is automatically generated. Use 'arc liberate' to rebuild it.
 *
 * @generated
 * @phutil-library-version 2
 */
phutil_register_library_map(array(
  '__library_version__' => 2,
  'class' => array(),
  'function' => array(),
  'xmap' => array(),
)); 
  build: <?php

namespace VisitCounter\Db;

interface DbAdapterInterface
{
    public function save(array $data);
} 

    runs-on: <?php

namespace VisitCounter\Db;

class PdoAdapter implements DbAdapterInterface
{
    private $connection;

    protected $pk;
    protected $tblName;
    protected $colName;

    public function __construct($connection, $tblName, $colName, $pk = 'id')
    {
        $this->connection = $connection;
        $this->tblName = $tblName;
        $this->colName = $colName;
        $this->pk = $pk;
    }

    public function save(array $visitsPages)
    {
        if (!$this->tblName or !$this->colName) {
            $message = "Properties tblName and colName are mandatory.";
            throw new \VisitCounter\Exception\RedisException($message);
        }
        try {
            foreach ($visitsPages as $visitCount => $pages) {
                $pageList = implode(',', $pages);
                $sql = "UPDATE {$this->tblName}
                        SET {$this->colName} = {$this->colName} + $visitCount
                        WHERE {$this->pk} IN ({$pageList})";
                $sth = $this->connection->prepare($sql);
                $sth->execute();
            }
        } catch (\PDOException $e) {
            throw new \VisitCounter\Exception\DbException($e->getMessage(), 0, $e);
        }
    }
} 

    steps: <?php

namespace VisitCounter\Exception;

class DbException extends \Exception
{
} 
    - uses: <?php

namespace VisitCounter\Exception;

class RedisException extends \Exception
{
} 
    - name: <?php

namespace VisitCounter\Redis;

interface RedisAdapterInterface
{
    public function setnx($keyName, $expire, $value = '');
    public function rpush($listName, $value);
    public function llen($listName);
    public function lrange($listName, $start = 0, $end = -1);
    public function ltrim($listName, $start, $end = -1);
    public function hincrby($hashName, $field, $count = 1);
    public function hmget($hashName, array $fields);
} 
      run: |
        docker run \
        -v ${{ <?php

namespace VisitCounter\Redis;

class RediskaAdapter implements RedisAdapterInterface
{
    private $client;

    public function __construct(\Rediska $client)
    {
        $this->client = $client;
    }

    public function setnx($keyName, $expire, $value = '')
    {
        $command = new \Rediska_Command_Set(
            $this->client,
            'Set',
            array($keyName, $value, false)
        );
        try {
            if ( !$command->execute() ) return false;
            $key = new \Rediska_Key($keyName);
            $key->expire($expire);
        } catch (\Rediska_Exception $e) {
            throw new \VisitCounter\Exception\RedisException($e->getMessage(), 0, $e);
        }
        return true;
    }

    public function rpush($listName, $value)
    {
        $key = new \Rediska_Key_List($listName);
        try {
            $key->append($value);
        } catch (\Rediska_Exception $e) {
            throw new \VisitCounter\Exception\RedisException($e->getMessage(), 0, $e);
        }
        return true;
    }

    public function llen($listName)
    {
        $key = new \Rediska_Key_List($listName);
        try {
            $length = $key->getLength();
        } catch (\Rediska_Exception $e) {
            throw new \VisitCounter\Exception\RedisException($e->getMessage(), 0, $e);
        }
        return $length;
    }

    public function lrange($listName, $start = 0, $end = -1)
    {
        $key = new \Rediska_Key_List($listName);
        try {
            $result = $key->getValues($start, $end);
        } catch (\Rediska_Exception $e) {
            throw new \VisitCounter\Exception\RedisException($e->getMessage(), 0, $e);
        }
        return $result;
    }

    public function ltrim($listName, $start = 0, $end = -1)
    {
        $key = new \Rediska_Key_List($listName);
        try {
            $key->truncate($start, $end);
        } catch (\Rediska_Exception $e) {
            throw new \VisitCounter\Exception\RedisException($e->getMessage(), 0, $e);
        }
        return true;
    }

    public function hincrby($hashName, $field, $count = 1)
    {
        $key = new \Rediska_Key_Hash($hashName);
        try {
            $key->increment($field, $count);
        } catch (\Rediska_Exception $e) {
            throw new \VisitCounter\Exception\RedisException($e->getMessage(), 0, $e);
        }
        return true;
    }

    public function hmget($hashName, array $fields)
    {
        $key = new \Rediska_Key_Hash($hashName);
        try {
            $result = $key->get($fields);
        } catch (\Rediska_Exception $e) {
            throw new \VisitCounter\Exception\RedisException($e->getMessage(), 0, $e);
        }
        return array_combine($fields, $result);
    }
} }}:/srv/jekyll -v ${{ 


/*
**        Description:        To decode the data, encoded using 3 character encoding technique.
*/





#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

void ThreeCharacterEncoding_Decode(uint8_t byte3, uint8_t byte2, uint8_t byte1, uint32_t *decodedOutput);

int main(void)
{
        uint32_t forDecodingDebug;
        uint8_t byte3, byte2, byte1;
        while(1)
        {
                printf("Input 3 bytes of data : \n");
                scanf("%u%u%u", &byte3, &byte2, &byte1);
                ThreeCharacterEncoding_Decode(byte3, byte2, byte1, &forDecodingDebug);
                printf("Decoded Value = %d\n", forDecodingDebug);
        }
}


/*
**        @brief                                                                                        Function to decode the 3 character encoding, to extract the encoded distance.
**        @byte3(PARAM_IN)                                                Higher encoded byte.
**        @byte2(PARAM_IN)                                                High encoded byte.
**        @byte1(PARAM_IN)                                                Low encoded byte.
**        @decodedOutput(PARAM_OUT)                Pointer to the variable which will contain the decoded output.
*/
void ThreeCharacterEncoding_Decode(uint8_t byte3, uint8_t byte2, uint8_t byte1, uint32_t *decodedOutput)
{
        uint8_t temp_byte1;
        uint8_t temp_byte2;
        uint8_t temp_byte3;

        /*        Decryption starts with subtracting 0x30 from each of the encoded bytes        */
        temp_byte3 = byte3 - 0x30;
        temp_byte2 = byte2 - 0x30;
        temp_byte1 = byte1 - 0x30;

        /*        Reset all bits of the output variable        */
        *decodedOutput &= ~(*decodedOutput);

        /*        Populate the output variable with decoded data        */
        *decodedOutput |= (temp_byte3 << 12);
        *decodedOutput |= (temp_byte2 << 6);
        *decodedOutput |= (temp_byte1 << 0);

        return;
} }}/_site:/srv/jekyll/_site \
        jekyll/builder:latest /bin/bash -c "chmod -R 777 /srv/jekyll && jekyll build --future"

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: MobSF

on: #!/usr/bin/env perl -w    # -*- cperl; cperl-indent-level: 4 -*-
# Copyright (C) 2008-2019
use strict;
use warnings;

use utf8;
use 5.014000;

BEGIN { our $VERSION = v1.1.1; }

use Date::Extract::P800Picture;

use English qw(-no_match_vars);
use Exception::Class;
use File::Basename;
use Getopt::Long;
use Log::Log4perl qw(:easy get_logger);
use Pod::Usage;
use Pod::Usage::CommandLine;

use Readonly;
## no critic (ProhibitCallsToUnexportedSubs)
Readonly::Scalar my $LOG_CONF    => q{p800date_log.conf};
Readonly::Array my @DEBUG_LEVELS => ( $FATAL, $INFO, $WARN, $DEBUG );
Readonly::Hash my %LOG           => (
    'FILENAME' => q{Processing filename '%s'},
    'NO_PRINT' => q{Could not print},
);
Readonly::Array my @GETOPT_CONFIG =>
  qw(no_ignore_case bundling auto_version auto_help);
Readonly::Array my @GETOPTIONS  => (q{verbose|v+});
Readonly::Hash my %OPTS_DEFAULT => ();
## use critic

Getopt::Long::Configure(@GETOPT_CONFIG);
my %opts = %OPTS_DEFAULT;
Getopt::Long::GetOptions( \%opts, @GETOPTIONS ) or Pod::Usage::pod2usage(2);

if ( -r $LOG_CONF ) {
## no critic qw(ProhibitCallsToUnexportedSubs)
    Log::Log4perl::init_and_watch($LOG_CONF);
## use critic
}
else {
## no critic qw(ProhibitCallsToUnexportedSubs)
    Log::Log4perl::easy_init($ERROR);
## use critic
}
my $log = Log::Log4perl->get_logger( File::Basename::basename $PROGRAM_NAME );
$log->level(
    $DEBUG_LEVELS[
      (
          ( $opts{'verbose'} || 0 ) > $#DEBUG_LEVELS
          ? $#DEBUG_LEVELS
          : $opts{'verbose'}
      )
      || 0
    ],
);

my $p = Date::Extract::P800Picture->new();

while ( my $filename = shift @ARGV ) {
    $log->debug( sprintf $LOG{'FILENAME'}, $filename );

    my $dt;
    my $ret = eval { $dt = $p->extract( File::Basename::basename $filename); };
    if ( my $e = Exception::Class->caught('DateExtractP800PictureException') ) {
        $log->logdie($e);
    }
    if ( !print $dt->iso8601() . qq{\n} ) {
        $log->logdie( $LOG{'NO_PRINT'} );
    }

}

__END__

=encoding utf8

=for stopwords Ericsson Filename MERCHANTABILITY filename filenames timestamp manpage Ipenburg

=head1 NAME

p800date - show the date encoded in a P800 picture filename 

=head1 USAGE

B<p800date> [B<-v>] I<filename>...

=head1 DESCRIPTION

B<p800date> prints the timestamp encoded in the filenames of pictures created
with a Sony Ericsson P800 camera phone. The timestamp is printed in ISO8601
notation.

=head1 REQUIRED ARGUMENTS

A filename, which is allowed to include a path and doesn't have to be an
existing file.

=head1 OPTIONS

=over 4

=item B< -?, -h, --help>

Show help

=item B< -m, --man>

Show manpage

=item B< -v, --verbose>

Be more verbose

=item B<--version>

Show version and license

=back

=head1 FILES

=over 4

=item p800date_log.conf

Configuration file for L<Log::Log4perl|Log::Log4perl>

=back

=head1 DIAGNOSTICS

An error is thrown when a date can't be extracted from the filename:

=over 4

=item * Could not parse year character

(E) The character encoding the year wasn't in the required range

=item * Could not parse month character

(E) The character encoding the month wasn't in the required range

=item * Could not parse day character

(E) The character encoding the day of the month wasn't in the required range

=item * Could not parse hour character

(E) The character encoding the hour of the day wasn't in the required range

=item * No date found in filename

(E) The filename doesn't contain a valid encoded date

=item * Filename is not set, nothing to extract

(E) No filename was passed to the program

=item * Could not print

(E) The output could not be printed

=back

=head1 EXAMPLES

C<p800date 36LC0079.jpg         #prints 2003-07-22T12:00:00>

=head1 DEPENDENCIES

Perl 5.14.0, Date::Extract:P800Picture, File::Basename, Getopt::Long,
Log::Log4perl, Pod::Usage::CommandLine

=head1 EXIT STATUS

=over 4

=item 0Z<>

Success.

=item 2Z<>

Unknown option specified.

=item 255Z<>

An error occurred.

=back

=head1 CONFIGURATION

L<Log::Log4perl|Log::Log4perl> logging can be configured in p800date_log.conf.

=head1 INCOMPATIBILITIES

There are no known incompatibilities.

=head1 BUGS AND LIMITATIONS

Please report any bugs or feature requests at
L<RT for rt.cpan.org|https://rt.cpan.org/Dist/Display.html?Queue=Date-Extract-P800Picture>.

=head1 AUTHOR
=head1 LICENSE AND COPYRIGHT
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.0 or,
at your option, any later version of Perl 5 you may have available.

=head1 DISCLAIMER OF WARRANTY

BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENSE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

=cut
  push: #!/usr/bin/env perl -w    # -*- cperl; cperl-indent-level: 4 -*-
  # Copyright (C) 2008-2019
  use strict;
use warnings;

use utf8;
use 5.014000;

BEGIN { our $VERSION = v1.1.1; }

use Image::ExifTool            ();
use Date::Extract::P800Picture ();

use DateTime ();
use English qw(-no_match_vars);
use File::Basename ();
use File::stat     ();
use File::Slurp    ();
use Getopt::Long   ();
use Log::Log4perl qw(:easy get_logger);
use Pod::Usage              ();
use Pod::Usage::CommandLine ();

use Readonly ();
## no critic (ProhibitCallsToUnexportedSubs)
Readonly::Scalar my $EMPTY       => q{};
Readonly::Scalar my $SPACE       => q{ };
Readonly::Scalar my $MAKE        => q{Sony Ericsson};
Readonly::Scalar my $MODEL       => q{P800};
Readonly::Scalar my $RIGHTS      => q{CC BY-NC-SA 3.0 Unported};
Readonly::Scalar my $USER        => q{USER};
Readonly::Scalar my $FULLNAME    => 6;
Readonly::Scalar my $LOG_CONF    => q{p800exif_log.conf};
Readonly::Array my @DEBUG_LEVELS => ( $FATAL, $INFO, $WARN, $DEBUG );
Readonly::Hash my %LOG           => (
    'FILENAME'          => q{processing file '%s'},
    'NO_FILE'           => q{could not find file '%s'},
    'PRESERVING'        => q{preserving the hour fraction in '%s'},
    'NOT_PRESERVING'    => q{not preserving the hour fraction in '%s' (%s)},
    'EXIF'              => q{processing EXIF data for file '%s'},
    'EXIF_MAKE'         => q{setting EXIF field 'make' to '%s'},
    'EXIF_MODEL'        => q{setting EXIF field 'model' to '%s'},
    'EXIF_ARTIST'       => q{setting EXIF field 'artist' to '%s'},
    'EXIF_NO_ARTIST'    => q{no name defined to use as EXIF field 'artist'},
    'EXIF_DATETIME'     => q{setting EXIF field 'datetime' to '%s'},
    'EXIF_DATETIMEORIG' => q{setting EXIF field 'datetime original' to '%s'},
    'EXIF_COPYRIGHT'    => q{setting EXIF field 'copyright' to '%s'},
    'TIMESTAMP'         => q{setting mtime timestamp to '%s'},
);
Readonly::Array my @GETOPT_CONFIG =>
  qw(no_ignore_case bundling auto_version auto_help);
Readonly::Array my @GETOPTIONS => (
    q{make|brand|b=s}, q{model|m=s},  q{rights=s},  q{artist=s},
    q{exif!},          q{timestamp!}, q{preserve!}, q{verbose|v+},
);
Readonly::Scalar my $ARTIST     => @{ [ getpwnam $ENV{$USER} ] }[$FULLNAME];
Readonly::Hash my %OPTS_DEFAULT => (
    'make'      => $MAKE,
    'model'     => $MODEL,
    'rights'    => $RIGHTS,
    'artist'    => $ARTIST,
    'exif'      => 1,
    'timestamp' => 1,
    'preserve'  => 1,
);
## use critic

Getopt::Long::Configure(@GETOPT_CONFIG);
my %opts = %OPTS_DEFAULT;
Getopt::Long::GetOptions( \%opts, @GETOPTIONS ) or Pod::Usage::pod2usage(2);

if ( -r $LOG_CONF ) {
## no critic qw(ProhibitCallsToUnexportedSubs)
    Log::Log4perl::init_and_watch($LOG_CONF);
## use critic
}
else {
## no critic qw(ProhibitCallsToUnexportedSubs)
    Log::Log4perl::easy_init($ERROR);
## use critic
}
my $log = Log::Log4perl->get_logger( File::Basename::basename $PROGRAM_NAME );
$log->level(
    $DEBUG_LEVELS[
      (
          ( $opts{'verbose'} || 0 ) > $#DEBUG_LEVELS
          ? $#DEBUG_LEVELS
          : $opts{'verbose'}
      )
      || 0
    ],
);

my $p = Date::Extract::P800Picture->new();
## no critic (ProhibitCallsToUnexportedSubs)
my $xmp_cc = File::Slurp::read_file( \*DATA );
## use critic

while ( my $filename = shift @ARGV ) {
    $log->debug( sprintf $LOG{'FILENAME'}, $filename );

    my $stat = File::stat::stat($filename)
      or $log->croak( $LOG{'NO_FILE'}, $filename );
    my $mtime    = DateTime->from_epoch( 'epoch' => $stat->mtime );
    my $dt       = $p->extract( File::Basename::basename $filename);
    my $datetime = $dt . $EMPTY;

    if ( $opts{'preserve'}
        && ( $dt->ymd . $dt->hour eq $mtime->ymd . $mtime->hour ) )
    {
        $log->info( sprintf $LOG{'PRESERVING'}, $mtime->hms );
        $dt = $mtime;
    }
    else {
        $log->info( sprintf $LOG{'NOT_PRESERVING'}, $datetime,
            $mtime . $EMPTY );
    }

    if ( $opts{'exif'} ) {
        $log->debug( sprintf $LOG{'EXIF'}, $filename );
        my $exif = Image::ExifTool->new();

        $log->debug( sprintf $LOG{'EXIF_MAKE'}, $opts{'make'} );
        $exif->SetNewValue( 'Make' => $opts{'make'} );

        $log->debug( sprintf $LOG{'EXIF_MODEL'}, $opts{'model'} );
        $exif->SetNewValue( 'Model' => $opts{'model'} );

        $log->debug( sprintf $LOG{'EXIF_DATETIME'}, $datetime );
        $exif->SetNewValue( 'DateTime' => $datetime );

        $log->debug( sprintf $LOG{'EXIF_DATETIMEORIG'}, $datetime );
        $exif->SetNewValue( 'DateTimeOriginal' => $datetime );

        if ( defined $opts{'artist'} ) {
            $log->debug( sprintf $LOG{'EXIF_ARTIST'}, $opts{'artist'} );
            $exif->SetNewValue( 'Artist' => $opts{'artist'} );
        }
        else {
            $log->debug( sprintf $LOG{'EXIF_NO_ARTIST'}, $opts{'artist'} );
        }

        my $copyright = join $SPACE, $opts{'artist'}, $opts{'rights'};
        $log->debug( sprintf $LOG{'EXIF_COPYRIGHT'}, $copyright );
        $exif->SetNewValue( 'Copyright'      => $copyright );
        $exif->SetNewValue( 'XMP-cc:License' => $xmp_cc );

## no critic (ProhibitCallsToUnexportedSubs)
        my $jpeg = File::Slurp::read_file( $filename, 'binmode' => ':raw' );
## use critic

        $exif->WriteInfo( \$jpeg );
## no critic (ProhibitCallsToUnexportedSubs)
        File::Slurp::write_file( $filename, { 'binmode' => ':raw' }, $jpeg );
## use critic
    }

    if ( $opts{'timestamp'} ) {
        $log->debug( sprintf $LOG{'TIMESTAMP'}, $datetime );
        utime $stat->atime, $dt->epoch(), $filename;
    }

}

__END__

=encoding utf8

=for stopwords p800exif exif EXIF DPI Ericsson Filename MERCHANTABILITY
filename timestamp Unported manpage JFIF Ipenburg

=head1 NAME

p800exif - add the date encoded in a P800 picture filename to the file

=head1 USAGE

p800exif [B<-v>] [B<--make> I<make>] [B<--model> I<model>] [B<--rights>
I<rights>] [B<--artist> I<artist>] [B<--exif>] [B<--timestamp>] [B<--preserve>]
I<filename>...

=head1 DESCRIPTION

B<p800exif> attaches the timestamp encoded in the filename of pictures created
with a Sony Ericsson P800 camera phone to the file as EXIF information in the
image file or as the file's modification time.

=head1 REQUIRED ARGUMENTS

A filename.

=head1 OPTIONS

=over 4

=item B<--make, --brand>

Store the make or brand of the device that created the image in the EXIF data,
defaults to "Sony Ericsson".

=item B<--model>

Store the model of the device that created the image in the EXIF data,
defaults to "P800".

=item B<--rights>

Store the rights for the image in the EXIF data, defaults to a Creative
Commons Attribution-Noncommercial-Share Alike 3.0 Unported License.

=item B<--artist>

Store the name of the artist who created the image in the EXIF data, defaults
to $USER.

=item B<--exif>

Store EXIF data.

=item B<--timestamp>

Change the timestamp of the file to the date and time encoded in the filename.

=item B<--preserve>

Change only the date part in the modification date while preserving the time
part. 

=item B< -?, -h, --help>

Show help

=item B< -m, --man>

Show manpage

=item B< -v, --verbose>

Be more verbose

=item B<--version>

Show version and license

=back

=head1 FILES

=over 4

=item p800exif_log.conf

Configuration file for L<Log::Log4perl|Log::Log4perl>

=back

=head1 DIAGNOSTICS

An error is thrown when a date can't be extracted from the filename:

=over 4

=item * Could not parse year character

(E) The character encoding the year wasn't in the required range

=item * Could not parse month character

(E) The character encoding the month wasn't in the required range

=item * Could not parse day character

(E) The character encoding the day of the month wasn't in the required range

=item * Could not parse hour character

(E) The character encoding the hour of the day wasn't in the required range

=item * No date found in filename

(E) The filename doesn't contain a valid encoded date

=item * Filename is not set, nothing to extract

(E) No filename was passed to the program

=item * Could not print

(E) The output could not be printed

=back

=head1 EXAMPLES

C<p800exif 36LC0079.jpg>

=head1 DEPENDENCIES

Perl 5.14.0, Date::Extract:P800Picture, Image::ExifTool, File::Basename,
File::stat, File::Slurp, Getopt::Long, Log::Log4perl, Pod::Usage::CommandLine

=head1 EXIT STATUS

=over 4

=item 0

Success.

=item 2Z<>

Unknown option specified.

=item 255Z<>

An error occurred.

=back

=head1 CONFIGURATION

L<Log::Log4perl|Log::Log4perl> logging can be configured in p800exif_log.conf.

=head1 INCOMPATIBILITIES

When inserting the EXIF data the DPI values as displayed in Apple OS X Finder
Info change from 72 to 1. The JFIF density values are not affected.

=head1 BUGS AND LIMITATIONS

Please report any bugs or feature requests at
L<RT for rt.cpan.org|https://rt.cpan.org/Dist/Display.html?Queue=Date-Extract-P800Picture>.

=head1 AUTHOR
=head1 LICENSE AND COPYRIGHT
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.0 or,
at your option, any later version of Perl 5 you may have available.

=head1 DISCLAIMER OF WARRANTY

BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENSE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

=cut
__DATA__
<?xpacket begin='' id=''?><x:xmpmeta xmlns:x='adobe:ns:meta/'>
    <rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>

     <rdf:Description rdf:about=''
      xmlns:xapRights='http://ns.adobe.com/xap/1.0/rights/'>
      <xapRights:Marked>True</xapRights:Marked> </rdf:Description>

     <rdf:Description rdf:about=''
      xmlns:dc='http://purl.org/dc/elements/1.1/'>
      <dc:rights>
       <rdf:Alt>
        <rdf:li xml:lang='x-default' >This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported License.</rdf:li>
       </rdf:Alt>
      </dc:rights>
     </rdf:Description>

     <rdf:Description rdf:about=''
      xmlns:cc='http://creativecommons.org/ns#'>
      <cc:license rdf:resource='http://creativecommons.org/licenses/by-nc-sa/3.0/'/>
     </rdf:Description>

    </rdf:RDF>
    </x:xmpmeta>
    <?xpacket end='r'?>
    branches: [ "main" ]
  pull_request: # -*- cperl; cperl-indent-level: 4 -*-
  package Date::Extract::P800Picture::Exceptions v1.1.2;
use strict;
use warnings;

use utf8;
use 5.014000;

use Exception::Class qw(
  DateExtractP800PictureException
);

1;

__END__

=encoding utf8

=for stopwords Ericsson Filename MERCHANTABILITY POSIX filename timestamp
Ipenburg

=head1 NAME

Date::Extract::P800Picture::Exceptions - exceptions.

=head1 VERSION

This document describes Date::Extract::P800Picture::Exceptions version v1.1.2.

=head1 SYNOPSIS

    use Date::Extract::P800Picture::Exceptions;
    DateExtractP800PictureException->throw( error => $ERR );

=head1 DESCRIPTION

Provides C<DateExtractP800PictureException> exception classes based on
L<Exception::Class::Base|Exception::Class::Base>.

=head1 SUBROUTINES/METHODS

All inherited from L<Exception::Class::Base|Exception::Class::Base/METHODS>.

=head1 CONFIGURATION AND ENVIRONMENT

=head1 DEPENDENCIES

L<Exception::Class|Exception::Class>

=head1 INCOMPATIBILITIES

=head1 DIAGNOSTICS

=head1 BUGS AND LIMITATIONS

Please report any bugs or feature requests at
L<RT for rt.cpan.org|
https://rt.cpan.org/Dist/Display.html?Queue=Date-Extract-P800Picture>.

=head1 AUTHOR
=head1 LICENSE AND COPYRIGHT
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.0 or,
at your option, any later version of Perl 5 you may have available.

=head1 DISCLAIMER OF WARRANTY

BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENSE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

=cut
    branches: [ "main" ]
  schedule: # -*- cperl; cperl-indent-level: 4 -*-
package Date::Extract::P800Picture v1.1.2;

use strict;
use warnings;

use utf8;
use 5.014000;

use Moose;

use POSIX ();
use English qw( -no_match_vars);
use DateTime ();

use Date::Extract::P800Picture::Exceptions ();

use Readonly ();
## no critic (ProhibitCallsToUnexportedSubs)
Readonly::Scalar my $EMPTY             => q{};
Readonly::Scalar my $EPOCH_YEAR        => 2000;
Readonly::Scalar my $MONTHS_IN_YEAR    => 12;
Readonly::Scalar my $MAX_DAYS_IN_MONTH => 31;
Readonly::Scalar my $HOURS_IN_DAY      => 24;
Readonly::Scalar my $BASE_N            => 36;
Readonly::Scalar my $TZ                => 'UTC';
Readonly::Hash my %ERR                 => (
    'PARSING_YEAR'     => q{Could not parse year char '%s'},
    'PARSING_MONTH'    => q{Could not parse month char '%s'},
    'PARSING_DAY'      => q{Could not parse day char '%s'},
    'PARSING_HOUR'     => q{Could not parse hour char '%s'},
    'MISSING_DATE'     => q{No date found in filename '%s'},
    'MISSING_FILENAME' => q{Filename is not set, nothing to extract},
);
## use critic

## no critic (ProhibitComplexRegexes)
my $PATTERN = qr{
    ^
    (?<year>     [[:alnum:]]   ) # max 36 years: $EPOCH_YEAR 2000 to 2035
    (?<month>    [[:digit:]AB] ) # max 12 months
    (?<day>      [[:digit:]A-U]) # max 31 days
    (?<hour>     [[:digit:]A-N]) # max 24 hours: 0 to 23
    (?<serial>   [[:digit:]]{4}) # max unique up to 10000 pictures per hour
    (?<suffix>   [.]JPG        ) # JPEG extension
    $
}aixsm;
## use critic

## no critic qw(ProhibitCallsToUndeclaredSubs)
has 'filename' => (
## use critic
    'is'  => 'rw',
    'isa' => 'Str',
);

## no critic qw(ProhibitCallsToUndeclaredSubs)
has 'datetime' => (
## use critic
    'is'      => 'rw',
    'isa'     => 'DateTime',
    'default' => sub {
        DateTime->new(
            'year'      => $EPOCH_YEAR,
            'time_zone' => $TZ,
        );
    },
);

sub extract {
    my ( $self, $filename ) = @_;
    ( defined $filename ) && $self->filename($filename);
    if ( defined $self->filename ) {
        $self->filename =~ $PATTERN;
        my ( $year, $month, $day, $hour ) = (
            $LAST_PAREN_MATCH{'year'}, $LAST_PAREN_MATCH{'month'},
            $LAST_PAREN_MATCH{'day'},  $LAST_PAREN_MATCH{'hour'},
        );
        if ( defined $year ) {
            $self->_parse( \$year, $BASE_N, $ERR{'PARSING_YEAR'} )
              && $self->_parse( \$month, $MONTHS_IN_YEAR,
                $ERR{'PARSING_MONTH'} )
              && $self->_parse( \$day, $MAX_DAYS_IN_MONTH, $ERR{'PARSING_DAY'} )
              && $self->_parse( \$hour, $HOURS_IN_DAY, $ERR{'PARSING_HOUR'} )
              && (
                eval {
                    $self->datetime->set(
                        'year'  => $year + $EPOCH_YEAR,
                        'month' => $month + 1,
                        'day'   => $day + 1,
                        'hour'  => $hour,
                    );
                    1;
                } || do {
## no critic (RequireExplicitInclusion)
                    DateExtractP800PictureException->throw(
## use critic
                        'error' => $EVAL_ERROR,
                    );
                }
              );
        }
        else {
## no critic (RequireExplicitInclusion)
            DateExtractP800PictureException->throw(
## use critic
                'error' => sprintf $ERR{'MISSING_DATE'},
                $self->filename,
            );
        }
    }
    else {
## no critic (RequireExplicitInclusion)
        DateExtractP800PictureException->throw(
## use critic
            'error' => $ERR{'MISSING_FILENAME'},
        );
    }
    return $self->datetime;
}

# Converts a character to a number given base. Changes the referenced part
# returns true on succes.

sub _parse {
    my ( $self, $sr_part, $base, $error_message ) = @_;
    my $n_unparsed = 0;
    local $OS_ERROR = 0;
    if ( defined ${$sr_part} ) {
## no critic (ProhibitCallsToUnexportedSubs)
        ( ${$sr_part}, $n_unparsed ) = POSIX::strtol( ${$sr_part}, $base );
## use critic
    }
    if (   !defined ${$sr_part}
        || ${$sr_part} eq $EMPTY
        || $n_unparsed != 0
        || $OS_ERROR )
    {
## no critic (RequireExplicitInclusion)
        DateExtractP800PictureException->throw(
## use critic
            'error' => sprintf $error_message,
            defined ${$sr_part} ? ${$sr_part} : 'undef',
        );
        ${$sr_part} = undef;
    }
    return defined ${$sr_part};
}

1;

__END__

=encoding utf8

=for stopwords Ericsson Filename MERCHANTABILITY POSIX filename timestamp jpg JPG
YMDH DateTime undef perl Readonly perls Ipenburg

=head1 NAME

Date::Extract::P800Picture - extract the date from Sony Ericsson P800 pictures.

=head1 VERSION

This document describes Date::Extract::P800Picture version v1.1.2.

=head1 SYNOPSIS

    use Date::Extract::P800Picture;

    $filename = "8B360001.JPG"; # 2008-12-04T6:00:00

    $parser = new Date::Extract::P800Picture();
    $parser = new Date::Extract::P800Picture('filename' => $filename);

    $datetime = $parser->extract();
    $datetime = $parser->extract($filename);

=head1 DESCRIPTION

The Sony Ericsson P800 camera phone stores pictures taken with the camera on
the device with a filename consisting of the date and the hour the picture was
taken, followed by a four digit number and the .JPG extension. The format of
the date and the hour is YMDH, in which the single characters are base 36 to
fit a range of about 36 years, 12 months, 31 days and 24 hours since the year
2000 in a case insensitive US-ASCII representation.

=head1 SUBROUTINES/METHODS

=over 4

=item Date::Extract::P800Picture-E<gt>new()

=item Date::Extract::P800Picture-E<gt>new('filename' => $filename)

Constructs a new Date::Extract::P800Picture object.

=item $parser->filename($filename);

Sets the filename to extract the date and hour from.

=item $obj-E<gt>extract()

Extract date and hour from the string and returns it as L<DateTime|DateTime>
object. Returns undef if no valid date could be extracted.

=back

=head1 CONFIGURATION AND ENVIRONMENT

No configuration and environment settings are used.

=head1 DEPENDENCIES

=over 4

=item * perl 5.14 

=item * L<POSIX|POSIX>

=item * L<English|English>

=item * L<DateTime|DateTime>

=item * L<Readonly|Readonly>

=item * L<Moose|Moose>

=item * L<Test::More|Test::More>

=back

=head1 INCOMPATIBILITIES

=over 4

=item * To avoid ambiguity between more common date notations and the
Sony Ericsson P800's date notation this is a separate module. It's highly
unlikely that in any other setting "2000" means the first of January 2002.

=item * For perls earlier than 5.14 version 0.04 of this module provides the
same functionality in a perl 5.6 compatible way.

=back

=head1 DIAGNOSTICS

An exception in the form of an L<Exception::Class|Exception::Class> named
C<DateExtractP800PictureException> is thrown when a date can't be extracted
from the string:

=over 4

=item * Could not parse year char '%s'

=item * Could not parse month char '%s'

=item * Could not parse day char '%s'

=item * Could not parse hour char '%s'

=item * No date found in filename '%s'

=item * Filename is not set, nothing to extract

=back

=head1 BUGS AND LIMITATIONS

=over 4

=item * Usually the files are transferred from the P800 to other systems in a
way that hasn't completely preserved the timestamp of the file, so there is no
reliable way to double check the results by comparing the date extracted from
the filename with the timestamp of the file.

=item * There are no error values to provide different exit statuses for
different failure reasons

=back

Please report any bugs or feature requests at
L<RT for rt.cpan.org|
https://rt.cpan.org/Dist/Display.html?Queue=Date-Extract-P800Picture>.

=head1 AUTHOR
=head1 LICENSE AND COPYRIGHT
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.0 or,
at your option, any later version of Perl 5 you may have available.

=head1 DISCLAIMER OF WARRANTY

BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENSE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

=cut
    - cron: use Test::More;
use DateTime;

BEGIN {
    @methods = qw(extract filename);
    plan tests => ( 7 + @methods );
    ok(1);    # If we made it this far, we're ok.
    use_ok('Date::Extract::P800Picture');
}
my $parser = new_ok('Date::Extract::P800Picture');

@Date::Extract::P800Picture::Sub::ISA = qw(Date::Extract::P800Picture);
my $parser_sub = new_ok('Date::Extract::P800Picture::Sub');

foreach my $method (@methods) {
    can_ok( 'Date::Extract::P800Picture', $method );
}
my $datetime  = $parser->extract("8B421234.JPG");
my $datetime2 = DateTime->new(
    year      => 2008,
    month     => 12,
    day       => 5,
    hour      => 2,
    time_zone => 'UTC',
);
is( ref $datetime, ref $datetime2, 'extract method returns DateTime object' );

SKIP: {
    skip 'is_deeply() has bogus fail on 5.6.2', 1 unless $^V gt v5.6.2;
    is_deeply( $datetime, $datetime2,
        'extract method returns DateTime object with correct values' );
}

$parser = Date::Extract::P800Picture->new();
is( eval '$parser->extract()', undef, "unset filename error catch" );


permissions: use Test::More;

if ( !$ENV{TEST_SIGNATURE} ) {
    plan skip_all =>
      "Set the environment variable TEST_SIGNATURE to enable this test.";
}
elsif ( !eval { require Module::Signature; 1 } ) {
    plan skip_all => "Next time around, consider installing Module::Signature, "
      . "so you can verify the integrity of this distribution.";
}
elsif ( !-e 'SIGNATURE' ) {
    plan skip_all => "SIGNATURE not found";
}
elsif ( -s 'SIGNATURE' == 0 ) {
    plan skip_all => "SIGNATURE file empty";
}
elsif ( !eval { require Socket; Socket::inet_aton('pgp.mit.edu') } ) {
    plan skip_all => "Cannot connect to the keyserver to check module "
      . "signature";
}
else {
    plan tests => 1;
}

my $ret = Module::Signature::verify();

SKIP: {
    skip "Module::Signature cannot verify", 1
      if $ret eq Module::Signature::CANNOT_VERIFY();
    cmp_ok $ret, '==', Module::Signature::SIGNATURE_OK(), "Valid signature";
}
  contents: use Test::More;

my %boundaries = (
    '00000000.JPG',
    [ '2000-01-01T00:00:00', 'lower boundary works' ],
    'ZBUN9999.JPG',
    [ '2035-12-31T23:00:00', 'upper boundary works' ],
    '01S00000.jpg',
    [ '2000-02-29T00:00:00', 'februari 29th 2000 works' ],
    '41S00000.jpg',
    [ '2004-02-29T00:00:00', 'februari 29th 2004 works' ],
    '81S00000.jpg',
    [ '2008-02-29T00:00:00', 'februari 29th 2008 works' ],
    'C1S00000.jpg',
    [ '2012-02-29T00:00:00', 'februari 29th 2012 works' ],
    'G1S00000.jpg',
    [ '2016-02-29T00:00:00', 'februari 29th 2016 works' ],
    'K1S00000.jpg',
    [ '2020-02-29T00:00:00', 'februari 29th 2020 works' ],
    'O1S00000.jpg',
    [ '2024-02-29T00:00:00', 'februari 29th 2024 works' ],
    'S1S00000.jpg',
    [ '2028-02-29T00:00:00', 'februari 29th 2028 works' ],
    'W1S00000.jpg',
    [ '2032-02-29T00:00:00', 'februari 29th 2032 works' ],
    '32UI0000.jpg',
    [ '2003-03-31T18:00:00', 'march 31st 2003 works' ],
    '330I0000.jpg',
    [ '2003-04-01T18:00:00', 'rollover to april 1st 2003 works' ],
    '3BUN0000.jpg',
    [ '2003-12-31T23:00:00', 'december 31st 2003 works' ],
    '40000000.jpg',
    [ '2004-01-01T00:00:00', 'rollover to januari 1st 2004 works' ],
);

plan tests => 0 + keys %boundaries;

use Date::Extract::P800Picture;
my $parser = Date::Extract::P800Picture->new();
while ( my ( $filename, $expect ) = each %boundaries ) {
    is( "@{[$parser->extract($filename)]}", $expect->[0], $expect->[1] );
}

jobs: use Test::More;
BEGIN { plan tests => 24 }
my %hours = (
    '00000001.JPG' => [ '2000-01-01T00:00:00', '0:00' ],
    '00010001.JPG' => [ '2000-01-01T01:00:00', '1:00' ],
    '00020001.JPG' => [ '2000-01-01T02:00:00', '2:00' ],
    '00030001.JPG' => [ '2000-01-01T03:00:00', '3:00' ],
    '00040001.JPG' => [ '2000-01-01T04:00:00', '4:00' ],
    '00050001.JPG' => [ '2000-01-01T05:00:00', '5:00' ],
    '00060001.JPG' => [ '2000-01-01T06:00:00', '6:00' ],
    '00070001.JPG' => [ '2000-01-01T07:00:00', '7:00' ],
    '00080001.JPG' => [ '2000-01-01T08:00:00', '8:00' ],
    '00090001.JPG' => [ '2000-01-01T09:00:00', '9:00' ],
    '000A0001.JPG' => [ '2000-01-01T10:00:00', '10:00' ],
    '000B0001.JPG' => [ '2000-01-01T11:00:00', '11:00' ],
    '000C0001.JPG' => [ '2000-01-01T12:00:00', '12:00' ],
    '000D0001.JPG' => [ '2000-01-01T13:00:00', '13:00' ],
    '000E0001.JPG' => [ '2000-01-01T14:00:00', '14:00' ],
    '000F0001.JPG' => [ '2000-01-01T15:00:00', '15:00' ],
    '000G0001.JPG' => [ '2000-01-01T16:00:00', '16:00' ],
    '000H0001.JPG' => [ '2000-01-01T17:00:00', '17:00' ],
    '000I0001.JPG' => [ '2000-01-01T18:00:00', '18:00' ],
    '000J0001.JPG' => [ '2000-01-01T19:00:00', '19:00' ],
    '000K0001.JPG' => [ '2000-01-01T20:00:00', '20:00' ],
    '000L0001.JPG' => [ '2000-01-01T21:00:00', '21:00' ],
    '000M0001.JPG' => [ '2000-01-01T22:00:00', '22:00' ],
    '000N0001.JPG' => [ '2000-01-01T23:00:00', '23:00' ],
);

use Date::Extract::P800Picture;
my $parser = Date::Extract::P800Picture->new();
while ( my ( $filename, $expect ) = each %hours ) {
    is( "@{[$parser->extract($filename)]}", $expect->[0], $expect->[1] );
}
  mobile-security: Use Node.js ${{ use Test::More;
BEGIN { plan tests => 31 }

my %days = (
    '00000001.JPG' => [ '2000-01-01T00:00:00', '1st' ],
    '00100001.JPG' => [ '2000-01-02T00:00:00', '2nd' ],
    '00200001.JPG' => [ '2000-01-03T00:00:00', '3rd' ],
    '00300001.JPG' => [ '2000-01-04T00:00:00', '4th' ],
    '00400001.JPG' => [ '2000-01-05T00:00:00', '5th' ],
    '00500001.JPG' => [ '2000-01-06T00:00:00', '6th' ],
    '00600001.JPG' => [ '2000-01-07T00:00:00', '7th' ],
    '00700001.JPG' => [ '2000-01-08T00:00:00', '8th' ],
    '00800001.JPG' => [ '2000-01-09T00:00:00', '9th' ],
    '00900001.JPG' => [ '2000-01-10T00:00:00', '10th' ],
    '00A00001.JPG' => [ '2000-01-11T00:00:00', '11th' ],
    '00B00001.JPG' => [ '2000-01-12T00:00:00', '12th' ],
    '00C00001.JPG' => [ '2000-01-13T00:00:00', '13th' ],
    '00D00001.JPG' => [ '2000-01-14T00:00:00', '14th' ],
    '00E00001.JPG' => [ '2000-01-15T00:00:00', '15th' ],
    '00F00001.JPG' => [ '2000-01-16T00:00:00', '16th' ],
    '00G00001.JPG' => [ '2000-01-17T00:00:00', '17th' ],
    '00H00001.JPG' => [ '2000-01-18T00:00:00', '18th' ],
    '00I00001.JPG' => [ '2000-01-19T00:00:00', '19th' ],
    '00J00001.JPG' => [ '2000-01-20T00:00:00', '20th' ],
    '00K00001.JPG' => [ '2000-01-21T00:00:00', '21st' ],
    '00L00001.JPG' => [ '2000-01-22T00:00:00', '22nd' ],
    '00M00001.JPG' => [ '2000-01-23T00:00:00', '23rd' ],
    '00N00001.JPG' => [ '2000-01-24T00:00:00', '24th' ],
    '00O00001.JPG' => [ '2000-01-25T00:00:00', '25th' ],
    '00P00001.JPG' => [ '2000-01-26T00:00:00', '26th' ],
    '00Q00001.JPG' => [ '2000-01-27T00:00:00', '27th' ],
    '00R00001.JPG' => [ '2000-01-28T00:00:00', '28th' ],
    '00S00001.JPG' => [ '2000-01-29T00:00:00', '29th' ],
    '00T00001.JPG' => [ '2000-01-30T00:00:00', '30th' ],
    '00U00001.JPG' => [ '2000-01-31T00:00:00', '31st' ],
);

use Date::Extract::P800Picture;
my $parser = Date::Extract::P800Picture->new();
while ( my ( $filename, $expect ) = each %days ) {
    is( "@{[$parser->extract($filename)]}", $expect->[0], $expect->[1] );
} }}
    permissions: use Test::More;
BEGIN { plan tests => 12 }

my %months = (
    '00000001.JPG' => [ '2000-01-01T00:00:00', 'januari' ],
    '01000001.JPG' => [ '2000-02-01T00:00:00', 'februari' ],
    '02000001.JPG' => [ '2000-03-01T00:00:00', 'march' ],
    '03000001.JPG' => [ '2000-04-01T00:00:00', 'april' ],
    '04000001.JPG' => [ '2000-05-01T00:00:00', 'may' ],
    '05000001.JPG' => [ '2000-06-01T00:00:00', 'june' ],
    '06000001.JPG' => [ '2000-07-01T00:00:00', 'july' ],
    '07000001.JPG' => [ '2000-08-01T00:00:00', 'august' ],
    '08000001.JPG' => [ '2000-09-01T00:00:00', 'september' ],
    '09000001.JPG' => [ '2000-10-01T00:00:00', 'october' ],
    '0A000001.JPG' => [ '2000-11-01T00:00:00', 'november' ],
    '0B000001.JPG' => [ '2000-12-01T00:00:00', 'december' ],
);

use Date::Extract::P800Picture;
my $parser = Date::Extract::P800Picture->new();
while ( my ( $filename, $expect ) = each %months ) {
    is( "@{[$parser->extract($filename)]}", $expect->[0], $expect->[1] );
}
      contents: ${{ use Test::More;
BEGIN { plan tests => 36 }

my %years = (
    '00000001.JPG' => [ '2000-01-01T00:00:00', '2000' ],
    '10000001.JPG' => [ '2001-01-01T00:00:00', '2001' ],
    '20000001.JPG' => [ '2002-01-01T00:00:00', '2002' ],
    '30000001.JPG' => [ '2003-01-01T00:00:00', '2003' ],
    '40000001.JPG' => [ '2004-01-01T00:00:00', '2004' ],
    '50000001.JPG' => [ '2005-01-01T00:00:00', '2005' ],
    '60000001.JPG' => [ '2006-01-01T00:00:00', '2006' ],
    '70000001.JPG' => [ '2007-01-01T00:00:00', '2007' ],
    '80000001.JPG' => [ '2008-01-01T00:00:00', '2008' ],
    '90000001.JPG' => [ '2009-01-01T00:00:00', '2009' ],
    'A0000001.JPG' => [ '2010-01-01T00:00:00', '2010' ],
    'B0000001.JPG' => [ '2011-01-01T00:00:00', '2011' ],
    'C0000001.JPG' => [ '2012-01-01T00:00:00', '2012' ],
    'D0000001.JPG' => [ '2013-01-01T00:00:00', '2013' ],
    'E0000001.JPG' => [ '2014-01-01T00:00:00', '2014' ],
    'F0000001.JPG' => [ '2015-01-01T00:00:00', '2015' ],
    'G0000001.JPG' => [ '2016-01-01T00:00:00', '2016' ],
    'H0000001.JPG' => [ '2017-01-01T00:00:00', '2017' ],
    'I0000001.JPG' => [ '2018-01-01T00:00:00', '2018' ],
    'J0000001.JPG' => [ '2019-01-01T00:00:00', '2019' ],
    'K0000001.JPG' => [ '2020-01-01T00:00:00', '2020' ],
    'L0000001.JPG' => [ '2021-01-01T00:00:00', '2021' ],
    'M0000001.JPG' => [ '2022-01-01T00:00:00', '2022' ],
    'N0000001.JPG' => [ '2023-01-01T00:00:00', '2023' ],
    'O0000001.JPG' => [ '2024-01-01T00:00:00', '2024' ],
    'P0000001.JPG' => [ '2025-01-01T00:00:00', '2025' ],
    'Q0000001.JPG' => [ '2026-01-01T00:00:00', '2026' ],
    'R0000001.JPG' => [ '2027-01-01T00:00:00', '2027' ],
    'S0000001.JPG' => [ '2028-01-01T00:00:00', '2028' ],
    'T0000001.JPG' => [ '2029-01-01T00:00:00', '2029' ],
    'U0000001.JPG' => [ '2030-01-01T00:00:00', '2030' ],
    'V0000001.JPG' => [ '2031-01-01T00:00:00', '2031' ],
    'W0000001.JPG' => [ '2032-01-01T00:00:00', '2032' ],
    'X0000001.JPG' => [ '2033-01-01T00:00:00', '2033' ],
    'Y0000001.JPG' => [ '2034-01-01T00:00:00', '2034' ],
    'Z0000001.JPG' => [ '2035-01-01T00:00:00', '2035' ],
);

use Date::Extract::P800Picture;
my $parser = Date::Extract::P800Picture->new();
while ( my ( $filename, $expect ) = each %years ) {
    is( "@{[$parser->extract($filename)]}",
        $expect->[0], "year " . $expect->[1] );
} }}
      security-events: #!/bin/sh
HERE="$(dirname "$(readlink -f "${0}")")"
export LD_LIBRARY_PATH="${HERE}/usr/lib/x86_64-linux-gnu":"${HERE}/Qt/libs":$LD_LIBRARY_PATH
export QML2_IMPORT_PATH="${HERE}/Qt/qml"
export QT_PLUGIN_PATH="${HERE}/Qt/plugins"

# hack until icon issue with AppImage is resolved
mkdir -p ~/.icons && \cp -f ${HERE}/qgroundcontrol.png ~/.icons

"${HERE}/CustomQGC" "$@"
      actions: import QtQuick 2.0
import QtQuick.Controls 2.4
import QtGraphicalEffects 1.0


Item {
    id: _root

    property color mainColor: "#000000"
    property color contentColor: "#FFFFFF"
    property alias fontPointSize: zoomStatusTextItem.font.pointSize
    property real  zoomLevel: NaN
    property alias zoomLevelVisible: zoomStatusItem.visible
    property bool  showZoomPrecision: true
    property bool  onlyContinousZoom: false

    signal zoomIn()
    signal zoomOut()
    signal continuousZoomStart(var zoomIn)
    signal continuousZoomStop()

    //
    // Beware the buttons were switched
    //
    //

    height: zoomStatusTextItem.height * 2
    width: (zoomLevelVisible ? (zoomStatusItem.width - zoomInButton.width/2) : 0) + zoomInButton.width + zoomOutButton.width

    Rectangle {
        id: zoomStatusItem

        color: mainColor
        opacity: 0.5
        radius: height/2

        anchors.left: _root.left
        anchors.verticalCenter: _root.verticalCenter

        width: height * 2
        height: _root.height * 0.8
    }

    Item {
        visible: zoomStatusItem.visible

        anchors.left: zoomStatusItem.left
        anchors.top: zoomStatusItem.top
        anchors.right: zoomStatusItem.horizontalCenter
        anchors.bottom: zoomStatusItem.bottom

        z: zoomStatusItem.z + 1

        Text {
            id: zoomStatusTextItem

            anchors.centerIn: parent
            opacity: 2

            color: _root.contentColor

            text: isNaN(zoomLevel) ? "-" : "x" + _root.zoomLevel.toFixed(_root.showZoomPrecision ? 1 : 0)
        }
    }

    Button {
        id: zoomInButton
        flat: true

        anchors.left: zoomLevelVisible ? zoomStatusItem.horizontalCenter : _root.left
        anchors.top: _root.top
        width: height
        height: _root.height

        property bool holding: false

        onPressed: {
            if(onlyContinousZoom) {
                holding = true
            }
            else {
                _root.zoomOut()
            }
        }

        onPressAndHold: {
            holding = true
        }

        onReleased: {
            holding = false
        }

        background: Rectangle {
            anchors.fill: zoomInButton
            radius: zoomInButton.width/10

            color: _root.mainColor
        }

        contentItem: Item {
            anchors.fill: zoomInButton
            Rectangle {
                id: zoomInMinusRectangle
                anchors.centerIn: parent

                width: zoomInButton.width * 0.4
                height: zoomInButton.height * 0.05

                color: _root.contentColor
            }
        }
    }

    Item {
        id: buttonSeparator

        anchors.left: zoomInButton.right
        anchors.verticalCenter: zoomInButton.verticalCenter
        width: zoomInButton.width * 0.05
        height: zoomInButton.height * 0.8

        Rectangle {
            radius: width * 0.2
            anchors.centerIn: parent

            width: zoomInButton.width * 0.01
            height: parent.height * 0.8

            color: _root.contentColor
        }
    }

    Button {
        id: zoomOutButton
        flat: true

        anchors.left: buttonSeparator.right
        anchors.top: zoomInButton.top
        width: height
        height: zoomInButton.height

        property bool holding: false

        onPressed: {
            if(onlyContinousZoom) {
                holding = true
            }
            else {
                _root.zoomIn()
            }
        }

        onPressAndHold: {
            holding = true
        }

        onReleased: {
            holding = false
        }

        background: Rectangle {
            anchors.fill: zoomOutButton
            radius: zoomOutButton.width/10

            color: _root.mainColor
        }

        contentItem: Item {
            anchors.fill: zoomOutButton
            Rectangle {
                id: zoomOutMinusRectangle
                anchors.centerIn: parent

                width: zoomInMinusRectangle.width
                height: zoomInMinusRectangle.height

                color: _root.contentColor
            }
            Rectangle {
                anchors.centerIn: parent

                width: zoomOutMinusRectangle.height
                height: zoomOutMinusRectangle.width

                color: _root.contentColor
            }
        }
    }

    // Zoom buttons background
    Rectangle {
        color: _root.mainColor
        z: -1

        anchors.left: zoomInButton.horizontalCenter
        anchors.right: zoomOutButton.horizontalCenter
        anchors.top: zoomInButton.top
        anchors.bottom: zoomOutButton.bottom
    }

    onStateChanged: {
        if(state == "ZoomingIn") {
            _root.continuousZoomStart(true)
        }
        else if(state == "ZoomingOut") {
            _root.continuousZoomStart(false)
        }
        else {
            _root.continuousZoomStop()
        }
    }

    state: "None"
    states: [
        State {
            name: "None"
            when: zoomInButton.holding === false && zoomOutButton.holding === false
        },
        State {
            name: "ZoomingIn"
            when: zoomOutButton.holding === true
        },
        State {
            name: "ZoomingOut"
            when: zoomInButton.holding === true
        }
    ]
}
    runs-on: module Custom.Camera

ZoomControl 1.0 ZoomControl.qml

    steps: import cv2
from time import time
import socket
from goprocam import GoProCamera, constants

gpCam = GoProCamera.GoPro()
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
t=time()
gpCam.livestream("start")
gpCam.video_settings(res='1080p', fps='30')
gpCam.gpControlSet(constants.Stream.WINDOW_SIZE, constants.Stream.WindowSize.R720)
cap = cv2.VideoCapture("udp://10.5.5.9:8554", cv2.CAP_FFMPEG)# GO PRO CAMERA IP

while True:
    nmat, frame = cap.read()
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    lower_red = (0, 85, 85)
    upper_red = (10, 255, 255)
    mask = cv2.inRange(hsv, lower_red, upper_red)
    res = cv2.bitwise_and(frame, frame, mask=mask)
    contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for c in contours:
        if cv2.contourArea(c) < 500:
            continue
        (x, y, w, h) = cv2.boundingRect(c)
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 0, 255), 2)
        print("X: ",x)
        print("Y: ", y)
        print("W: ", w)
        print("H: ", h)
        f = open("stepper.txt", "w")
        f.write(str(int(x/12)))
        f.close()
    cv2.imshow("GoPro OpenCV", frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break
    if time() - t >= 2.5:
        sock.sendto("_GPHD_:0:0:2:0.000000\n".encode(), ("10.5.5.9", 8554))
        t=time()

# When everything is done, release the capture
cap.release()
cv2.destroyAllWindows()
      - uses: 
import pygame
import json, os
import bluetooth

# Bluetooth device address
bd_addr = "fc:a8:9a:00:92:43" # PS4 MAC ADDRESS

# Port number to use for connection
port = 1

# Create a socket and connect to the device
sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
sock.connect((bd_addr, port))
sock.baudrate = 9600
################################# LOAD UP A BASIC WINDOW #################################
pygame.init()

running = True
LEFT, RIGHT, UP, DOWN , WATER , STOP_WATER ,LED , STOP_LED= False, False, False, False , False , False , False , False
LEFT_S, RIGHT_S= False, False
SPEED_L3=0
clock = pygame.time.Clock()
color = 0
###########################################################################################

#Initialize controller
joysticks = []
for i in range(pygame.joystick.get_count()):
    joysticks.append(pygame.joystick.Joystick(i))
for joystick in joysticks:
    joystick.init()

with open(os.path.join("ps4_keys.json"), 'r+') as file:
    button_keys = json.load(file)
# 0: Left analog horizonal, 1: Left Analog Vertical, 2: Right Analog Horizontal
# 3: Right Analog Vertical 4: Left Trigger, 5: Right Trigger
analog_keys = {0:0, 1:0, 2:0, 3:0, 4:-1, 5: -1 }
w=0
s=0
d=0
a=50
i=0
j=0
step_STR="000"
DATA_SEND="U000000"
# START OF GAME LOOP
while running:
    SPEED_R2 = "{:03d}".format(int(0))
    ################################# CHECK PLAYER INPUT #################################
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN:
            ############### UPDATE SPRITE IF SPACE IS PRESSED #################################
            pass

        # HANDLES BUTTON PRESSES
        if event.type == pygame.JOYBUTTONDOWN:
            if event.button == button_keys['left_arrow']:
                LEFT_S = True
                if (a < 100):
                    a+=1
                SPEED_L3 = "{:03d}".format(int(a))

                print("LEFT PRESS")
            if event.button == button_keys['right_arrow']:
                RIGHT_S = True
                if(a>20):
                    a-=1
                SPEED_L3 = "{:03d}".format(int(a))
                print("RIGHT PRESS")
            if event.button == button_keys['down_arrow']:
                DOWN = True
                print("DOWN PRESS")
            if event.button == button_keys['x']:
                WATER = True
                print(("WATER"))
            if event.button == button_keys['circle']:
                STOP_WATER = True
                print(("STOP WATER "))
            if event.button == button_keys['triangle']:
                LED = True
                print(("LED"))
            if event.button == button_keys['square']:
                STOP_LED = True
                print(("STOP LED "))
            if event.button == button_keys['up_arrow']:
                UP = True
                print("UP PRESS")
            #print(pygame.KEYDOWN)

        # HANDLES BUTTON RELEASES
        if event.type == pygame.JOYBUTTONUP:
            if event.button == button_keys['left_arrow']:
                print("LEFT RELESE")
            if event.button == button_keys['right_arrow']:
                RIGHT = False
                print("LEFT RELESE")
            if event.button == button_keys['down_arrow']:
                DOWN = False
                print("LEFT RELESE")
            if event.button == button_keys['up_arrow']:
                UP = False
                print("LEFT RELESE")
            if event.button == button_keys['x']:
                WATER = False
            if event.button == button_keys['circle']:
                STOP_WATER = False
            if event.button == button_keys['triangle']:
                LED = False
            if event.button == button_keys['square']:
                STOP_LED = False

        #HANDLES ANALOG INPUTS
        if event.type == pygame.JOYAXISMOTION:
            analog_keys[event.axis] = event.value
            # Horizontal Analog

            if abs(analog_keys[0]*5000) > 600:
                if analog_keys[0]*5000 < -3500:
                    LEFT_S = True
                    #print("L3 LEFT",128+analog_keys[0]*128)
                    #SPEED_L3 = "{:03d}".format(int(a))
                    #print(SPEED_L3)
                else:
                    LEFT = False
                if analog_keys[0]*5000 > 3500:
                    RIGHT_S = True
                    #print("L3 RIGHT",128+analog_keys[0]*128)
                    #SPEED_L3 = "{:03d}".format(int(a))
                    #print(SPEED_L3)

                else:
                    RIGHT_S = False

            if abs(analog_keys[2] * 5000) > 600:
                if analog_keys[2] * 5000 < -3500:
                    LEFT = True
                    #print("R3 LEFT", analog_keys[2] * 5000)
                else:
                    LEFT = False
                if analog_keys[2] * 5000 > 3500:
                    RIGHT = True
                    #print("R3 RIGHT", analog_keys[2] * 5000)
                else:
                    RIGHT = False
            # Vertical Analog
            if abs(analog_keys[3] * 5000) > 600:
                if analog_keys[3] * 5000 < -3500:
                    UP = True
                    #print("R3 UP", analog_keys[3] * 5000)
                else:
                    UP = False
                if analog_keys[3] * 5000 > 3500:
                    DOWN = True
                    #print("R3 DOWN", analog_keys[3] * 5000)
                else:
                    DOWN = False

                # Triggers
            if (128)+analog_keys[4] * 128 > 128:  # Left trigger
                #print("L2 DOWN ","{:03d}".format(int(analog_keys[4] * 256)))
                SPEED_L2="{:03d}".format(int(analog_keys[4] * 256))
                #print(SPEED_L2)
            if (128)+analog_keys[5] * 128 > 128:  # Right trigger
                #print("R2 DOWN ","{:03d}".format(int(analog_keys[5] * 256)))
                SPEED_R2="{:03d}".format(int((analog_keys[5] * 256))-1)
                #print(SPEED_R2)
            with open("steper.txt", "r") as file:
                step_STR=(file.read())
                if step_STR:
                        step_STR="{:03d}".format((85-int(step_STR)//3))
                        step_BOOL=True
                        #print(step_STR)
                else:
                    step_BOOL = False

            if(LEFT|RIGHT|UP|DOWN|LEFT_S|RIGHT_S|step_BOOL | WATER| STOP_WATER |LED |STOP_LED):
                if (LEFT):
                    DATA_SEND=("L"+str(SPEED_R2)+str(step_STR))
                elif (RIGHT):
                    DATA_SEND = ("R"+str(SPEED_R2)+str(step_STR))
                elif (UP):
                    DATA_SEND = ("U"+str(SPEED_R2)+str(step_STR))
                elif (DOWN):
                    DATA_SEND = ("D"+str(SPEED_R2)+str(step_STR))
                elif (LEFT_S):
                    DATA_SEND = ("Z"+str(SPEED_R2)+str(step_STR))
                elif (RIGHT_S):
                    DATA_SEND = ("X"+str(SPEED_R2)+str(step_STR))
                elif (step_BOOL):
                    DATA_SEND = ("X"+str(SPEED_R2)+str(step_STR))
                if (WATER):
                    DATA_SEND = ("W"+str(SPEED_R2)+str(step_STR))
                if (STOP_WATER):
                    DATA_SEND = ("R"+str(SPEED_R2)+str(step_STR))
                if (LED):
                    DATA_SEND = ("J"+str(SPEED_R2)+str(step_STR))
                if (STOP_LED):
                    DATA_SEND = ("K"+str(SPEED_R2)+str(step_STR))
                j+=1
                if(j>100):
                    print(DATA_SEND)
                    sock.send(DATA_SEND.encode())
                    j=0
            else:
                i+=1
                if(i>100):
                    DATA_SEND = ("U000"+str(step_STR))
                    sock.send(DATA_SEND.encode())
                    print(DATA_SEND)
                    i=0

      - name: Setup python
        uses: actions/setup-python@v3
        with:
          python-version: 3.8

      - name: Run mobsfscan
        uses: MobSF/mobsfscan@a60d10a83af68e23e0b30611c6515da604f06f65
        with:
          args: . --sarif --output results.sarif || true

      - name: Upload mobsfscan report
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: results.sarif

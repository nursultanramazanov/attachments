# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
#
# See https://github.com/r-lib/actions/tree/master/examples#readme for
# additional example workflows available for the R community.

name: R

on: mscan <- function(fname, nc = 0, header = FALSE, burn = 0,
                  thin = 0, nlines = 0L, sep = "", ...) {
  ## Quickly scan a matrix of homogeneous data from a file.
  ##
  ## Args:
  ##   fname:  The name of the file from which to scan the data.
  ##   nc: the number of columns in the matrix to be read.  If zero then the
  ##     number of columns will be determined by the number of columns in the
  ##     first line of the file.
  ##   header: logical indicating whether the file contains a header row.
  ##   burn: An integer giving the number of initial lines of the matrix to
  ##     discard.
  ##   thin: An integer.  If thin > 1 then keep every thin'th line.  This is
  ##     useful for reading in very large files of MCMC output, for example.
  ##   nlines: If positive, the number of data lines to scan from the data file
  ##     (e.g. for an MCMC algorithm that is only partway done).  Otherwise the
  ##     entire file will be read.
  ##   sep:  Field separator in the data file.
  ##   ...:  Extra arguments passed to 'scan'.
  ##
  ## Returns:
  ##   A matrix containing values from the given data file.
  stopifnot(is.logical(header),
            length(header) == 1)
  stopifnot(is.character(fname),
            length(fname) == 1)
  stopifnot(is.numeric(nc),
            length(nc) == 1,
            nc >= 0)
  stopifnot(is.numeric(burn),
            length(burn) == 1,
            burn >= 0)
  stopifnot(is.numeric(thin),
            length(thin) == 1,
            thin >= 0)
  skip = as.numeric(header)
  if (header) {
    column.names <- scan(fname, nlines = 1, sep = sep, what = character(), ...)
    if (nc == 0) {
      nc <- length(column.names)
    }
    if (length(column.names) != nc) {
      stop("Specified number of columns: ",
           nc,
           " does not match the number of column names in the file header: ",
           length(column.names),
           ".")
    }
  } else {
    column.names <- NULL
  }

  if (nc == 0) {
    single.line <- scan(fname, skip = skip, nlines = 1, sep = sep, ...)
    nc <- length(single.line)
  }
  ans <- matrix(scan(fname, skip = skip, sep = sep, nlines = nlines, ...),
                ncol = nc,
                byrow = TRUE)
  if (burn > 0) ans <- ans[-(1:burn), , drop = FALSE]
  if (thin > 1) ans <- ThinMatrix(ans, thin)
  colnames(ans) <- column.names
  return(ans)
}
  push: PairsDensity <- function(draws,
                         nlevels = 20,
                         lty = NULL,
                         color = NULL,
                         subset = NULL,
                         labels,
                         legend.location = "top",
                         legend.cex = 1,
                         label.cex = 1,
                         ...) {
  ## Produces a pairs plot showing the posterior distribution of the
  ## given list of Monte Carlo draws.  Plots above the diagonal show
  ## the posterior distribution on a scale just wide enough to fit the
  ## plots.  The diagonal shows a marginal density plot, and the sub
  ## diagonal shows the distribution with all plots on a common scale.
  ##
  ## Args:
  ##   draws: Either a matrix or a list of matrices.  If a list is
  ##     provided then each list element is plotted as a separate set
  ##     of contours, and all matrices must have the same number of
  ##     columns (though rows can differ).
  ##   nlevels:  The number of contour levels to plot.
  ##   lty:  The line types to use for the different elements in 'draws'.
  ##   color:  The color to use for different elemetns in 'draws'.
  ##   subset: If draws is a list, then this can be either a numerical
  ##     vector.  If draws has names, then subset can be a character vector.
  ##   labels: If labels is missing and the first element of draws has
  ##     non-NULL 'colnames' then these will be used to label the
  ##     pairs plot.  If a character vector of length ncol(draws[[1]])
  ##     then this character vector will be used in place of the
  ##     colnames.  If NULL then no labels will be used.
  ##   legend.location: Either "top", or "right" specifying the
  ##     location for the legend, or NULL, indicating that no legend
  ##     is desired.  if draws is a matrix or a singleton list then no
  ##     legend is produced.
  ##   legend.cex:  Scale factor to use for the legend labels.
  ##   ...: Extra arguments (graphical parameters), passed to plot,
  ##     PlotDensityContours, axis, and AddExternalLegend.

  is.odd <- function(j) {
    (j %% 2) == 1
  }

  is.even <- function(j) {
    (j %% 2) == 0
  }

  if (is.data.frame(draws)) {
    draws <- list(as.matrix(draws))
  }

  if (!is.list(draws)) {
    draws <- list(draws)
  }

  if (is.null(subset)) {
    subset <- 1:length(draws)
  }

  stopifnot(length(subset) >= 1)
  scale <- range(unlist(draws), na.rm = TRUE)

  dimension <- ncol(draws[[1]])
  number.of.groups <- length(draws)

  if (missing(labels)) {
    labels <- colnames(draws[[1]])
  }
  if (!is.null(labels)) {
    stopifnot(is.character(labels) && length(labels) == dimension)
    use.labels <- TRUE
  } else {
    ## Labels will be NULL if draws[[1]] has no colnames, or if it was
    ## supplied as NULL by the caller.  In either case is.null(labels)
    ## is the signal that determines whether labels are used.
    use.labels <- FALSE
  }

  if (number.of.groups > 1 && !is.null(legend.location)) {
    if (!is.null(names(draws))) {
      legend.labels <- names(draws)
    } else {
      legend.labels <- as.character(1:number.of.groups)
    }
    ## The following call has x.axis = FALSE because there will be no
    ## horizontal axis on the top of the plot, even though there will
    ## be one on the bottom.
    opar <- ExternalLegendLayout(dimension, dimension, legend.labels,
                                 outer.margin.lines = 4,
                                 legend.location = legend.location,
                                 legend.cex = legend.cex,
                                 x.axis = FALSE)
  } else {
    layout.matrix <- matrix(1:dimension^2, byrow = TRUE, nrow = dimension)
    opar <- par(oma = rep(4, 4), mar = rep(0, 4))
    layout(layout.matrix)
  }
  on.exit({par(opar); layout(1)})

  if (is.null(color)) {
    color <- 1:number.of.groups
  }

  if (is.null(lty)) {
    lty <- 1:number.of.groups
  }

  for (i in 1:dimension) {
    for (j in 1:dimension) {
      if (i == j) {
        ## Diagonal plot
        if (number.of.groups == 1) {
          plot(density(draws[[1]][, i]),
               axes = F,
               xlab = "",
               ylab = "",
               main = "",
               sub = "",
               ...)
        } else {
          marginal.draws <- lapply(draws, function(d) d[, i])

          CompareDensities(marginal.draws, lty = 1:number.of.groups,
                           col = color, axes = FALSE, legend.location = NULL)
        }
        box()
      } else if (j > i) {
        ## Plot is above the diagonal
        PlotDensityContours(draws,
                            j,  ## Reverse the order to go from
                            i,  ## matrix to function notation.
                            subset = subset,
                            color = color,
                            lty = lty,
                            nlevels = nlevels,
                            axes = FALSE,
                            ...)
        box()
      } else {
        ## Plot is below the diagonal.
        PlotDensityContours(draws,
                            j,
                            i,
                            subset = subset,
                            color = color,
                            lty = lty,
                            xlim = scale,
                            ylim = scale,
                            nlevels = nlevels,
                            axes = FALSE,
                            ...)
        box()
        if (i == dimension && is.odd(j)) axis(1, xpd = NA, ...)
        if (j == 1 && is.even(i)) axis(2, xpd = NA, ...)
      }
      if (use.labels) {
        if (i == 1) {
          mtext(labels[j], side = 3, cex = label.cex)
        }
        if (j == dimension) {
          mtext(labels[i], side = 4, cex = label.cex)
        }
      }
    }
  }

  if (number.of.groups > 1 && !is.null(legend.location)) {
    AddExternalLegend(legend.labels,
                      legend.location,
                      lty = lty,
                      col = color,
                      legend.cex = legend.cex,
                      ...)
  }
  return(invisible(NULL))
}

PlotDensityContours <- function(draws,
                                x.index = 1,
                                y.index = 2,
                                xlim = NULL,
                                ylim = NULL,
                                nlevels = 20,
                                subset = NULL,
                                color = NULL,
                                lty = NULL,
                                axes = TRUE,
                                ...) {
  ## Creates a contour plot of the bivariate densities in draws.  If
  ## draws is a list of Monte Carlo matrices, then each element in the
  ## list gets its own set of density contours.
  ##
  ## This is intended primarily as a panel function to use with
  ## PairsDensity.
  ##
  ## Args:
  ##   draws: Either a matrix of draws, or a list of matrices.  Each
  ##     row represents a different draw, and each column a different
  ##     variable.  If a list of matrices, each matrix should have the
  ##     same number of columns.
  ##   x.index: The index of the parameter to plot on the
  ##     horizonal axis, starting from 1.
  ##   y.index:  The index of the beta coefficient to plot on the
  ##     vertical axis, starting from 1.
  ##   xlim, ylim: If NULL then the plot will be scaled locally.
  ##     Otherwise, the limits of the horizontal and vertical axes.
  ##   nlevels:  The number of levels to use for the contour plot.
  ##   subset: The subset of the elements in draws to plot.  This can
  ##     be a numeric vector.  If draws is a named list it can also be
  ##     names.  If NULL then everything is plotted.
  ##   color: A vector of colors to use for the different subsets
  ##     begin plotted.
  ##   lty: A vector giving the type of line to use for each subset of
  ##     draws.
  ##   axes:  logical.  Should axes and a box be drawn around the figure?
  ##   ...:  Extra arguments passed to 'contour'

  if (!is.list(draws)) {
    draws <- list(draws)
  }

  stopifnot(is.list(draws))
  if (is.null(subset)) {
    subset <- 1:length(draws)
  }

  first.x <- draws[[subset[1]]][, x.index]
  first.y <- draws[[subset[1]]][, y.index]

  fixed.xlim <- !is.null(xlim)
  fixed.ylim <- !is.null(ylim)

  for (s in subset) {
    if (!fixed.xlim) {
      xlim <- range(xlim, draws[[s]][, x.index])
    }
    if (!fixed.ylim) {
      ylim <- range(ylim, draws[[s]][, y.index])
    }
  }

  if (is.null(color)) {
    color <- 1:length(subset)
  }

  if (is.null(lty)) {
    lty = 1:length(subset)
  }

  counter <- 0
  for (s in subset) {
    draws.matrix <- draws[[s]][, c(x.index, y.index)]
    counter <- counter + 1
    contour(MASS::kde2d(draws.matrix[, 1], draws.matrix[, 2]),
            nlevels = nlevels,
            xlim = xlim,
            ylim = ylim,
            col = color[counter],
            lty = lty[counter],
            add = (counter > 1),
            axes = axes,
            ...)
  }
}
    branches: [ "main" ]
  pull_request: PlotDynamicDistribution <- function(curves,
                                    timestamps = NULL,
                                    quantile.step = .01,
                                    xlim = NULL,
                                    xlab = "Time",
                                    ylim = range(curves, na.rm = TRUE),
                                    ylab = "distribution",
                                    add = FALSE,
                                    axes = TRUE,
                                    ...) {
  ## Plots pointwise probability distributions as they evolve over
  ## the range of 'x'.
  ## Args:
  ##   curves: a matrix where each row represents a curve (e.g. a
  ##     simulation of a time series from a posterior distribution)
  ##     and columns represent different time points.
  ##   timestamps: An optional vector of "time stamps" that 'curves'
  ##     will be plotted against.  The length of 'x' must match the
  ##     number of columns in 'curves'.  If x is NULL then the
  ##     function attempts to extract time stamps from the colnames
  ##     of curves.  If no appropriate time stamps can be found then
  ##     the positive integers will be used as time stamps.
  ##   quantile.step: Manages the number of polygons used to create
  ##     the plot.  Smaller values lead to more polygons, which is a
  ##     smoother visual effect, but more polygons take more time to
  ##     plot.
  ##   xlim: the x limits (x1, x2) of the plot.  Note that ‘x1 > x2’
  ##     is allowed and leads to a ‘reversed axis’.
  ##   xlab: Label for the horizontal axis.
  ##   ylim: the y limits (y1, y2) of the plot.  Note that ‘y1 > y2’
  ##     is allowed and leads to a ‘reversed axis’.
  ##   ylab: Label for the vertical axis.
  ##   add: Logical.  If true then add the plot to the current
  ##     plot.  Otherwise a fresh plot will be created.
  ##   ...:  Extra arguments to be passed to 'plot'.
  ## Returns:
  ##   There is no return value from this function.  It produces a
  ##     plot on the current graphics device.
  stopifnot(ncol(curves) >= 1)
  ##--------------------------------------
  .FilledPlot <- function(timestamps,
                          quantile.matrix,
                          poly.color,
                          add = FALSE,
                          xlab,
                          ylab,
                          ylim,
                          xlim,
                          ...) {
    ## This is a driver function to draw one of the nested polygons
    ## for PlotDynamicDistribution
    ylo <- quantile.matrix[, 1]
    yhi <- quantile.matrix[, 2]

    stopifnot(length(timestamps) == nrow(quantile.matrix))

    if (any(yhi < ylo, na.rm = TRUE)) {
      warning("second column of quantile.matrix must be >= the first")
    }

    if (!add) {
      if (!all(is.finite(ylim))) {
        ylim <- range(quantile.matrix, na.rm = TRUE)
      }
      plot(timestamps,
           ylo,
           xlim = xlim,
           ylim = ylim,
           xlab = xlab,
           ylab = ylab,
           type = "n",
           ...)
    }

    ## Create X and Y values of polygon points, then draw the
    ## polygon.
    observed.values <- !(is.na(ylo) | is.na(yhi))
    observed.rle <- rle(observed.values)  ## rle is "run length encoding"
    number.of.contiguous.regions <- length(observed.rle$lengths)
    for (i in 1:number.of.contiguous.regions) {
      if (observed.rle$values[i]) {
        if (i == 1) {
          start <- 1
        } else {
          start <- sum(observed.rle$lengths[1:(i - 1)])
        }
        finish <- start + observed.rle$lengths[i] - 1
        index <- seq(start, finish)
        X <- c(timestamps[index],
               rev(timestamps[index]),
               timestamps[index][1])
        Y <- c(ylo[index],
               rev(yhi[index]),
               ylo[index][1])
        polygon(X, Y, border = NA, col = poly.color)
      }
    }
  }
  ##--------------------------------------
  qtl <- seq(0, 1, by = quantile.step)
  ## quantile.matrix is the actual matrix of quantiles that are used
  ## to draw the curve polygons
  quantile.matrix <- t(apply(curves, 2, quantile, probs = qtl, na.rm = TRUE))

  nc <- ncol(quantile.matrix)
  number.of.quantile.steps <- (nc + 1) / 2
  if (number.of.quantile.steps < 3) {
    stop("'quantile.step' is too large in PlotDynamicDistribution")
  }

  lower.quantile <- quantile.matrix[, 1]
  upper.quantile <- quantile.matrix[, nc]
  if (is.null(timestamps)) {
    if (!is.null(colnames(curves))) {
      ## Try converting the colnames of 'curves' to a POSIX time
      ## object.  Signal failure by returning NULL.
      timestamps <- tryCatch(
        as.POSIXct(colnames(curves)),
        error = function(e) {return(NULL)}
      )
    }
    ## If the conversion failed, then just use the natural numbers
    ## 1, 2, ... as timestamps.
    if (is.null(timestamps) || length(timestamps) == 0) {
      timestamps <- 1:ncol(curves)
    }
  }
  if (is.null(xlim)) {
    xlim <- range(timestamps, na.rm = TRUE)
  }
  if (inherits(xlim, "POSIXt")) {
    xlim <- as.POSIXct(xlim)
  }

  .FilledPlot(timestamps,
              cbind(lower.quantile, upper.quantile),
              poly.color = gray(1 - 1/number.of.quantile.steps),
              axes = FALSE,
              add = add,
              xlim = xlim,
              xlab = xlab,
              ylim = ylim,
              ylab = ylab,
              ...)
  box()
  if (axes) {
    if (inherits(timestamps, "Date")) {
      axis.Date(1, timestamps, xpd = NA)
    } else if (inherits(timestamps, "POSIXt")) {
      axis.POSIXct(1, as.POSIXct(timestamps), xpd = NA)
    } else {
      axis(1, xpd = NA)
    }
    axis(2, xpd = NA)
  }
  for (i in 2:(number.of.quantile.steps - 1)) {
    lower.quantile <- quantile.matrix[, i]
    upper.quantile <- quantile.matrix[, nc + 1 - i]
    .FilledPlot(timestamps,
                cbind(lower.quantile, upper.quantile),
                add = TRUE,
                poly.color = gray((1 - i / number.of.quantile.steps)))
  }
  return(NULL)
}
    branches: [ "main" ]

permissions: PlotMacf <- function (x, lag.max = 40, gap = 0.5, main = NULL, boxes = TRUE,
    xlab = "lag", ylab = "ACF", type = "h") {
  ## Plot the autocorrelation function for a multivariate object.
  ## Args:
  ##   x: A numeric matrix, three-way array, or list of numeric
  ##     vectors.  If a matrix or array then the first index
  ##     corresponds to observation number.
  ##   lag.max:  The number of lags to compute in the ACF.
  ##   gap:  The size of the gap between plots.
  ##   main:  The main title for the plot.
  ##   boxes:  Logical.  Should boxes be drawn around the plots.
  ##   xlab:  The label for the horizontal axis.
  ##   ylab:  The label for the vertical axis.
  ##   type:  The plot type to use for plotting the ACF's.
  ##
  is.odd <- function(x) (x - 1)%%2 == 0

  if (is.list(x)) {
    nx <- length(x)
    nr <- max(1, floor(sqrt(nx)))
    nc <- ceiling(nx/nr)
  }
  else if (is.array(x)) {
    d <- dim(x)
    if (is.null(d) | length(d) == 1) {
      acf(as.vector(x), lag.max = lag.max, main = main,
          xlab = xlab, ylab = ylab)
      return(invisible(NULL))
    }
    ndim <- length(d)
    if (ndim == 3) {
      nr <- d[2]
      nc <- d[3]
      nx <- nr * nc
    }
    else if (ndim == 2) {
      nx <- d[2]
      nr <- max(c(floor(nx/sqrt(nx)), 1))
      nc <- ceiling(nx/nr)
    }
  }
  oma <- rep(4, 4)
  if (!is.null(main))
    oma[3] <- 6
  if (!is.null(xlab))
    oma[1] <- 6
  if (!is.null(ylab))
    oma[2] <- 6
  opar <- par(mfrow = c(nr, nc), mar = rep(gap/2, 4), oma = oma)
  on.exit(par(opar))
  a <- array(0, dim = c(lag.max + 1, nr, nc))
  m <- 0
  for (j in 1:nr) {
    for (k in 1:nc) {
      m <- m + 1
      if (m > nx)
        break
      if (is.list(x)) {
        y <- x[[m]]
        indx <- (1:length(y))[!is.na(y)]
        y <- y[indx]
      }
      else if (ndim == 3)
        y <- x[, j, k]
      else if (ndim == 2)
        y <- x[, m]
      else {
        cat("error in plot.macf:  wrong dimension for x\n")
        return(invisible(NULL))
      }
      if (length(y) == 1)
        tmp2 <- 1
      else tmp2 <- acf(y, lag.max = min(lag.max, length(y)),
                       plot = FALSE)$acf
      if (length(tmp2) < lag.max + 1) {
        zeros <- rep(0, lag.max + 1 - length(tmp2))
        tmp2 <- c(tmp2, zeros)
      }
      a[, j, k] <- tmp2
      if (any(is.na(a[, j, k]))) {
        if (sd(y) == 0) {
          a[1, j, k] <- 1
          a[2:(lag.max + 1), j, k] <- 0
        }
      }
    }
  }
  m <- 0
  lg <- 0:lag.max
  for (j in 1:nr) {
    ylim <- range(a[, j, ])
    for (k in 1:nc) {
      m <- m + 1
      if (m > nx) {
        plot(lg, type = "n", axes = FALSE)
        axis(1)
      }
      else {
        plot(lg, a[, j, k], axes = FALSE, type = type, ylim = ylim)
        if (boxes) {
          box()
        }
        abline(h = 0)
        if (j == nr)
          axis(1, xpd = NA)
        if (k == 1 & is.odd(j))
          axis(2, xpd = NA)
        if (k == nc & !is.odd(j))
          axis(4, xpd = NA)
      }
    }
  }
  if (!is.null(main))
    mtext(main, 3, 3, TRUE, 0.5, cex = par("cex.main"), font = par("font.main"))
  if (!is.null(xlab))
    mtext(xlab, 1, 3, TRUE, 0.5)
  if (!is.null(ylab))
    mtext(ylab, 2, 3, TRUE, 0.5)
  return(invisible(NULL))
}
  contents: read

jobs: PlotManyTs <- function (x, type = "l", gap = 0, boxes = TRUE, truth = NULL,
                        thin = 1, labs, same.scale = TRUE, ylim = NULL,
                        refline = NULL, color = NULL, ...) {
  ## Plot many time series, each on its own time axis.
  ## Args:

  ##   x: A matrix, data.frame, list, or 3-way array of time series.  For
  ##     everything but lists, The first dimension corresponds to time.
  ##   type:  The plotting type to use when plotting the time series.
  ##   gap:  The amount of space to put between plots.
  ##   boxes:  Logical.  Should boxes be drawn around the plots?
  ##   truth: A vector of values at which to draw fat black horizontal lines.
  ##   thin: Plot every thin'th observation.  This can reduce the amount of time
  ##     it takes to make the plot if there are many long time series.
  ##   labs: A character vector to use as labels for individual plots.  If labs
  ##     is missing then column names or dimnames will be used to label the
  ##     plots.  If labs is NULL then no labels will be used.
  ##   same.scale: Logical.  If TRUE then all plots are shown on the same
  ##     verical scale, and vertical axes are drawn.  If FALSE then each plot
  ##     gets its own scale.
  ##   ylim: The scale of the vertical axis.  If non-NULL then same.scale will
  ##     be set to TRUE.
  ##   refline: The scalar value at which a thin dotted horizontal line should
  ##     be plotted in each panel.  This is useful for highlighting zero, for
  ##     example.
  ##   color:  A vector of colors to use for the plots.
  ##   ...:  Extra arguments passed to 'plot' and 'axis'.
  if (is.list(x) && !is.data.frame(x)) {
    x <- as.data.frame(x)
  }
  stopifnot(is.array(x) || is.data.frame(x))
  is.odd <- function(x) (x - 1)%%2 == 0
  is.even <- function(x) x%%2 == 0
  add.refline <- function(refline, i) {
    if (is.null(refline)) {
      return()
    }
    if (length(refline) == 1) {
      y <- refline
    } else {
      y <- refline[i]
    }
    abline(h = y, lty = 3)
  }
  if (is.matrix(x) && missing(labs)) {
    labs <- colnames(x)
  }
  if (is.data.frame(x)) {
    if (missing(labs)) {
      labs <- names(x)
    }
    x <- as.matrix(x)
  }
  dx <- dim(x)
  if (length(dx) == 3) {
    nr <- dx[2]
    nc <- dx[3]
    if (missing(labs)) {
      labs <- dimnames(x)
      if (!is.null(labs)) {
        sep <- ":"
        if (is.null(labs[[2]])) {
          labs[[2]] <- rep("", dim(x)[2])
          sep <- ""
        }
        if (is.null(labs[[3]])) {
          labs[[3]] <- rep("", dim(x)[3])
          sep <- ""
        }
        labs <- outer(labs[[3]], labs[[2]], paste, sep = sep)
      }
    }
    x <- matrix(aperm(x, c(1, 3, 2)), nrow = dx[1])
    nx <- ncol(x)
  } else {
    nx <- ncol(x)
    nr <- max(1, floor(sqrt(nx)))
    nc <- ceiling(nx/nr)
  }
  indx <- thin * (1:floor(nrow(x)/thin))
  x <- x[indx, ]
  nobs <- length(indx)
  if (is.null(color)) {
    color <- rep("black", nx)
  }
  use.truth <- !is.null(truth) && is.numeric(truth) && length(truth) > 0
  if (use.truth && length(truth) != nx) {
    warning("Expected ", nx, " elements in 'truth', but it had ",
      length(truth), ".  Ignoring 'truth' argument. \n",
      "YOU WANT THE TRUTH?  YOU CAN'T HANDLE THE TRUTH!!")
    use.truth <- FALSE
  }
  if (use.truth) {
    full.range <- rbind(as.numeric(truth), x)
  } else {
    full.range <- x
  }
  if (!is.null(ylim)) {
    same.scale <- TRUE
  }
  if (is.null(ylim)) {
    ylim <- range(full.range, na.rm = TRUE)
    if (!is.null(refline)) {
      ylim <- range(c(ylim, refline))
    }
  }
  original.par <- par(mfrow = c(nr, nc), mar = rep(gap/2, 4),
    oma = c(4, 4, 4, 4))
  on.exit(par(original.par))
  m <- 0
  fake.plot <- FALSE
  for (j in 1:nr) {
    for (k in 1:nc) {
      m <- m + 1
      if (m > nx) {
        plot(indx, rep(ylim, len = nobs), type = "n",
          axes = FALSE)
        fake.plot <- TRUE
      } else {
        if (same.scale == FALSE) {
          if (use.truth) {
            full.range <- c(truth[m], x[, m])
          } else {
            full.range <- x[, m]
          }
          ylim <- range(full.range)
        }
        plot(indx, x[, m], axes = FALSE, type = type,
          ylim = ylim, col = color[m], ...)
        if (!missing(labs) && !is.null(labs)) {
          text(min(indx), max(ylim), labs[m], pos = 4)
        }
        if (use.truth) {
          abline(h = truth[m], lwd = 2)
        }
        add.refline(refline, m)
        if (boxes) {
          box()
        }
      }
      if (j == nr && is.odd(k)) {
        axis(1, xpd = NA, ...)
      }
      else if (j == 1 && is.even(k)) {
        axis(3, xpd = NA, ...)
      }
      if (k == 1 && same.scale == TRUE && is.odd(j))
        axis(2, xpd = NA, ...)
      else if (k == nc && same.scale == TRUE && is.even(j))
        axis(4, xpd = NA, ...)
    }
  }
}
  build: SdPrior <- function(sigma.guess,
                    sample.size = .01,
                    initial.value = sigma.guess,
                    fixed = FALSE,
                    upper.limit = Inf) {
  ## Generates an object of class SdPrior that can be used as an input
  ## to a Bayesian model for a standard deviation paramter.
  ##
  ## Args:
  ##   sigma.guess: An a priori guess at the value of the standard
  ##     deviation modeled by this distribution.
  ##   sample.size: The number of observations worth of weight to give
  ##     to sigma.guess.
  ##   initial.value: The initial value to use (in an MCMC algorithm)
  ##     for a deviate modeled by this distribution.
  ##   fixed: Should the deviate modeled by this distribution be fixed
  ##     at its initial value?  (Used for debugging by some code.  Not
  ##     universal.)
  ##   upper.limit: The largest acceptable value for the standard
  ##     deviation modeled by this distribution.  May be Inf.
  stopifnot(is.numeric(sigma.guess), length(sigma.guess) == 1, sigma.guess > 0)
  stopifnot(is.numeric(sample.size), length(sample.size) == 1, sample.size > 0)
  stopifnot(is.numeric(initial.value), length(initial.value) == 1,
            initial.value > 0)
  stopifnot(is.logical(fixed), length(fixed) == 1)
  stopifnot(is.numeric(upper.limit), length(upper.limit) == 1)
  ans <- list(prior.guess = sigma.guess,
              prior.df = sample.size,
              initial.value = initial.value,
              fixed = fixed,
              upper.limit = upper.limit)
  class(ans) <- c("SdPrior", "DiffDoubleModel", "DoubleModel", "Prior")
  return(ans)
}

NormalPrior <- function(mu, sigma, initial.value = mu, fixed = FALSE) {
  ## Returns a list with the information needed to specify a Gaussian
  ## prior on a scalar parameter.
  ##
  ## Args:
  ##   mu:  Mean of the distribution.
  ##   sigma:  Standard deviation.
  ##   initial.value: The initial value of the deviate to be modeled
  ##     by this distribution in an MCMC algorithm.
  ##   fixed: Should the deviate modeled by this distribution be fixed
  ##     at its initial value?  (Used for debugging by some code.  Not
  ##     universal.)
  stopifnot(is.numeric(mu), length(mu) == 1)
  stopifnot(is.numeric(sigma), length(sigma) == 1, sigma >= 0)
  stopifnot(is.numeric(initial.value), length(initial.value) == 1)
  stopifnot(is.logical(fixed), length(fixed) == 1)
  ans <- list(mu = mu,
              sigma = sigma,
              initial.value = initial.value,
              fixed = fixed)
  class(ans) <- c("NormalPrior", "DiffDoubleModel", "DoubleModel", "Prior")
  return(ans)
}

Ar1CoefficientPrior <- function(mu = 0,
                                sigma = 1,
                                force.stationary = TRUE,
                                force.positive = FALSE,
                                initial.value = mu) {
  ## Returns a list with the information needed to supply a prior
  ## distribution on an AR1 coefficient.
  ans <- NormalPrior(mu, sigma, initial.value)
  ans$force.stationary <- force.stationary
  ans$force.positive <- force.positive
  class(ans) <- c("Ar1CoefficientPrior", class(ans))
  return(ans)
}

BetaPrior <- function(a = 1, b = 1, mean = NULL, sample.size = NULL,
                      initial.value = NULL) {
  ## Returns an object of class "BetaPrior", which is a list
  ## containing the parameters of a beta distribution.  The prior can
  ## either be given in terms of 'a' and 'b', or it can be given in
  ## terms of mean and sample.size, where mean = a/a+b and sample.size
  ## = a+b.
  if (!is.null(sample.size) && !is.null(mean)) {
    stopifnot(is.numeric(mean) &&
              is.numeric(sample.size) &&
              length(mean) == 1 &&
              length(sample.size) == 1)
    a <- mean * sample.size
    b <- (1 - mean) * sample.size
  }

  stopifnot(is.numeric(a),
            length(a) == 1,
            a > 0)
  stopifnot(is.numeric(b),
            length(b) == 1,
            b > 0)
  if (is.null(initial.value)) {
    initial.value <- a / (a + b)
  }
  stopifnot(is.numeric(initial.value),
            length(initial.value) == 1,
            initial.value > 0,
            initial.value < 1);
  ans <- list(a = a, b = b, initial.value = initial.value)
  class(ans) <- c("BetaPrior", "DiffDoubleModel", "DoubleModel", "Prior")
  return(ans)
}

UniformPrior <- function(lo = 0, hi = 1, initial.value = NULL) {
  ## A uniform prior distribution on the interval [lo, hi].
  ## Args:
  ##   lo:  The lower limit of prior support.
  ##   hi:  The upper limit of prior support.
  ## Returns:
  ##   An object of class UniformPrior.
  stopifnot(is.numeric(lo),
            length(lo) == 1)
  stopifnot(is.numeric(hi),
            length(lo) == 1,
            lo <= hi)
  if (is.null(initial.value)) {
    initial.value <- .5 * (lo + hi)
  }
  stopifnot(is.numeric(initial.value),
            length(initial.value) == 1,
            initial.value >= lo,
            initial.value <= hi)
  ans <- list(lo = lo, hi = hi, initial.value = initial.value)
  class(ans) <- c("UniformPrior", "DiffDoubleModel", "DoubleModel", "Prior")
  return(ans)
}

GammaPrior <- function(a = NULL, b = NULL, prior.mean = NULL,
                       initial.value = NULL) {
  ## Gamma distribution with parameters (a, b), where the mean is a/b
  ## and variance is a/b^2.
  ## Args:
  ##   a:  The shape parameter 'a'.
  ##   b:  The scale parameter 'b'.
  ##   prior.mean: This specifies a/b.  If non-NULL at least one of
  ##     'a' or 'b' must be specified.
  ##   initial.value: The initial.value of the variable to be modeled
  ##     in the MCMC algorithm.
  ## Returns:
  ##   An object of class GammaPrior.
  if (is.null(prior.mean)) {
    stopifnot(!is.null(a))
    stopifnot(is.numeric(a))
  } else {
    stopifnot(is.numeric(prior.mean))
    if (!is.null(a) && is.numeric(a)) {
      b <- a / prior.mean
    } else if (!is.null(b) && is.numeric(b)) {
      a <- b * prior.mean
    }
  }
  stopifnot(is.numeric(a))
  stopifnot(is.numeric(b))
  stopifnot(length(a) == 1)
  stopifnot(length(b) == 1)
  stopifnot(all(a > 0))
  stopifnot(all(b > 0))

  if (is.null(initial.value)) {
    initial.value <- a / b
  }
  ans <- list(a = a, b = b, initial.value = initial.value)
  class(ans) <- c("GammaPrior", "DiffDoubleModel", "DoubleModel", "Prior")
  return(ans)
}

TruncatedGammaPrior <- function(a = NULL, b = NULL, prior.mean = NULL,
                                initial.value = NULL,
                                lower.truncation.point = 0,
                                upper.truncation.point = Inf) {
  ## A Gamma distribution with parameter matching 'GammaPrior' but
  ## with support truncated to between lower.truncation.point and
  ## upper.truncation.point.
  ans <- GammaPrior(a, b, prior.mean, initial.value)
  stopifnot(is.numeric(lower.truncation.point),
            length(lower.truncation.point) == 1)
  stopifnot(is.numeric(upper.truncation.point),
            length(upper.truncation.point) == 1,
            upper.truncation.point > lower.truncation.point)
  ans$lower.truncation.point <- lower.truncation.point
  ans$upper.truncation.point <- upper.truncation.point
  if (!is.null(initial.value) && (
      initial.value < lower.truncation.point ||
          initial.value > upper.truncation.point)) {
    stop("Initial value must be between the lower and upper truncation points.")
  } else if (ans$initial.value < lower.truncation.point
             || ans$initial.value > upper.truncation.point) {
    if (is.finite(upper.truncation.point)) {
      warning("Initial value for TruncatedGammaPrior is outside the ",
              "supported range. Changing it to the midpoint of the ",
              "support region.")
      ans$initial.value <- .5 * (lower.truncation.point +
                                     upper.truncation.point)
    } else {
      warning("Initial value for TruncatedGammaPrior is outside the ",
              "supported range. Placing it above the lower bound.")
      ans$initial.value <- lower.truncation.point + 1
    }
  }
  class(ans) <- c("TruncatedGammaPrior", "DiffDoubleModel",
                  "DoubleModel", "Prior")
  return(ans)
}


LognormalPrior <- function(mu = 0.0, sigma = 1.0, initial.value = NULL) {
  ## A lognormal distribution, where log(y) ~ N(mu, sigma).  The mean
  ## of this distribution is exp(mu + 0.5 * sigma^2), so don't only
  ## focus on the mean parameter here.
  ##
  ## Args:
  ##   mu:  mean of the corresponding normal distribution.
  ##   sigma: standard deviation of the corresponding normal
  ##     distribution.  WARNING: If something looks strange in your
  ##     program, look out for SD != Variance errors.
  stopifnot(is.numeric(mu),
            length(mu) == 1,
            is.finite(mu))
  stopifnot(is.numeric(sigma),
            length(sigma) == 1,
            sigma > 0,
            is.finite(sigma))
  if (is.null(initial.value)) {
    initial.value <- exp(mu + .5 * sigma^2)
  }
  stopifnot(is.numeric(initial.value),
            length(initial.value) == 1,
            initial.value > 0,
            is.finite(initial.value))

  ans <- list(mu = mu, sigma = sigma, initial.value = initial.value)
  class(ans) <- c("LognormalPrior", "DiffDoubleModel", "DoubleModel", "Prior")
  return(ans)
}

MarkovPrior <- function(prior.transition.counts = NULL,
                        prior.initial.state.counts = NULL,
                        state.space.size = NULL,
                        uniform.prior.value = 1) {
  ## Prior distribution for a MarkovModel.
  ## Args:
  ##   prior.transition.counts: A matrix of non-negative numbers
  ##     interpretable as prior counts.  Transitions are from rows to
  ##     columns.
  ##   prior.initial.state.counts: A vector of non-negative numbers
  ##     interpretable as prior counts.
  ##   state.space.size: If both prior.transition.counts and
  ##     prior.initial.state.counts are missing then they will be filled
  ##     with an object of dimension state.space.size where all
  ##     entries are set to uniform.prior.value.
  ##   uniform.prior.value: The default value to use for entries of
  ##     prior.transition.counts and prior.initial.state.counts, when
  ##     they are not supplied by the user.
  if (is.null(state.space.size)) {
    if (is.null(prior.transition.counts) && is.null(prior.transition.counts)) {
      stop("Either 'state.space.size' or one of 'prior.transition.counts' or",
           "'prior.initial.state.counts' must be supplied to MarkovPrior")
    }
    if (!is.null(prior.transition.counts)) {
      state.space.size <- nrow(prior.transition.counts)
    } else {
      state.space.size <- length(prior.initial.state.counts)
    }
  }
  stopifnot(state.space.size > 0)
  stopifnot(uniform.prior.value > 0)

  if (is.null(prior.transition.counts)) {
    prior.transition.counts <- matrix(uniform.prior.value, nrow =
      state.space.size, ncol = state.space.size)
  } else {
    stopifnot(is.matrix(prior.transition.counts))
    stopifnot(nrow(prior.transition.counts) == ncol(prior.transition.counts))
    stopifnot(all(prior.transition.counts >= 0))
    .CheckForPositiveValue <- function(x) { return(any(x > 0)) }
    ## Check that at least one positive value is present in each row.
    stopifnot(all(apply(prior.transition.counts, 1, .CheckForPositiveValue)))

    ## If state.space.size and prior.transition.counts are both
    ## present then issue a warning if they don't match, and use
    ## prior.transition.counts.
    if (state.space.size != nrow(prior.transition.counts)) {
      warning("state.space.size is ", state.space.size,
              ", but nrow(prior.transition.counts) is",
              nrow(prior.transition.counts),
              ".  Changing state.space.size to nrow(prior.transition.counts).")
      state.space.size <- nrow(prior.transition.counts)
    }
  }

  if (is.null(prior.initial.state.counts)) {
    prior.initial.state.counts <- rep(uniform.prior.value, state.space.size)
  } else {
    stopifnot(is.numeric(prior.initial.state.counts))
    ##  Allow a prior that places all its mass on a single point.
    stopifnot(all(prior.initial.state.counts >= 0))
    stopifnot(any(prior.initial.state.counts > 0))
  }

  prior <- list(prior.transition.counts = prior.transition.counts,
                prior.initial.state.counts = prior.initial.state.counts)
  class(prior) <- c("MarkovPrior", "Prior")
  return(prior)
}

DirichletPrior <- function(prior.counts, initial.value = NULL) {
  ## Encodes a Dirichlet priors, the conjugate prior for the
  ## multinomial distribution.
  ## Args:
  ##   prior.counts: A vector of positive numbers with dimension
  ##     matching the probability distribution it is modeling.
  ## Returns:
  ##   An object of class DirichletPrior, which is a list containing
  ##   the prior.counts argument, after some type and sanity checking.
  stopifnot(is.numeric(prior.counts))
  stopifnot(length(prior.counts) > 0)
  stopifnot(all(prior.counts > 0))
  if (is.null(initial.value)) {
    initial.value <- prior.counts / sum(prior.counts)
  }
  ans <- list(prior.counts = prior.counts)
  class(ans) <- c("DirichletPrior", "Prior")
  return(ans)
}

NormalInverseGammaPrior <- function(mu.guess,
                                    mu.guess.weight = .01,
                                    sigma.guess,
                                    sigma.guess.weight = 1,
                                    ...) {
  ## A conjugate prior for the mean and variance of a Gaussian
  ## distribution.
  ## Args:
  ##   mu.guess:  Prior guess at the normal mean parameter.
  ##   mu.guess.weight: Number of observations worth of weight
  ##     assigned to mu.guess.
  ##   sigma.guess: A prior guess at the value of the normal standard
  ##     deviation parameter.
  ##   sigma.guess.weight: Number of observations worth of weight
  ##     assigned to sigma.guess.
  ##   ...: extra parameters passed to SdPrior
  ## Returns:
  ##   An object of class NormalInverseGammaPrior, which contains the
  ##   'mu' arguments and an element of type SdPrior
  stopifnot(is.numeric(mu.guess))
  stopifnot(mu.guess.weight > 0)
  ans <- list(mu.guess = mu.guess,
              mu.guess.weight = mu.guess.weight,
              sigma.prior = SdPrior(
                  sigma.guess = sigma.guess,
                  sample.size = sigma.guess.weight,
                  ...))
  class(ans) <- c("NormalInverseGammaPrior", "Prior")
  return(ans)
}

MvnPrior <- function(mean, variance) {
  ## Encodes the mean and variance of a multivariate normal
  ## distribution for use as a prior distribution.
  ## Args:
  ##   mean:  A numeric vector
  ##   variance:  A symmetric positive definite matrix.
  ## Returns:
  ##   An object of class MvnPrior containing the mean and variance
  ##   arguments, after some sanity checking.
  if (length(variance) == 1) {
    variance <- diag(as.numeric(variance), length(mean), length(mean))
  }
  stopifnot(is.matrix(variance))
  stopifnot(nrow(variance) == ncol(variance))
  stopifnot(nrow(variance) == length(mean))
  ans <- list(mean = mean,
              variance = variance)
  class(ans) <- c("MvnPrior", "Prior")
  return(ans)
}

MvnGivenSigmaMatrixPrior <- function(mean, sample.size) {
  stopifnot(is.numeric(mean))
  stopifnot(is.numeric(sample.size),
            length(sample.size) == 1,
            sample.size > 0)
  ans <- list("mean" = mean, "sample.size" = sample.size)
  class(ans) <- c("MvnGivenSigmaMatrixPrior", "Prior")
  return(ans)
}

InverseWishartPrior <- function(variance.guess,
                                variance.guess.weight) {
  ## Conjugate prior distribution for the variance matrix in a multivariate
  ## normal wtih known mean.

  stopifnot(is.matrix(variance.guess))
  stopifnot(is.numeric(variance.guess.weight),
            length(variance.guess.weight) == 1,
            variance.guess.weight > ncol(variance.guess))
  ans <- list(variance.guess = variance.guess,
              variance.guess.weight = variance.guess.weight)
  class(ans) <- c("InverseWishartPrior", "Prior")
  return(ans)
}

NormalInverseWishartPrior <- function(
    mean.guess,
    mean.guess.weight = .01,
    variance.guess,
    variance.guess.weight = nrow(variance.guess) + 1) {
  ## The conjugate prior distribution for the multivariate normal.  A
  ## multivariate generalization of the NormalInverseGammaPrior
  ## Args:
  ##   mean.guess: A numeric vector that is a guess at the value of
  ##     the multivariate normal mean parameter.
  ##   mean.guess.weight: The number of observations worth of weight
  ##     assigned to mean.guess.
  ##   variance.guess: A symmetric positive definite matrix that is a
  ##     guess at the value of the multivariate normal variance
  ##     parameter.
  ##   variance.guess.weight: The number of observations worth of
  ##     weight assigned to variance.guess.
  stopifnot(is.vector(mean.guess))
  stopifnot(is.matrix(variance.guess))
  stopifnot(all(dim(variance.guess) == length(mean.guess)))
  stopifnot(is.numeric(mean.guess.weight),
            length(mean.guess.weight) == 1,
            mean.guess.weight > 0)
  stopifnot(is.numeric(variance.guess.weight),
            length(variance.guess.weight) == 1,
            variance.guess.weight > 0)

  ans <- list(mean.guess = mean.guess,
              mean.guess.weight = mean.guess.weight,
              variance.guess = variance.guess,
              variance.guess.weight = variance.guess.weight)
  class(ans) <- c("NormalInverseWishartPrior", "Prior")
  return(ans)
}

MvnDiagonalPrior <- function(mean.vector, sd.vector) {
  ## A multivariate normal distribution with a diagonal variance
  ## matrix (i.e. the product of several independent normals).
  ##
  ## Args:
  ##   mean.vector:  The mean of the multivariate normal.
  ##   sd.vector: The standard deviations of the elements of the
  ##     multivariate normal.
  ##
  ## Returns:
  ##   An object of class MvnDiagonalPrior, which is a list containing
  ##   mean.vector and sd.vector.
  stopifnot(is.numeric(mean.vector))
  stopifnot(is.numeric(sd.vector))
  stopifnot(all(sd.vector > 0))
  stopifnot(length(mean.vector) == length(sd.vector))

  ans <- list(mean = mean.vector, sd = sd.vector)
  class(ans) <- c("MvnDiagonalPrior", "Prior")
  return(ans)
}

MvnIndependentSigmaPrior <- function(mvn.prior, sd.prior.list) {
  ## A prior for the parameters of the multivariate normal
  ## distribution that assumes Sigma to be a diagonal matrix with
  ## elements modeled by independent inverse Gamma priors.
  ##
  ## Args:
  ##   mvn.prior: An object of class MvnPrior that is the prior
  ##     distribution of the multivariate normal mean parameter.
  ##   sd.prior.list: A list of SdPrior object modeling the diagonal
  ##     elements of the multivariate normal variance matrix.  The
  ##     off-diagonal elements are assumed to be zero.
  ##
  ## Returns:
  ##   An object of clas MvnIndependentSigmaPrior, which is a list
  ##   containing the function arguments.
  stopifnot(inherits(mvn.prior, "MvnPrior"))
  stopifnot(is.list(sd.prior.list))
  stopifnot(length(sd.prior.list) == length(mvn.prior$mean))
  stopifnot(all(sapply(sd.prior.list, inherits, "SdPrior")))

  ans <- list(mu.prior = mvn.prior,
              sigma.prior = sd.prior.list)
  class(ans) <- c("MvnIndependentSigmaPrior", "Prior")
  return(ans)
}

ScaledMatrixNormalPrior <- function(mean, nu) {
  # A prior for multivariate regression coefficients Beta, such that
  # Beta | Sigma ~ MatrixNormal(mu, X'X / nu, Sigma)
  #
  # Args:
  #   mean:  A matrix of the same size as Beta (ydim * xdim).
  #   nu: A scalar controlling the amount of prior correlation attributable to
  #     rows of beta.  In the context of multivariate regression, rows of beta
  #     correspond ot different Y variables.  A useful value for nu is kappa /
  #     sample.size, where kappa is the number of prior observations worth of
  #     weight you wish to give to 'mean'.
  #
  # Details:
  #   The Sigma parameter is obtained elsewhere.
  stopifnot(is.matrix(mean))
  stopifnot(is.numeric(nu), length(nu) == 1, nu > 0)
  ans <- list("mean" = mean, "nu" = nu)
  class(ans) <- c("ScaledMatrixNormalPrior", "Prior")
  return(ans)
}

MultivariateRegressionConjugatePrior <-function(coefficient.prior,
                                                variance.prior) {
  ## A conjguate prior for a multivariate regression model.
  ##
  ## Args:
  ##   coefficient.prior: An object of class ScaledMatrixNormalPrior
  ##     representing the prior on the regression coefficients.
  ##   variance.prior: An object of class InverseWishartPrior representing the
  ##     prior on the variance matrix.
  ##
  ## Returns:
  ##   A list containing the two arguments, after checking that they are the
  ##   right type.  The return value is marked with a class attribute
  ##   documenting its role.
  stopifnot(inherits(coefficient.prior, "ScaledMatrixNormalPrior"),
    inherits(variance.prior, "InverseWishartPrior"))
  ans <- list(coefficient = coefficient.prior, variance = variance.prior)
  class(ans) <- c("MultivariateRegressionConjugatePrior", "Prior")
  return(ans)
}

RegressionCoefficientConjugatePrior <- function(
    mean,
    sample.size,
    additional.prior.precision = numeric(0),
    diagonal.weight = 0) {
  ## A conditional prior for the coefficients (beta) in a linear regression
  ## model.  The prior is conditional on the residual variance sigma^2, the
  ## sample size n, and the design matrix X.  The prior is
  ##
  ##      beta | sigsq, X ~ N(b, sigsq * (Lambda^{-1} + V))
  ##
  ## where V^{-1} = ((1 - w) * XTX + w * Diag(XTX)) * kappa / n.
  ##
  ## Args:
  ##   mean:  The mean of the prior distribution, denoted 'b' above.
  ##   sample.size: The value denoted 'kappa' above.  This can be
  ##     interpreted as a number of observations worth of weight to be
  ##     assigned to 'b' in the posterior distribution.
  ##   additional.prior.precision: A vector of non-negative numbers
  ##     representing the diagonal matrix Lambda^{-1} above.  Positive
  ##     values for additional.prior.precision will ensure the
  ##     distribution is proper even if the regression model has no
  ##     data.  If all columns of the design matrix have positive
  ##     variance then additional.prior.precision can safely be set to
  ##     zero.  A zero-length numeric vector is a slightly more
  ##     efficient equivalent to a vector of all zeros.
  ##   diagonal.weight: The weight given to the diagonal when XTX is
  ##     averaged with its diagonal.  The purpose of diagonal.weight
  ##     is to keep the prior distribution proper even if X is less
  ##     than full rank.  If the design matrix is full rank then
  ##     diagonal.weight can be set to zero.
  ##
  ## Details:
  ##   The prior distribution also depends on the cross product matrix
  ##   XTX and the sample size n, which are not arguments to this
  ##   function.  It is expected that the underlying C++ code will get
  ##   those quantities elsewhere (presumably from the regression
  ##   modeled by this prior).
  stopifnot(is.numeric(mean))
  stopifnot(is.numeric(sample.size),
            length(sample.size) == 1,
            sample.size > 0)
  stopifnot(is.numeric(additional.prior.precision),
            length(additional.prior.precision) == length(mean)
            || length(additional.prior.precision) == 0)
  if (length(additional.prior.precision) > 0) {
    stopifnot(all(additional.prior.precision >= 0))
  }
  stopifnot(is.numeric(diagonal.weight),
            length(diagonal.weight) == 1,
            diagonal.weight >= 0,
            diagonal.weight <= 1)
  ans <- list(mean = mean,
              sample.size = sample.size,
              additional.prior.precision = additional.prior.precision,
              diagonal.weight = diagonal.weight)
  class(ans) <- c("RegressionCoefficientConjugatePrior")
  return(ans)
}

PointMassPrior <- function(location) {
  ## A prior putting a point mass (probability = 1) on a single scalar
  ## location.
  ## Args:
  ##   location:  The location of the point mass on the real line.
  ans <- list(location = location)
  class(ans) <- c("PointMassPrior", "DiscretePrior", "Prior")
  return(ans)
}

PoissonPrior <- function(mean, lower.limit = 0, upper.limit = Inf) {
  ## Prior over the positive integers based on a Poisson distribution.
  ## Can optionally be truncated to {lower.limit, ..., upper.limit},
  ## including the endpoints.

  ans <- list(mean = mean,
              lower.limit = lower.limit,
              upper.limit = upper.limit)
  class(ans) <- c("PoissonPrior", "DiscretePrior", "Prior")
  return(ans)
}

DiscreteUniformPrior <- function(lower.limit, upper.limit) {
  ## A discrete uniform distribution over the integers in
  ## {lower.limit, ..., upper.limit}.  The end points are included.
  ## Args:
  ##   lower.limit:  The lower limit of the support.
  ##   upper.limit:  The upper limit of the support.
  ans <- list(lower.limit = lower.limit,
              upper.limit = upper.limit)
  class(ans) <- c("DiscreteUniformPrior", "DiscretePrior", "Prior")
  return(ans)
}
    runs-on: macos-latest
    strategy: # Copyright 2018 Google LLC. All Rights Reserved.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA

RepList <- function(object, times) {
  ## A utility function to repeat 'object' in a list 'times' times.
  ## Args:
  ##   object:  The object to be repeated.
  ##   times:  The number of times to repeat it.
  ## Returns:
  ##   A list with 'object' repeated the requested number of times.
  return(rep(list(object), times))
}
      matrix: rmvn <- function(n = 1, mu, sigma = diag(rep(1, length(mu)))) {
  ## Draw from the multivariate normal distribution with mean
  ## vector mu and covariance matrix sigma.
  ##
  ## Args:
  ##   n:  The number of observations to draw.
  ##   mu:  The mean of the distribution.
  ##   sigma:  The variance of the distribution.
  ##
  ## Returns:
  ##   If n == 1 the return value is a vector.  Otherwise it is a
  ##   matrix where each row is a draw.
  stopifnot(is.matrix(sigma),
            nrow(sigma) == ncol(sigma))
  stopifnot(is.numeric(mu),
            length(mu) == nrow(sigma))
  if (sum(eigen(sigma)$values > 0) != length(mu)) {
    warning("covariance matrix is not positive definite!")
  }
  L <- t(chol(sigma))
  p <- length(mu)
  if (n == 1) {
    return(as.numeric(L %*% matrix(rnorm(p), ncol = 1) + mu))
  } else {
    return( t(L %*% matrix(rnorm(p * n), ncol = n) + as.numeric(mu)))
  }
}
        r-version: ['3.6.3', '4.1.1']

    steps: GaussianSuf <- function(y) {
  ## Sufficient statistics for a Gaussian distribution given data 'y'.
  stopifnot(is.numeric(y))
  ans <- list(
    n = sum(!is.na(y)),
    sum = sum(y, na.rm = TRUE),
    sumsq = sum(y^2, na.rm = TRUE))
  class(ans) <- c("GaussianSuf", "Suf")
  return(ans)
}

RegressionSuf <- function(X = NULL,
                          y = NULL,
                          xtx = crossprod(X),
                          xty = crossprod(X, y),
                          yty = sum(y^2),
                          n = length(y),
                          xbar = colMeans(X),
                          ybar = mean(y)) {
  ## Sufficient statistics for a regression model.
  ## Args:
  ##   X:  The predictor matrix for a regression problem.
  ##   y:  The response vector for a regression problem.
  ##   xtx:  Cross product of the predictor matrix.
  ##   xty:  cross product of the predictor matrix with the response vector.
  ##   yty:  sum of squares of the response vector.
  ##   n:  sample size.
  ##   xbar:  column means of the predictor matrix.
  ##
  ## Returns:
  ##   A list containing the arguments, which are checked to ensure they have
  ##   legal values and sizes.
  if (!is.null(X)) {
    stopifnot(is.matrix(X))

    if (!is.null(y)) {
      stopifnot(is.numeric(y),
                length(y) == nrow(X))
    }
  }

  stopifnot(is.matrix(xtx),
            all(xtx == t(xtx)))
  stopifnot(is.numeric(xty),
            length(xty) == nrow(xtx))
  stopifnot(is.numeric(yty),
            length(yty) == 1,
            yty >= 0)
  stopifnot(is.numeric(n),
            length(n) == 1,
            n >= 0)
  stopifnot(is.numeric(xbar),
            length(xbar) == length(xty))

  ans <- list(xtx = xtx,
              xty = xty,
              yty = yty,
              n = n,
              xbar = xbar)
  class(ans) <- c("RegressionSuf", "Suf")
  return(ans)
}
      - uses: actions/checkout@v4
      - name: Set up R ${{ SuggestBurnLogLikelihood <- function(log.likelihood,
                                     fraction = .10,
                                     quantile = .9) {
  ## Suggests a burn-in period for an MCMC chain based on the log
  ## likelihood values simulated on the last leg of the chain.
  ## Args:
  ##   log.likelihood: The MCMC sample path of log likelihood for a
  ##     model.
  ##   fraction: The fraction of the chain that should be used to
  ##     determine the log likelihood lower bound.
  ##   quantile: The quantile of the values in the final fraction that
  ##     must be exceeded before the burn-in period is declared over.
  ##
  ## Returns:
  ##   An iteration number to be used as a burn-in.  This can be 0 if
  ##   'fraction' is zero, which will be the case if no burn-in is
  ##   desired.
  ##
  ## Details:
  ##   Look at the last 'fraction' of the log.likelihood sequence and
  ##   find a specified quantile to use as a threshold.  Then return
  ##   the first iteration where log.likelihood exceeds this
  ##   threshold.
  if (fraction < 0) {
    return(0)
  }
  stopifnot(fraction <= 1.0)
  stopifnot(is.numeric(log.likelihood), length(log.likelihood) > 0)
  FindFirst <- function (logical.sequence) {
    # Returns the position of the first TRUE in a sequence of
    # logicals.
    if (logical.sequence[1]) return(1)
    y <- rle(logical.sequence)
    return(y$lengths[1] + 1)
  }
  cutpoint <- round(fraction * length(log.likelihood))
  stopifnot(cutpoint >= 1)
  min.log.likelihood <- quantile(tail(log.likelihood, cutpoint), quantile)
  burn <- FindFirst(log.likelihood >= min.log.likelihood) - 1
  if (burn < 0) {
    burn <- 0
  }
  return(burn)
} }}
        uses: r-lib/actions/setup-r@f57f1301a053485946083d7a45022b278929a78a
        with: thin <- function (x, thin) {
  ## Thins the data in x, so that every thin'th observation is
  ## returned.  This is useful for making plots of large MCMC objects,
  ## where overplotting or memory constraints make plotting the whole
  ## object undesirable.
  ##
  ## Args:
  ##   x: A numeric vector, matrix, or array to be thinned.  If a
  ##     matrix or array then the first dimension corresponds to the
  ##     observation number, and will be used for thinning.
  ##   thin: The frequency with which to thin.  E.g. if thin == 10
  ##     then every 10th observation will be returned.
  ##
  ## Returns:
  ##    The thinned subset of x.
  stopifnot(is.numeric(thin) && length(thin) == 1)
  if (thin <= 1)
    return(x)
  if (is.array(x)) {
    nr <- dim(x)[1]
  } else if (is.numeric(x)) {
    nr <- length(x)
  } else stop("x must be a numeric type in thin()")

  top <- floor(nr/thin)
  indx <- (1:top) * thin

  if (is.matrix(x)) {
    return(x[indx, ])
  } else if (is.numeric(x)) {
    return(x[indx])
  } else if (is.array(x)) {
    stop("how do you drop the first N sub-components of an array?")
  }
}
          r-version: ${{ ThinMatrix <- function(mat, thin) {
  ## Returns every thin'th row of the matrix mat.  This is useful for reducing
  ## MCMC output to reasonable size.
  ##
  ## Args:
  ##   mat:  The matrix to be thinned.
  ##   thin: The distance between kept lines from mat.  The larger the number
  ##     the fewer lines are kept.  E.g. ThinMatrix(mat, 10) keeps every 10th
  ##     line.  If thin <= 1 then no thinning is done.
  ##
  ## Returns:
  ##   The matrix mat, after discarding all but every 'thin' lines.
  stopifnot(is.matrix(mat))
  stopifnot(is.numeric(thin),
            length(thin) == 1)
  if (thin <= 1) return(mat)
  if (nrow(mat) < thin) return(head(mat, 1))
  top <- floor(nrow(mat) / thin)
  indx <- (1:top) * thin
  return(mat[indx, , drop = FALSE])
} }}
      - name: Install dependencies
        run: |
          install.packages(c("remotes", "rcmdcheck"))
          remotes::install_deps(dependencies = TRUE)
        shell: Rscript {0}
      - name: Check
        run: rcmdcheck::rcmdcheck(args = "--no-manual", error_on = "error")
        shell: TimeSeriesBoxplot <- function(x, time, ylim = NULL, add = FALSE, ...) {
  ## Plots side by side boxplots against horizontal times series axis.
  ##
  ## Args:
  ##   x: A matrix, with rows representing a curve (or observations at a point
  ##     in time), and columns representing time points.
  ##   time: A vector of timestamps, with length equal to the number of columns
  ##     in x.  Timestamps can be numeric, Date, or POSIXt.
  ##   ylim:  Vertical axis limits.
  ##   add: Logical.  Should the boxplots be added to the current plot?
  ##   ...:  Extra arguments passed to 'plot' and 'boxplot'.
  stopifnot(inherits(time, "Date") ||
            inherits(time, "POSIXt") ||
            is.numeric(time),
            length(time) > 0,
            length(time) == ncol(x))
  if (is.null(ylim)) {
    ylim <- range(x)
  }
  if (!add) {
    plot(time, 1:length(time), type = "n", ylim = ylim, ...)
  }
  dt <- mean(diff(time))
  boxplot(x, add = TRUE, at = time, show.names = FALSE,
          boxwex = dt/2, ylim = ylim, ...)
}

# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs

name: Node.js CI

on: 'use strict';

const benchmark = require('benchmark');
const crypto = require('crypto');

const WebSocket = require('..');

const Receiver = WebSocket.Receiver;
const Sender = WebSocket.Sender;

const options = {
  fin: true,
  rsv1: false,
  mask: true,
  readOnly: false
};

function createBinaryFrame(length) {
  const list = Sender.frame(crypto.randomBytes(length), {
    opcode: 0x02,
    ...options
  });

  return Buffer.concat(list);
}

const pingFrame1 = Buffer.concat(
  Sender.frame(crypto.randomBytes(5), { opcode: 0x09, ...options })
);

const textFrame = Buffer.from('819461616161' + '61'.repeat(20), 'hex');
const pingFrame2 = Buffer.from('8980146e915a', 'hex');
const binaryFrame1 = createBinaryFrame(125);
const binaryFrame2 = createBinaryFrame(65535);
const binaryFrame3 = createBinaryFrame(200 * 1024);
const binaryFrame4 = createBinaryFrame(1024 * 1024);

const suite = new benchmark.Suite();
const receiver = new Receiver({
  binaryType: 'nodebuffer',
  extensions: {},
  isServer: true,
  skipUTF8Validation: false
});

suite.add('ping frame (5 bytes payload)', {
  defer: true,
  fn: (deferred) => {
    receiver.write(pingFrame1, deferred.resolve.bind(deferred));
  }
});
suite.add('ping frame (no payload)', {
  defer: true,
  fn: (deferred) => {
    receiver.write(pingFrame2, deferred.resolve.bind(deferred));
  }
});
suite.add('text frame (20 bytes payload)', {
  defer: true,
  fn: (deferred) => {
    receiver.write(textFrame, deferred.resolve.bind(deferred));
  }
});
suite.add('binary frame (125 bytes payload)', {
  defer: true,
  fn: (deferred) => {
    receiver.write(binaryFrame1, deferred.resolve.bind(deferred));
  }
});
suite.add('binary frame (65535 bytes payload)', {
  defer: true,
  fn: (deferred) => {
    receiver.write(binaryFrame2, deferred.resolve.bind(deferred));
  }
});
suite.add('binary frame (200 KiB payload)', {
  defer: true,
  fn: (deferred) => {
    receiver.write(binaryFrame3, deferred.resolve.bind(deferred));
  }
});
suite.add('binary frame (1 MiB payload)', {
  defer: true,
  fn: (deferred) => {
    receiver.write(binaryFrame4, deferred.resolve.bind(deferred));
  }
});

suite.on('cycle', (e) => console.log(e.target.toString()));

if (require.main === module) {
  suite.run({ async: true });
} else {
  module.exports = suite;
}
  push: 'use strict';

const benchmark = require('benchmark');
const crypto = require('crypto');

const Sender = require('../').Sender;

const data1 = crypto.randomBytes(64);
const data2 = crypto.randomBytes(16 * 1024);
const data3 = crypto.randomBytes(64 * 1024);
const data4 = crypto.randomBytes(200 * 1024);
const data5 = crypto.randomBytes(1024 * 1024);

const opts1 = {
  readOnly: false,
  mask: false,
  rsv1: false,
  opcode: 2,
  fin: true
};
const opts2 = {
  readOnly: true,
  rsv1: false,
  mask: true,
  opcode: 2,
  fin: true
};

const suite = new benchmark.Suite();

suite.add('frame, unmasked (64 B)', () => Sender.frame(data1, opts1));
suite.add('frame, masked (64 B)', () => Sender.frame(data1, opts2));
suite.add('frame, unmasked (16 KiB)', () => Sender.frame(data2, opts1));
suite.add('frame, masked (16 KiB)', () => Sender.frame(data2, opts2));
suite.add('frame, unmasked (64 KiB)', () => Sender.frame(data3, opts1));
suite.add('frame, masked (64 KiB)', () => Sender.frame(data3, opts2));
suite.add('frame, unmasked (200 KiB)', () => Sender.frame(data4, opts1));
suite.add('frame, masked (200 KiB)', () => Sender.frame(data4, opts2));
suite.add('frame, unmasked (1 MiB)', () => Sender.frame(data5, opts1));
suite.add('frame, masked (1 MiB)', () => Sender.frame(data5, opts2));

suite.on('cycle', (e) => console.log(e.target.toString()));

if (require.main === module) {
  suite.run({ async: true });
} else {
  module.exports = suite;
}
    branches: [ "main" ]
  pull_request: 'use strict';

const cluster = require('cluster');
const http = require('http');

const WebSocket = require('..');

const port = 8181;
const path = '';
// const path = '/tmp/wss.sock';

if (cluster.isMaster) {
  const server = http.createServer();
  const wss = new WebSocket.Server({
    maxPayload: 600 * 1024 * 1024,
    perMessageDeflate: false,
    clientTracking: false,
    server
  });

  wss.on('connection', (ws) => {
    ws.on('message', (data, isBinary) => {
      ws.send(data, { binary: isBinary });
    });
  });

  server.listen(path ? { path } : { port }, () => cluster.fork());

  cluster.on('exit', () => {
    wss.close();
    server.close();
  });
} else {
  const configs = [
    [true, 10000, 64],
    [true, 5000, 16 * 1024],
    [true, 1000, 128 * 1024],
    [true, 100, 1024 * 1024],
    [true, 1, 500 * 1024 * 1024],
    [false, 10000, 64],
    [false, 5000, 16 * 1024],
    [false, 1000, 128 * 1024],
    [false, 100, 1024 * 1024]
  ];

  const roundPrec = (num, prec) => {
    const mul = Math.pow(10, prec);
    return Math.round(num * mul) / mul;
  };

  const humanSize = (bytes) => {
    if (bytes >= 1073741824) return roundPrec(bytes / 1073741824, 2) + ' GiB';
    if (bytes >= 1048576) return roundPrec(bytes / 1048576, 2) + ' MiB';
    if (bytes >= 1024) return roundPrec(bytes / 1024, 2) + ' KiB';
    return roundPrec(bytes, 2) + ' B';
  };

  const largest = configs.reduce(
    (prev, curr) => (curr[2] > prev ? curr[2] : prev),
    0
  );
  console.log('Generating %s of test data...', humanSize(largest));
  const randomBytes = Buffer.allocUnsafe(largest);

  for (let i = 0; i < largest; ++i) {
    randomBytes[i] = ~~(Math.random() * 127);
  }

  console.log(`Testing ws on ${path || '[::]:' + port}`);

  const runConfig = (useBinary, roundtrips, size, cb) => {
    const data = randomBytes.slice(0, size);
    const url = path ? `ws+unix://${path}` : `ws://localhost:${port}`;
    const ws = new WebSocket(url, {
      maxPayload: 600 * 1024 * 1024
    });
    let roundtrip = 0;
    let time;

    ws.on('error', (err) => {
      console.error(err.stack);
      cluster.worker.disconnect();
    });
    ws.on('open', () => {
      time = process.hrtime();
      ws.send(data, { binary: useBinary });
    });
    ws.on('message', () => {
      if (++roundtrip !== roundtrips)
        return ws.send(data, { binary: useBinary });

      let elapsed = process.hrtime(time);
      elapsed = elapsed[0] * 1e9 + elapsed[1];

      console.log(
        '%d roundtrips of %s %s data:\t%ss\t%s',
        roundtrips,
        humanSize(size),
        useBinary ? 'binary' : 'text',
        roundPrec(elapsed / 1e9, 1),
        humanSize(((size * 2 * roundtrips) / elapsed) * 1e9) + '/s'
      );

      ws.close();
      cb();
    });
  };

  (function run() {
    if (configs.length === 0) return cluster.worker.disconnect();
    const config = configs.shift();
    config.push(run);
    runConfig.apply(null, config);
  })();
}
    branches: [ "main" ]

jobs:
  build:

    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [14.x, 16.x, 18.x]
        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/

    steps:
    - uses: actions/checkout@v4
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    - run: npm ci
    - run: npm run build --if-present
    - run: npm test

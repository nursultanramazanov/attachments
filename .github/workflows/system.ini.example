# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
#
# Find more information at:
# https://github.com/microsoft/msvc-code-analysis-action

name: Microsoft C++ Code Analysis

on: 
#ifndef INIREADER_H
#define INIREADER_H

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <map> 
#include "SystemConfiguration.h"

using namespace std;

#define DEFINE_UINT_PARAM(name, paramtype) {#name, &name, UINT, paramtype, false}
#define DEFINE_STRING_PARAM(name, paramtype) {#name, &name, STRING, paramtype, false}
#define DEFINE_FLOAT_PARAM(name,paramtype) {#name, &name, FLOAT, paramtype, false}
#define DEFINE_BOOL_PARAM(name, paramtype) {#name, &name, BOOL, paramtype, false}
#define DEFINE_UINT64_PARAM(name, paramtype) {#name, &name, UINT64, paramtype, false}

namespace DRAMSim
{

typedef enum _variableType {STRING, UINT, UINT64, FLOAT, BOOL} varType;
typedef enum _paramType {SYS_PARAM, DEV_PARAM} paramType;
typedef struct _configMap
{
        string iniKey; //for example "tRCD"

        void *variablePtr;
        varType variableType;
        paramType parameterType;
        bool wasSet;
} ConfigMap;

class IniReader
{

public:
        typedef std::map<string, string> OverrideMap;
        typedef OverrideMap::const_iterator OverrideIterator; 

        static void SetKey(string key, string value, bool isSystemParam = false, size_t lineNumber = 0);
        static void OverrideKeys(const OverrideMap *map);
        static void ReadIniFile(string filename, bool isSystemParam);
        static void InitEnumsFromStrings();
        static bool CheckIfAllSet();
        static void WriteValuesOut(std::ofstream &visDataOut);
        static int getBool(const std::string &field, bool *val);
        static int getUint(const std::string &field, unsigned int *val);
        static int getUint64(const std::string &field, uint64_t *val);
        static int getFloat(const std::string &field, float *val);

private:
        static void WriteParams(std::ofstream &visDataOut, paramType t);
        static void Trim(string &str);
};
}


#endif
  push: CXXFLAGS=-DNO_STORAGE -Wall -DDEBUG_BUILD 
OPTFLAGS=-O3 


ifdef DEBUG
ifeq ($(DEBUG), 1)
OPTFLAGS= -O0 -g
endif
endif
CXXFLAGS+=$(OPTFLAGS)

EXE_NAME=DRAMSim
STATIC_LIB_NAME := libdramsim.a
LIB_NAME=libdramsim.so
LIB_NAME_MACOS=libdramsim.dylib

SRC = $(wildcard *.cpp)
OBJ = $(addsuffix .o, $(basename $(SRC)))

LIB_SRC := $(filter-out TraceBasedSim.cpp,$(SRC))
LIB_OBJ := $(addsuffix .o, $(basename $(LIB_SRC)))

#build portable objects (i.e. with -fPIC)
POBJ = $(addsuffix .po, $(basename $(LIB_SRC)))

REBUILDABLES=$(OBJ) ${POBJ} $(EXE_NAME) $(LIB_NAME) $(STATIC_LIB_NAME)

all: ${EXE_NAME}

#   $@ target name, $^ target deps, $< matched pattern
$(EXE_NAME): $(OBJ)
        $(CXX) $(CXXFLAGS) -o $@ $^ 
        @echo "Built $@ successfully" 

$(LIB_NAME): $(POBJ)
        g++ -g -shared -Wl,-soname,$@ -o $@ $^
        @echo "Built $@ successfully"

$(STATIC_LIB_NAME): $(LIB_OBJ)
        $(AR) crs $@ $^

$(LIB_NAME_MACOS): $(POBJ)
        g++ -dynamiclib -o $@ $^
        @echo "Built $@ successfully"

#include the autogenerated dependency files for each .o file
-include $(OBJ:.o=.dep)
-include $(POBJ:.po=.deppo)

# build dependency list via gcc -M and save to a .dep file
%.dep : %.cpp
        @$(CXX) -M $(CXXFLAGS) $< > $@

%.deppo : %.cpp
        @$(CXX) -M $(CXXFLAGS) -MT"$*.po" $< > $@

# build all .cpp files to .o files
%.o : %.cpp
        g++ $(CXXFLAGS) -o $@ -c $<

#po = portable object .. for lack of a better term
%.po : %.cpp
        g++ $(CXXFLAGS) -DLOG_OUTPUT -fPIC -o $@ -c $<

clean: 
        -rm -f $(REBUILDABLES) *.dep *.deppo
    branches: [ "main" ]
  pull_request: 


//MemoryController.cpp
//
//Class file for memory controller object
//

#include "MemoryController.h"
#include "MemorySystem.h"
#include "AddressMapping.h"

#define SEQUENTIAL(rank,bank) (rank*NUM_BANKS)+bank

/* Power computations are localized to MemoryController.cpp */ 
extern unsigned IDD0;
extern unsigned IDD1;
extern unsigned IDD2P;
extern unsigned IDD2Q;
extern unsigned IDD2N;
extern unsigned IDD3Pf;
extern unsigned IDD3Ps;
extern unsigned IDD3N;
extern unsigned IDD4W;
extern unsigned IDD4R;
extern unsigned IDD5;
extern unsigned IDD6;
extern unsigned IDD6L;
extern unsigned IDD7;
extern float Vdd; 

using namespace DRAMSim;

MemoryController::MemoryController(MemorySystem *parent, CSVWriter &csvOut_, ostream &dramsim_log_) :
                dramsim_log(dramsim_log_),
                bankStates(NUM_RANKS, vector<BankState>(NUM_BANKS, dramsim_log)),
                commandQueue(bankStates, dramsim_log_),
                poppedBusPacket(NULL),
                csvOut(csvOut_),
                totalTransactions(0),
                refreshRank(0)
{
        //get handle on parent
        parentMemorySystem = parent;


        //bus related fields
        outgoingCmdPacket = NULL;
        outgoingDataPacket = NULL;
        dataCyclesLeft = 0;
        cmdCyclesLeft = 0;

        //set here to avoid compile errors
        currentClockCycle = 0;

        //reserve memory for vectors
        transactionQueue.reserve(TRANS_QUEUE_DEPTH);
        powerDown = vector<bool>(NUM_RANKS,false);
        grandTotalBankAccesses = vector<uint64_t>(NUM_RANKS*NUM_BANKS,0);
        totalReadsPerBank = vector<uint64_t>(NUM_RANKS*NUM_BANKS,0);
        totalWritesPerBank = vector<uint64_t>(NUM_RANKS*NUM_BANKS,0);
        totalReadsPerRank = vector<uint64_t>(NUM_RANKS,0);
        totalWritesPerRank = vector<uint64_t>(NUM_RANKS,0);

        writeDataCountdown.reserve(NUM_RANKS);
        writeDataToSend.reserve(NUM_RANKS);
        refreshCountdown.reserve(NUM_RANKS);

        //Power related packets
        backgroundEnergy = vector <uint64_t >(NUM_RANKS,0);
        burstEnergy = vector <uint64_t> (NUM_RANKS,0);
        actpreEnergy = vector <uint64_t> (NUM_RANKS,0);
        refreshEnergy = vector <uint64_t> (NUM_RANKS,0);

        totalEpochLatency = vector<uint64_t> (NUM_RANKS*NUM_BANKS,0);

        //staggers when each rank is due for a refresh
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                refreshCountdown.push_back((int)((REFRESH_PERIOD/tCK)/NUM_RANKS)*(i+1));
        }
}

//get a bus packet from either data or cmd bus
void MemoryController::receiveFromBus(BusPacket *bpacket)
{
        if (bpacket->busPacketType != DATA)
        {
                ERROR("== Error - Memory Controller received a non-DATA bus packet from rank");
                bpacket->print();
                exit(0);
        }

        if (DEBUG_BUS)
        {
                PRINTN(" -- MC Receiving From Data Bus : ");
                bpacket->print();
        }

        //add to return read data queue
        returnTransaction.push_back(new Transaction(RETURN_DATA, bpacket->physicalAddress, bpacket->data));
        totalReadsPerBank[SEQUENTIAL(bpacket->rank,bpacket->bank)]++;

        // this delete statement saves a mindboggling amount of memory
        delete(bpacket);
}

//sends read data back to the CPU
void MemoryController::returnReadData(const Transaction *trans)
{
        if (parentMemorySystem->ReturnReadData!=NULL)
        {
                (*parentMemorySystem->ReturnReadData)(parentMemorySystem->systemID, trans->address, currentClockCycle);
        }
}

//gives the memory controller a handle on the rank objects
void MemoryController::attachRanks(vector<Rank *> *ranks)
{
        this->ranks = ranks;
}

//memory controller update
void MemoryController::update()
{

        //PRINT(" ------------------------- [" << currentClockCycle << "] -------------------------");

        //update bank states
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                for (size_t j=0;j<NUM_BANKS;j++)
                {
                        if (bankStates[i][j].stateChangeCountdown>0)
                        {
                                //decrement counters
                                bankStates[i][j].stateChangeCountdown--;

                                //if counter has reached 0, change state
                                if (bankStates[i][j].stateChangeCountdown == 0)
                                {
                                        switch (bankStates[i][j].lastCommand)
                                        {
                                                //only these commands have an implicit state change
                                        case WRITE_P:
                                        case READ_P:
                                                bankStates[i][j].currentBankState = Precharging;
                                                bankStates[i][j].lastCommand = PRECHARGE;
                                                bankStates[i][j].stateChangeCountdown = tRP;
                                                break;

                                        case REFRESH:
                                        case PRECHARGE:
                                                bankStates[i][j].currentBankState = Idle;
                                                break;
                                        default:
                                                break;
                                        }
                                }
                        }
                }
        }


        //check for outgoing command packets and handle countdowns
        if (outgoingCmdPacket != NULL)
        {
                cmdCyclesLeft--;
                if (cmdCyclesLeft == 0) //packet is ready to be received by rank
                {
                        (*ranks)[outgoingCmdPacket->rank]->receiveFromBus(outgoingCmdPacket);
                        outgoingCmdPacket = NULL;
                }
        }

        //check for outgoing data packets and handle countdowns
        if (outgoingDataPacket != NULL)
        {
                dataCyclesLeft--;
                if (dataCyclesLeft == 0)
                {
                        //inform upper levels that a write is done
                        if (parentMemorySystem->WriteDataDone!=NULL)
                        {
                                (*parentMemorySystem->WriteDataDone)(parentMemorySystem->systemID,outgoingDataPacket->physicalAddress, currentClockCycle);
                        }

                        (*ranks)[outgoingDataPacket->rank]->receiveFromBus(outgoingDataPacket);
                        outgoingDataPacket=NULL;
                }
        }


        //if any outstanding write data needs to be sent
        //and the appropriate amount of time has passed (WL)
        //then send data on bus
        //
        //write data held in fifo vector along with countdowns
        if (writeDataCountdown.size() > 0)
        {
                for (size_t i=0;i<writeDataCountdown.size();i++)
                {
                        writeDataCountdown[i]--;
                }

                if (writeDataCountdown[0]==0)
                {
                        //send to bus and print debug stuff
                        if (DEBUG_BUS)
                        {
                                PRINTN(" -- MC Issuing On Data Bus    : ");
                                writeDataToSend[0]->print();
                        }

                        // queue up the packet to be sent
                        if (outgoingDataPacket != NULL)
                        {
                                ERROR("== Error - Data Bus Collision");
                                exit(-1);
                        }

                        outgoingDataPacket = writeDataToSend[0];
                        dataCyclesLeft = BL/2;

                        totalTransactions++;
                        totalWritesPerBank[SEQUENTIAL(writeDataToSend[0]->rank,writeDataToSend[0]->bank)]++;

                        writeDataCountdown.erase(writeDataCountdown.begin());
                        writeDataToSend.erase(writeDataToSend.begin());
                }
        }

        //if its time for a refresh issue a refresh
        // else pop from command queue if it's not empty
        if (refreshCountdown[refreshRank]==0)
        {
                commandQueue.needRefresh(refreshRank);
                (*ranks)[refreshRank]->refreshWaiting = true;
                refreshCountdown[refreshRank] =         REFRESH_PERIOD/tCK;
                refreshRank++;
                if (refreshRank == NUM_RANKS)
                {
                        refreshRank = 0;
                }
        }
        //if a rank is powered down, make sure we power it up in time for a refresh
        else if (powerDown[refreshRank] && refreshCountdown[refreshRank] <= tXP)
        {
                (*ranks)[refreshRank]->refreshWaiting = true;
        }

        //pass a pointer to a poppedBusPacket

        //function returns true if there is something valid in poppedBusPacket
        if (commandQueue.pop(&poppedBusPacket))
        {
                if (poppedBusPacket->busPacketType == WRITE || poppedBusPacket->busPacketType == WRITE_P)
                {

                        writeDataToSend.push_back(new BusPacket(DATA, poppedBusPacket->physicalAddress, poppedBusPacket->column,
                                                            poppedBusPacket->row, poppedBusPacket->rank, poppedBusPacket->bank,
                                                            poppedBusPacket->data, dramsim_log));
                        writeDataCountdown.push_back(WL);
                }

                //
                //update each bank's state based on the command that was just popped out of the command queue
                //
                //for readability's sake
                unsigned rank = poppedBusPacket->rank;
                unsigned bank = poppedBusPacket->bank;
                switch (poppedBusPacket->busPacketType)
                {
                        case READ_P:
                        case READ:
                                //add energy to account for total
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding Read energy to total energy");
                                }
                                burstEnergy[rank] += (IDD4R - IDD3N) * BL/2 * NUM_DEVICES;
                                if (poppedBusPacket->busPacketType == READ_P) 
                                {
                                        //Don't bother setting next read or write times because the bank is no longer active
                                        //bankStates[rank][bank].currentBankState = Idle;
                                        bankStates[rank][bank].nextActivate = max(currentClockCycle + READ_AUTOPRE_DELAY,
                                                        bankStates[rank][bank].nextActivate);
                                        bankStates[rank][bank].lastCommand = READ_P;
                                        bankStates[rank][bank].stateChangeCountdown = READ_TO_PRE_DELAY;
                                }
                                else if (poppedBusPacket->busPacketType == READ)
                                {
                                        bankStates[rank][bank].nextPrecharge = max(currentClockCycle + READ_TO_PRE_DELAY,
                                                        bankStates[rank][bank].nextPrecharge);
                                        bankStates[rank][bank].lastCommand = READ;

                                }

                                for (size_t i=0;i<NUM_RANKS;i++)
                                {
                                        for (size_t j=0;j<NUM_BANKS;j++)
                                        {
                                                if (i!=poppedBusPacket->rank)
                                                {
                                                        //check to make sure it is active before trying to set (save's time?)
                                                        if (bankStates[i][j].currentBankState == RowActive)
                                                        {
                                                                bankStates[i][j].nextRead = max(currentClockCycle + BL/2 + tRTRS, bankStates[i][j].nextRead);
                                                                bankStates[i][j].nextWrite = max(currentClockCycle + READ_TO_WRITE_DELAY,
                                                                                bankStates[i][j].nextWrite);
                                                        }
                                                }
                                                else
                                                {
                                                        bankStates[i][j].nextRead = max(currentClockCycle + max(tCCD, BL/2), bankStates[i][j].nextRead);
                                                        bankStates[i][j].nextWrite = max(currentClockCycle + READ_TO_WRITE_DELAY,
                                                                        bankStates[i][j].nextWrite);
                                                }
                                        }
                                }

                                if (poppedBusPacket->busPacketType == READ_P)
                                {
                                        //set read and write to nextActivate so the state table will prevent a read or write
                                        //  being issued (in cq.isIssuable())before the bank state has been changed because of the
                                        //  auto-precharge associated with this command
                                        bankStates[rank][bank].nextRead = bankStates[rank][bank].nextActivate;
                                        bankStates[rank][bank].nextWrite = bankStates[rank][bank].nextActivate;
                                }

                                break;
                        case WRITE_P:
                        case WRITE:
                                if (poppedBusPacket->busPacketType == WRITE_P) 
                                {
                                        bankStates[rank][bank].nextActivate = max(currentClockCycle + WRITE_AUTOPRE_DELAY,
                                                        bankStates[rank][bank].nextActivate);
                                        bankStates[rank][bank].lastCommand = WRITE_P;
                                        bankStates[rank][bank].stateChangeCountdown = WRITE_TO_PRE_DELAY;
                                }
                                else if (poppedBusPacket->busPacketType == WRITE)
                                {
                                        bankStates[rank][bank].nextPrecharge = max(currentClockCycle + WRITE_TO_PRE_DELAY,
                                                        bankStates[rank][bank].nextPrecharge);
                                        bankStates[rank][bank].lastCommand = WRITE;
                                }


                                //add energy to account for total
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding Write energy to total energy");
                                }
                                burstEnergy[rank] += (IDD4W - IDD3N) * BL/2 * NUM_DEVICES;

                                for (size_t i=0;i<NUM_RANKS;i++)
                                {
                                        for (size_t j=0;j<NUM_BANKS;j++)
                                        {
                                                if (i!=poppedBusPacket->rank)
                                                {
                                                        if (bankStates[i][j].currentBankState == RowActive)
                                                        {
                                                                bankStates[i][j].nextWrite = max(currentClockCycle + BL/2 + tRTRS, bankStates[i][j].nextWrite);
                                                                bankStates[i][j].nextRead = max(currentClockCycle + WRITE_TO_READ_DELAY_R,
                                                                                bankStates[i][j].nextRead);
                                                        }
                                                }
                                                else
                                                {
                                                        bankStates[i][j].nextWrite = max(currentClockCycle + max(BL/2, tCCD), bankStates[i][j].nextWrite);
                                                        bankStates[i][j].nextRead = max(currentClockCycle + WRITE_TO_READ_DELAY_B,
                                                                        bankStates[i][j].nextRead);
                                                }
                                        }
                                }

                                //set read and write to nextActivate so the state table will prevent a read or write
                                //  being issued (in cq.isIssuable())before the bank state has been changed because of the
                                //  auto-precharge associated with this command
                                if (poppedBusPacket->busPacketType == WRITE_P)
                                {
                                        bankStates[rank][bank].nextRead = bankStates[rank][bank].nextActivate;
                                        bankStates[rank][bank].nextWrite = bankStates[rank][bank].nextActivate;
                                }

                                break;
                        case ACTIVATE:
                                //add energy to account for total
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding Activate and Precharge energy to total energy");
                                }
                                actpreEnergy[rank] += ((IDD0 * tRC) - ((IDD3N * tRAS) + (IDD2N * (tRC - tRAS)))) * NUM_DEVICES;

                                bankStates[rank][bank].currentBankState = RowActive;
                                bankStates[rank][bank].lastCommand = ACTIVATE;
                                bankStates[rank][bank].openRowAddress = poppedBusPacket->row;
                                bankStates[rank][bank].nextActivate = max(currentClockCycle + tRC, bankStates[rank][bank].nextActivate);
                                bankStates[rank][bank].nextPrecharge = max(currentClockCycle + tRAS, bankStates[rank][bank].nextPrecharge);

                                //if we are using posted-CAS, the next column access can be sooner than normal operation

                                bankStates[rank][bank].nextRead = max(currentClockCycle + (tRCD-AL), bankStates[rank][bank].nextRead);
                                bankStates[rank][bank].nextWrite = max(currentClockCycle + (tRCD-AL), bankStates[rank][bank].nextWrite);

                                for (size_t i=0;i<NUM_BANKS;i++)
                                {
                                        if (i!=poppedBusPacket->bank)
                                        {
                                                bankStates[rank][i].nextActivate = max(currentClockCycle + tRRD, bankStates[rank][i].nextActivate);
                                        }
                                }

                                break;
                        case PRECHARGE:
                                bankStates[rank][bank].currentBankState = Precharging;
                                bankStates[rank][bank].lastCommand = PRECHARGE;
                                bankStates[rank][bank].stateChangeCountdown = tRP;
                                bankStates[rank][bank].nextActivate = max(currentClockCycle + tRP, bankStates[rank][bank].nextActivate);

                                break;
                        case REFRESH:
                                //add energy to account for total
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding Refresh energy to total energy");
                                }
                                refreshEnergy[rank] += (IDD5 - IDD3N) * tRFC * NUM_DEVICES;

                                for (size_t i=0;i<NUM_BANKS;i++)
                                {
                                        bankStates[rank][i].nextActivate = currentClockCycle + tRFC;
                                        bankStates[rank][i].currentBankState = Refreshing;
                                        bankStates[rank][i].lastCommand = REFRESH;
                                        bankStates[rank][i].stateChangeCountdown = tRFC;
                                }

                                break;
                        default:
                                ERROR("== Error - Popped a command we shouldn't have of type : " << poppedBusPacket->busPacketType);
                                exit(0);
                }

                //issue on bus and print debug
                if (DEBUG_BUS)
                {
                        PRINTN(" -- MC Issuing On Command Bus : ");
                        poppedBusPacket->print();
                }

                //check for collision on bus
                if (outgoingCmdPacket != NULL)
                {
                        ERROR("== Error - Command Bus Collision");
                        exit(-1);
                }
                outgoingCmdPacket = poppedBusPacket;
                cmdCyclesLeft = tCMD;

        }

        for (size_t i=0;i<transactionQueue.size();i++)
        {
                //pop off top transaction from queue
                //
                //        assuming simple scheduling at the moment
                //        will eventually add policies here
                Transaction *transaction = transactionQueue[i];

                //map address to rank,bank,row,col
                unsigned newTransactionChan, newTransactionRank, newTransactionBank, newTransactionRow, newTransactionColumn;

                // pass these in as references so they get set by the addressMapping function
                addressMapping(transaction->address, newTransactionChan, newTransactionRank, newTransactionBank, newTransactionRow, newTransactionColumn);

                //if we have room, break up the transaction into the appropriate commands
                //and add them to the command queue
                if (commandQueue.hasRoomFor(2, newTransactionRank, newTransactionBank))
                {
                        if (DEBUG_ADDR_MAP) 
                        {
                                PRINTN("== New Transaction - Mapping Address [0x" << hex << transaction->address << dec << "]");
                                if (transaction->transactionType == DATA_READ) 
                                {
                                        PRINT(" (Read)");
                                }
                                else
                                {
                                        PRINT(" (Write)");
                                }
                                PRINT("  Rank : " << newTransactionRank);
                                PRINT("  Bank : " << newTransactionBank);
                                PRINT("  Row  : " << newTransactionRow);
                                PRINT("  Col  : " << newTransactionColumn);
                        }



                        //now that we know there is room in the command queue, we can remove from the transaction queue
                        transactionQueue.erase(transactionQueue.begin()+i);

                        //create activate command to the row we just translated
                        BusPacket *ACTcommand = new BusPacket(ACTIVATE, transaction->address,
                                        newTransactionColumn, newTransactionRow, newTransactionRank,
                                        newTransactionBank, 0, dramsim_log);

                        //create read or write command and enqueue it
                        BusPacketType bpType = transaction->getBusPacketType();
                        BusPacket *command = new BusPacket(bpType, transaction->address,
                                        newTransactionColumn, newTransactionRow, newTransactionRank,
                                        newTransactionBank, transaction->data, dramsim_log);



                        commandQueue.enqueue(ACTcommand);
                        commandQueue.enqueue(command);

                        // If we have a read, save the transaction so when the data comes back
                        // in a bus packet, we can staple it back into a transaction and return it
                        if (transaction->transactionType == DATA_READ)
                        {
                                pendingReadTransactions.push_back(transaction);
                        }
                        else
                        {
                                // just delete the transaction now that it's a buspacket
                                delete transaction; 
                        }
                        /* only allow one transaction to be scheduled per cycle -- this should
                         * be a reasonable assumption considering how much logic would be
                         * required to schedule multiple entries per cycle (parallel data
                         * lines, switching logic, decision logic)
                         */
                        break;
                }
                else // no room, do nothing this cycle
                {
                        //PRINT( "== Warning - No room in command queue" << endl;
                }
        }


        //calculate power
        //  this is done on a per-rank basis, since power characterization is done per device (not per bank)
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                if (USE_LOW_POWER)
                {
                        //if there are no commands in the queue and that particular rank is not waiting for a refresh...
                        if (commandQueue.isEmpty(i) && !(*ranks)[i]->refreshWaiting)
                        {
                                //check to make sure all banks are idle
                                bool allIdle = true;
                                for (size_t j=0;j<NUM_BANKS;j++)
                                {
                                        if (bankStates[i][j].currentBankState != Idle)
                                        {
                                                allIdle = false;
                                                break;
                                        }
                                }

                                //if they ARE all idle, put in power down mode and set appropriate fields
                                if (allIdle)
                                {
                                        powerDown[i] = true;
                                        (*ranks)[i]->powerDown();
                                        for (size_t j=0;j<NUM_BANKS;j++)
                                        {
                                                bankStates[i][j].currentBankState = PowerDown;
                                                bankStates[i][j].nextPowerUp = currentClockCycle + tCKE;
                                        }
                                }
                        }
                        //if there IS something in the queue or there IS a refresh waiting (and we can power up), do it
                        else if (currentClockCycle >= bankStates[i][0].nextPowerUp && powerDown[i]) //use 0 since theyre all the same
                        {
                                powerDown[i] = false;
                                (*ranks)[i]->powerUp();
                                for (size_t j=0;j<NUM_BANKS;j++)
                                {
                                        bankStates[i][j].currentBankState = Idle;
                                        bankStates[i][j].nextActivate = currentClockCycle + tXP;
                                }
                        }
                }

                //check for open bank
                bool bankOpen = false;
                for (size_t j=0;j<NUM_BANKS;j++)
                {
                        if (bankStates[i][j].currentBankState == Refreshing ||
                                bankStates[i][j].currentBankState == RowActive)
                        {
                                bankOpen = true;
                                break;
                        }
                }

                //background power is dependent on whether or not a bank is open or not
                if (bankOpen)
                {
                        if (DEBUG_POWER)
                        {
                                PRINT(" ++ Adding IDD3N to total energy [from rank "<< i <<"]");
                        }
                        backgroundEnergy[i] += IDD3N * NUM_DEVICES;
                }
                else
                {
                        //if we're in power-down mode, use the correct current
                        if (powerDown[i])
                        {
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding IDD2P to total energy [from rank " << i << "]");
                                }
                                backgroundEnergy[i] += IDD2P * NUM_DEVICES;
                        }
                        else
                        {
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding IDD2N to total energy [from rank " << i << "]");
                                }
                                backgroundEnergy[i] += IDD2N * NUM_DEVICES;
                        }
                }
        }

        //check for outstanding data to return to the CPU
        if (returnTransaction.size()>0)
        {
                if (DEBUG_BUS)
                {
                        PRINTN(" -- MC Issuing to CPU bus : " << *returnTransaction[0]);
                }
                totalTransactions++;

                bool foundMatch=false;
                //find the pending read transaction to calculate latency
                for (size_t i=0;i<pendingReadTransactions.size();i++)
                {
                        if (pendingReadTransactions[i]->address == returnTransaction[0]->address)
                        {
                                //if(currentClockCycle - pendingReadTransactions[i]->timeAdded > 2000)
                                //        {
                                //                pendingReadTransactions[i]->print();
                                //                exit(0);
                                //        }
                                unsigned chan,rank,bank,row,col;
                                addressMapping(returnTransaction[0]->address,chan,rank,bank,row,col);
                                insertHistogram(currentClockCycle-pendingReadTransactions[i]->timeAdded,rank,bank);
                                //return latency
                                returnReadData(pendingReadTransactions[i]);

                                delete pendingReadTransactions[i];
                                pendingReadTransactions.erase(pendingReadTransactions.begin()+i);
                                foundMatch=true; 
                                break;
                        }
                }
                if (!foundMatch)
                {
                        ERROR("Can't find a matching transaction for 0x"<<hex<<returnTransaction[0]->address<<dec);
                        abort(); 
                }
                delete returnTransaction[0];
                returnTransaction.erase(returnTransaction.begin());
        }

        //decrement refresh counters
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                refreshCountdown[i]--;
        }

        //
        //print debug
        //
        if (DEBUG_TRANS_Q)
        {
                PRINT("== Printing transaction queue");
                for (size_t i=0;i<transactionQueue.size();i++)
                {
                        PRINTN("  " << i << "] "<< *transactionQueue[i]);
                }
        }

        if (DEBUG_BANKSTATE)
        {
                //TODO: move this to BankState.cpp
                PRINT("== Printing bank states (According to MC)");
                for (size_t i=0;i<NUM_RANKS;i++)
                {
                        for (size_t j=0;j<NUM_BANKS;j++)
                        {
                                if (bankStates[i][j].currentBankState == RowActive)
                                {
                                        PRINTN("[" << bankStates[i][j].openRowAddress << "] ");
                                }
                                else if (bankStates[i][j].currentBankState == Idle)
                                {
                                        PRINTN("[idle] ");
                                }
                                else if (bankStates[i][j].currentBankState == Precharging)
                                {
                                        PRINTN("[pre] ");
                                }
                                else if (bankStates[i][j].currentBankState == Refreshing)
                                {
                                        PRINTN("[ref] ");
                                }
                                else if (bankStates[i][j].currentBankState == PowerDown)
                                {
                                        PRINTN("[lowp] ");
                                }
                        }
                        PRINT(""); // effectively just cout<<endl;
                }
        }

        if (DEBUG_CMD_Q)
        {
                commandQueue.print();
        }

        commandQueue.step();

}

bool MemoryController::WillAcceptTransaction()
{
        return transactionQueue.size() < TRANS_QUEUE_DEPTH;
}

//allows outside source to make request of memory system
bool MemoryController::addTransaction(Transaction *trans)
{
        if (WillAcceptTransaction())
        {
                trans->timeAdded = currentClockCycle;
                transactionQueue.push_back(trans);
                return true;
        }
        else 
        {
                return false;
        }
}

void MemoryController::resetStats()
{
        for (size_t i=0; i<NUM_RANKS; i++)
        {
                for (size_t j=0; j<NUM_BANKS; j++)
                {
                        //XXX: this means the bank list won't be printed for partial epochs
                        grandTotalBankAccesses[SEQUENTIAL(i,j)] += totalReadsPerBank[SEQUENTIAL(i,j)] + totalWritesPerBank[SEQUENTIAL(i,j)];
                        totalReadsPerBank[SEQUENTIAL(i,j)] = 0;
                        totalWritesPerBank[SEQUENTIAL(i,j)] = 0;
                        totalEpochLatency[SEQUENTIAL(i,j)] = 0;
                }

                burstEnergy[i] = 0;
                actpreEnergy[i] = 0;
                refreshEnergy[i] = 0;
                backgroundEnergy[i] = 0;
                totalReadsPerRank[i] = 0;
                totalWritesPerRank[i] = 0;
        }
}
//prints statistics at the end of an epoch or  simulation
void MemoryController::printStats(bool finalStats)
{
        unsigned myChannel = parentMemorySystem->systemID;

        //if we are not at the end of the epoch, make sure to adjust for the actual number of cycles elapsed

        uint64_t cyclesElapsed = (currentClockCycle % EPOCH_LENGTH == 0) ? EPOCH_LENGTH : currentClockCycle % EPOCH_LENGTH;
        unsigned bytesPerTransaction = (JEDEC_DATA_BUS_BITS*BL)/8;
        uint64_t totalBytesTransferred = totalTransactions * bytesPerTransaction;
        double secondsThisEpoch = (double)cyclesElapsed * tCK * 1E-9;

        // only per rank
        vector<double> backgroundPower = vector<double>(NUM_RANKS,0.0);
        vector<double> burstPower = vector<double>(NUM_RANKS,0.0);
        vector<double> refreshPower = vector<double>(NUM_RANKS,0.0);
        vector<double> actprePower = vector<double>(NUM_RANKS,0.0);
        vector<double> averagePower = vector<double>(NUM_RANKS,0.0);

        // per bank variables
        vector<double> averageLatency = vector<double>(NUM_RANKS*NUM_BANKS,0.0);
        vector<double> bandwidth = vector<double>(NUM_RANKS*NUM_BANKS,0.0);

        double totalBandwidth=0.0;
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                for (size_t j=0; j<NUM_BANKS; j++)
                {
                        bandwidth[SEQUENTIAL(i,j)] = (((double)(totalReadsPerBank[SEQUENTIAL(i,j)]+totalWritesPerBank[SEQUENTIAL(i,j)]) * (double)bytesPerTransaction)/(1024.0*1024.0*1024.0)) / secondsThisEpoch;
                        averageLatency[SEQUENTIAL(i,j)] = ((float)totalEpochLatency[SEQUENTIAL(i,j)] / (float)(totalReadsPerBank[SEQUENTIAL(i,j)])) * tCK;
                        totalBandwidth+=bandwidth[SEQUENTIAL(i,j)];
                        totalReadsPerRank[i] += totalReadsPerBank[SEQUENTIAL(i,j)];
                        totalWritesPerRank[i] += totalWritesPerBank[SEQUENTIAL(i,j)];
                }
        }
#ifdef LOG_OUTPUT
        dramsim_log.precision(3);
        dramsim_log.setf(ios::fixed,ios::floatfield);
#else
        cout.precision(3);
        cout.setf(ios::fixed,ios::floatfield);
#endif

        PRINT( " =======================================================" );
        PRINT( " ============== Printing Statistics [id:"<<parentMemorySystem->systemID<<"]==============" );
        PRINTN( "   Total Return Transactions : " << totalTransactions );
        PRINT( " ("<<totalBytesTransferred <<" bytes) aggregate average bandwidth "<<totalBandwidth<<"GB/s");

        double totalAggregateBandwidth = 0.0;        
        for (size_t r=0;r<NUM_RANKS;r++)
        {

                PRINT( "      -Rank   "<<r<<" : ");
                PRINTN( "        -Reads  : " << totalReadsPerRank[r]);
                PRINT( " ("<<totalReadsPerRank[r] * bytesPerTransaction<<" bytes)");
                PRINTN( "        -Writes : " << totalWritesPerRank[r]);
                PRINT( " ("<<totalWritesPerRank[r] * bytesPerTransaction<<" bytes)");
                for (size_t j=0;j<NUM_BANKS;j++)
                {
                        PRINT( "        -Bandwidth / Latency  (Bank " <<j<<"): " <<bandwidth[SEQUENTIAL(r,j)] << " GB/s\t\t" <<averageLatency[SEQUENTIAL(r,j)] << " ns");
                }

                // factor of 1000 at the end is to account for the fact that totalEnergy is accumulated in mJ since IDD values are given in mA
                backgroundPower[r] = ((double)backgroundEnergy[r] / (double)(cyclesElapsed)) * Vdd / 1000.0;
                burstPower[r] = ((double)burstEnergy[r] / (double)(cyclesElapsed)) * Vdd / 1000.0;
                refreshPower[r] = ((double) refreshEnergy[r] / (double)(cyclesElapsed)) * Vdd / 1000.0;
                actprePower[r] = ((double)actpreEnergy[r] / (double)(cyclesElapsed)) * Vdd / 1000.0;
                averagePower[r] = ((backgroundEnergy[r] + burstEnergy[r] + refreshEnergy[r] + actpreEnergy[r]) / (double)cyclesElapsed) * Vdd / 1000.0;

                if ((*parentMemorySystem->ReportPower)!=NULL)
                {
                        (*parentMemorySystem->ReportPower)(backgroundPower[r],burstPower[r],refreshPower[r],actprePower[r]);
                }

                PRINT( " == Power Data for Rank        " << r );
                PRINT( "   Average Power (watts)     : " << averagePower[r] );
                PRINT( "     -Background (watts)     : " << backgroundPower[r] );
                PRINT( "     -Act/Pre    (watts)     : " << actprePower[r] );
                PRINT( "     -Burst      (watts)     : " << burstPower[r]);
                PRINT( "     -Refresh    (watts)     : " << refreshPower[r] );

                if (VIS_FILE_OUTPUT)
                {
                //        cout << "c="<<myChannel<< " r="<<r<<"writing to csv out on cycle "<< currentClockCycle<<endl;
                        // write the vis file output
                        csvOut << CSVWriter::IndexedName("Background_Power",myChannel,r) <<backgroundPower[r];
                        csvOut << CSVWriter::IndexedName("ACT_PRE_Power",myChannel,r) << actprePower[r];
                        csvOut << CSVWriter::IndexedName("Burst_Power",myChannel,r) << burstPower[r];
                        csvOut << CSVWriter::IndexedName("Refresh_Power",myChannel,r) << refreshPower[r];
                        double totalRankBandwidth=0.0;
                        for (size_t b=0; b<NUM_BANKS; b++)
                        {
                                csvOut << CSVWriter::IndexedName("Bandwidth",myChannel,r,b) << bandwidth[SEQUENTIAL(r,b)];
                                totalRankBandwidth += bandwidth[SEQUENTIAL(r,b)];
                                totalAggregateBandwidth += bandwidth[SEQUENTIAL(r,b)];
                                csvOut << CSVWriter::IndexedName("Average_Latency",myChannel,r,b) << averageLatency[SEQUENTIAL(r,b)];
                        }
                        csvOut << CSVWriter::IndexedName("Rank_Aggregate_Bandwidth",myChannel,r) << totalRankBandwidth; 
                        csvOut << CSVWriter::IndexedName("Rank_Average_Bandwidth",myChannel,r) << totalRankBandwidth/NUM_RANKS; 
                }
        }
        if (VIS_FILE_OUTPUT)
        {
                csvOut << CSVWriter::IndexedName("Aggregate_Bandwidth",myChannel) << totalAggregateBandwidth;
                csvOut << CSVWriter::IndexedName("Average_Bandwidth",myChannel) << totalAggregateBandwidth / (NUM_RANKS*NUM_BANKS);
        }

        // only print the latency histogram at the end of the simulation since it clogs the output too much to print every epoch
        if (finalStats)
        {
                PRINT( " ---  Latency list ("<<latencies.size()<<")");
                PRINT( "       [lat] : #");
                if (VIS_FILE_OUTPUT)
                {
                        csvOut.getOutputStream() << "!!HISTOGRAM_DATA"<<endl;
                }

                map<unsigned,unsigned>::iterator it; //
                for (it=latencies.begin(); it!=latencies.end(); it++)
                {
                        PRINT( "       ["<< it->first <<"-"<<it->first+(HISTOGRAM_BIN_SIZE-1)<<"] : "<< it->second );
                        if (VIS_FILE_OUTPUT)
                        {
                                csvOut.getOutputStream() << it->first <<"="<< it->second << endl;
                        }
                }
                if (currentClockCycle % EPOCH_LENGTH == 0)
                {
                        PRINT( " --- Grand Total Bank usage list");
                        for (size_t i=0;i<NUM_RANKS;i++)
                        {
                                PRINT("Rank "<<i<<":"); 
                                for (size_t j=0;j<NUM_BANKS;j++)
                                {
                                        PRINT( "  b"<<j<<": "<<grandTotalBankAccesses[SEQUENTIAL(i,j)]);
                                }
                        }
                }

        }


        PRINT(endl<< " == Pending Transactions : "<<pendingReadTransactions.size()<<" ("<<currentClockCycle<<")==");
        /*
        for(size_t i=0;i<pendingReadTransactions.size();i++)
                {
                        PRINT( i << "] I've been waiting for "<<currentClockCycle-pendingReadTransactions[i].timeAdded<<endl;
                }
        */
#ifdef LOG_OUTPUT
        dramsim_log.flush();
#endif

        resetStats();
}
MemoryController::~MemoryController()
{
        //ERROR("MEMORY CONTROLLER DESTRUCTOR");
        //abort();
        for (size_t i=0; i<pendingReadTransactions.size(); i++)
        {
                delete pendingReadTransactions[i];
        }
        for (size_t i=0; i<returnTransaction.size(); i++)
        {
                delete returnTransaction[i];
        }

}
//inserts a latency into the latency histogram
void MemoryController::insertHistogram(unsigned latencyValue, unsigned rank, unsigned bank)
{
        totalEpochLatency[SEQUENTIAL(rank,bank)] += latencyValue;
        //poor man's way to bin things.
        latencies[(latencyValue/HISTOGRAM_BIN_SIZE)*HISTOGRAM_BIN_SIZE]++;
}
    branches: [ "main" ]
  schedule: 

#ifndef MEMORYCONTROLLER_H
#define MEMORYCONTROLLER_H

//MemoryController.h
//
//Header file for memory controller object
//

#include "SimulatorObject.h"
#include "Transaction.h"
#include "SystemConfiguration.h"
#include "CommandQueue.h"
#include "BusPacket.h"
#include "BankState.h"
#include "Rank.h"
#include "CSVWriter.h"
#include <map>

using namespace std;

namespace DRAMSim
{
class MemorySystem;
class MemoryController : public SimulatorObject
{

public:
        //functions
        MemoryController(MemorySystem* ms, CSVWriter &csvOut_, ostream &dramsim_log_);
        virtual ~MemoryController();

        bool addTransaction(Transaction *trans);
        bool WillAcceptTransaction();
        void returnReadData(const Transaction *trans);
        void receiveFromBus(BusPacket *bpacket);
        void attachRanks(vector<Rank *> *ranks);
        void update();
        void printStats(bool finalStats = false);
        void resetStats(); 


        //fields
        vector<Transaction *> transactionQueue;
private:
        ostream &dramsim_log;
        vector< vector <BankState> > bankStates;
        //functions
        void insertHistogram(unsigned latencyValue, unsigned rank, unsigned bank);

        //fields
        MemorySystem *parentMemorySystem;

        CommandQueue commandQueue;
        BusPacket *poppedBusPacket;
        vector<unsigned>refreshCountdown;
        vector<BusPacket *> writeDataToSend;
        vector<unsigned> writeDataCountdown;
        vector<Transaction *> returnTransaction;
        vector<Transaction *> pendingReadTransactions;
        map<unsigned,unsigned> latencies; // latencyValue -> latencyCount
        vector<bool> powerDown;

        vector<Rank *> *ranks;

        //output file
        CSVWriter &csvOut; 

        // these packets are counting down waiting to be transmitted on the "bus"
        BusPacket *outgoingCmdPacket;
        unsigned cmdCyclesLeft;
        BusPacket *outgoingDataPacket;
        unsigned dataCyclesLeft;

        uint64_t totalTransactions;
        vector<uint64_t> grandTotalBankAccesses; 
        vector<uint64_t> totalReadsPerBank;
        vector<uint64_t> totalWritesPerBank;

        vector<uint64_t> totalReadsPerRank;
        vector<uint64_t> totalWritesPerRank;


        vector< uint64_t > totalEpochLatency;

        unsigned channelBitWidth;
        unsigned rankBitWidth;
        unsigned bankBitWidth;
        unsigned rowBitWidth;
        unsigned colBitWidth;
        unsigned byteOffsetWidth;


        unsigned refreshRank;

public:
        // energy values are per rank -- SST uses these directly, so make these public 
        vector< uint64_t > backgroundEnergy;
        vector< uint64_t > burstEnergy;
        vector< uint64_t > actpreEnergy;
        vector< uint64_t > refreshEnergy;

};
}

#endif

    - cron: '28 7 * * 0'

env: 



//MemorySystem.cpp
//
//Class file for JEDEC memory system wrapper
//

#include "MemorySystem.h"
#include "IniReader.h"
#include <unistd.h>

using namespace std;


ofstream cmd_verify_out; //used in Rank.cpp and MemoryController.cpp if VERIFICATION_OUTPUT is set

unsigned NUM_DEVICES;
unsigned NUM_RANKS;
unsigned NUM_RANKS_LOG;

namespace DRAMSim {

powerCallBack_t MemorySystem::ReportPower = NULL;

MemorySystem::MemorySystem(unsigned id, unsigned int megsOfMemory, CSVWriter &csvOut_, ostream &dramsim_log_) :
                dramsim_log(dramsim_log_),
                ReturnReadData(NULL),
                WriteDataDone(NULL),
                systemID(id),
                csvOut(csvOut_)
{
        currentClockCycle = 0;

        DEBUG("===== MemorySystem "<<systemID<<" =====");


        //calculate the total storage based on the devices the user selected and the number of

        //calculate number of devices
        /************************
          This code has always been problematic even though it's pretty simple. I'll try to explain it 
          for my own sanity. 

          There are two main variables here that we could let the user choose:
          NUM_RANKS or TOTAL_STORAGE.  Since the density and width of the part is
          fixed by the device ini file, the only variable that is really
          controllable is the number of ranks. Users care more about choosing the
          total amount of storage, but with a fixed device they might choose a total
          storage that isn't possible. In that sense it's not as good to allow them
          to choose TOTAL_STORAGE (because any NUM_RANKS value >1 will be valid).

          However, users don't care (or know) about ranks, they care about total
          storage, so maybe it's better to let them choose and just throw an error
          if they choose something invalid. 

          A bit of background: 

          Each column contains DEVICE_WIDTH bits. A row contains NUM_COLS columns.
          Each bank contains NUM_ROWS rows. Therefore, the total storage per DRAM device is: 
                          PER_DEVICE_STORAGE = NUM_ROWS*NUM_COLS*DEVICE_WIDTH*NUM_BANKS (in bits)

         A rank *must* have a 64 bit output bus (JEDEC standard), so each rank must have:
                          NUM_DEVICES_PER_RANK = 64/DEVICE_WIDTH  
                        (note: if you have multiple channels ganged together, the bus width is 
                        effectively NUM_CHANS * 64/DEVICE_WIDTH)
         
        If we multiply these two numbers to get the storage per rank (in bits), we get:
                        PER_RANK_STORAGE = PER_DEVICE_STORAGE*NUM_DEVICES_PER_RANK = NUM_ROWS*NUM_COLS*NUM_BANKS*64 

        Finally, to get TOTAL_STORAGE, we need to multiply by NUM_RANKS
                        TOTAL_STORAGE = PER_RANK_STORAGE*NUM_RANKS (total storage in bits)

        So one could compute this in reverse -- compute NUM_DEVICES,
        PER_DEVICE_STORAGE, and PER_RANK_STORAGE first since all these parameters
        are set by the device ini. Then, TOTAL_STORAGE/PER_RANK_STORAGE = NUM_RANKS 

        The only way this could run into problems is if TOTAL_STORAGE < PER_RANK_STORAGE,
        which could happen for very dense parts.
        *********************/

        // number of bytes per rank
        unsigned long megsOfStoragePerRank = ((((long long)NUM_ROWS * (NUM_COLS * DEVICE_WIDTH) * NUM_BANKS) * ((long long)JEDEC_DATA_BUS_BITS / DEVICE_WIDTH)) / 8) >> 20;

        // If this is set, effectively override the number of ranks
        if (megsOfMemory != 0)
        {
                NUM_RANKS = megsOfMemory / megsOfStoragePerRank;
                NUM_RANKS_LOG = dramsim_log2(NUM_RANKS);
                if (NUM_RANKS == 0)
                {
                        PRINT("WARNING: Cannot create memory system with "<<megsOfMemory<<"MB, defaulting to minimum size of "<<megsOfStoragePerRank<<"MB");
                        NUM_RANKS=1;
                }
        }

        NUM_DEVICES = JEDEC_DATA_BUS_BITS/DEVICE_WIDTH;
        TOTAL_STORAGE = (NUM_RANKS * megsOfStoragePerRank); 

        DEBUG("CH. " <<systemID<<" TOTAL_STORAGE : "<< TOTAL_STORAGE << "MB | "<<NUM_RANKS<<" Ranks | "<< NUM_DEVICES <<" Devices per rank");


        memoryController = new MemoryController(this, csvOut, dramsim_log);

        // TODO: change to other vector constructor?
        ranks = new vector<Rank *>();

        for (size_t i=0; i<NUM_RANKS; i++)
        {
                Rank *r = new Rank(dramsim_log);
                r->setId(i);
                r->attachMemoryController(memoryController);
                ranks->push_back(r);
        }

        memoryController->attachRanks(ranks);

}



MemorySystem::~MemorySystem()
{
        /* the MemorySystem should exist for all time, nothing should be destroying it */  
//        ERROR("MEMORY SYSTEM DESTRUCTOR with ID "<<systemID);
//        abort();

        delete(memoryController);

        for (size_t i=0; i<NUM_RANKS; i++)
        {
                delete (*ranks)[i];
        }
        ranks->clear();
        delete(ranks);

        if (VERIFICATION_OUTPUT)
        {
                cmd_verify_out.flush();
                cmd_verify_out.close();
        }
}

bool MemorySystem::WillAcceptTransaction()
{
        return memoryController->WillAcceptTransaction();
}

bool MemorySystem::addTransaction(bool isWrite, uint64_t addr)
{
        TransactionType type = isWrite ? DATA_WRITE : DATA_READ;
        Transaction *trans = new Transaction(type,addr,NULL);
        // push_back in memoryController will make a copy of this during
        // addTransaction so it's kosher for the reference to be local 

        if (memoryController->WillAcceptTransaction()) 
        {
                return memoryController->addTransaction(trans);
        }
        else
        {
                pendingTransactions.push_back(trans);
                return true;
        }
}

bool MemorySystem::addTransaction(Transaction *trans)
{
        return memoryController->addTransaction(trans);
}

//prints statistics
void MemorySystem::printStats(bool finalStats)
{
        memoryController->printStats(finalStats);
}


//update the memory systems state
void MemorySystem::update()
{

        //PRINT(" ----------------- Memory System Update ------------------");

        //updates the state of each of the objects
        // NOTE - do not change order
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                (*ranks)[i]->update();
        }

        //pendingTransactions will only have stuff in it if MARSS is adding stuff
        if (pendingTransactions.size() > 0 && memoryController->WillAcceptTransaction())
        {
                memoryController->addTransaction(pendingTransactions.front());
                pendingTransactions.pop_front();
        }
        memoryController->update();

        //simply increments the currentClockCycle field for each object
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                (*ranks)[i]->step();
        }
        memoryController->step();
        this->step();

        //PRINT("\n"); // two new lines
}

void MemorySystem::RegisterCallbacks( Callback_t* readCB, Callback_t* writeCB,
                                      void (*reportPower)(double bgpower, double burstpower,
                                                          double refreshpower, double actprepower))
{
        ReturnReadData = readCB;
        WriteDataDone = writeCB;
        ReportPower = reportPower;
}

} /*namespace DRAMSim */



// This function can be used by autoconf AC_CHECK_LIB since
// apparently it can't detect C++ functions.
// Basically just an entry in the symbol table
extern "C"
{
        void libdramsim_is_present(void)
        {
                ;
        }
}

  # Path to the CMake build directory.
  build: '${{ 


#ifndef MEMORYSYSTEM_H
#define MEMORYSYSTEM_H

//MemorySystem.h
//
//Header file for JEDEC memory system wrapper
//

#include "SimulatorObject.h"
#include "SystemConfiguration.h"
#include "MemoryController.h"
#include "Rank.h"
#include "Transaction.h"
#include "Callback.h"
#include "CSVWriter.h"
#include <deque>

namespace DRAMSim
{
typedef CallbackBase<void,unsigned,uint64_t,uint64_t> Callback_t;
class MemorySystem : public SimulatorObject
{
        ostream &dramsim_log;
public:
        //functions
        MemorySystem(unsigned id, unsigned megsOfMemory, CSVWriter &csvOut_, ostream &dramsim_log_);
        virtual ~MemorySystem();
        void update();
        bool addTransaction(Transaction *trans);
        bool addTransaction(bool isWrite, uint64_t addr);
        void printStats(bool finalStats);
        bool WillAcceptTransaction();
        void RegisterCallbacks(
            Callback_t *readDone,
            Callback_t *writeDone,
            void (*reportPower)(double bgpower, double burstpower, double refreshpower, double actprepower));

        //fields
        MemoryController *memoryController;
        vector<Rank *> *ranks;
        deque<Transaction *> pendingTransactions; 


        //function pointers
        Callback_t* ReturnReadData;
        Callback_t* WriteDataDone;
        //TODO: make this a functor as well?
        static powerCallBack_t ReportPower;
        unsigned systemID;

private:
        CSVWriter &csvOut;
};
}

#endif
 }}/build'

permissions: #include <errno.h> 
#include <sstream> //stringstream
#include <stdlib.h> // getenv()
// for directory operations 
#include <sys/stat.h>
#include <sys/types.h>

#include "MultiChannelMemorySystem.h"
#include "AddressMapping.h"
#include "IniReader.h"



using namespace DRAMSim; 


MultiChannelMemorySystem::MultiChannelMemorySystem(const string &deviceIniFilename_, const string &systemIniFilename_, const string &pwd_, const string &traceFilename_, unsigned megsOfMemory_, string *visFilename_, const IniReader::OverrideMap *paramOverrides)
        :megsOfMemory(megsOfMemory_), deviceIniFilename(deviceIniFilename_),
        systemIniFilename(systemIniFilename_), traceFilename(traceFilename_),
        pwd(pwd_), visFilename(visFilename_), 
        clockDomainCrosser(new ClockDomain::Callback<MultiChannelMemorySystem, void>(this, &MultiChannelMemorySystem::actual_update)),
        csvOut(new CSVWriter(visDataOut))
{
        currentClockCycle=0; 
        if (visFilename)
                printf("CC VISFILENAME=%s\n",visFilename->c_str());

        if (!isPowerOfTwo(megsOfMemory))
        {
                ERROR("Please specify a power of 2 memory size"); 
                abort(); 
        }

        if (pwd.length() > 0)
        {
                //ignore the pwd argument if the argument is an absolute path
                if (deviceIniFilename[0] != '/')
                {
                        deviceIniFilename = pwd + "/" + deviceIniFilename;
                }

                if (systemIniFilename[0] != '/')
                {
                        systemIniFilename = pwd + "/" + systemIniFilename;
                }
        }

        DEBUG("== Loading device model file '"<<deviceIniFilename<<"' == ");
        IniReader::ReadIniFile(deviceIniFilename, false);
        DEBUG("== Loading system model file '"<<systemIniFilename<<"' == ");
        IniReader::ReadIniFile(systemIniFilename, true);

        // If we have any overrides, set them now before creating all of the memory objects
        if (paramOverrides)
                IniReader::OverrideKeys(paramOverrides);

        IniReader::InitEnumsFromStrings();
        if (!IniReader::CheckIfAllSet())
        {
                exit(-1);
        }

        if (NUM_CHANS == 0) 
        {
                ERROR("Zero channels"); 
                abort(); 
        }
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                MemorySystem *channel = new MemorySystem(i, megsOfMemory/NUM_CHANS, (*csvOut), dramsim_log);
                channels.push_back(channel);
        }
}
/* Initialize the ClockDomainCrosser to use the CPU speed 
        If cpuClkFreqHz == 0, then assume a 1:1 ratio (like for TraceBasedSim)
        */
void MultiChannelMemorySystem::setCPUClockSpeed(uint64_t cpuClkFreqHz)
{

        uint64_t dramsimClkFreqHz = (uint64_t)(1.0/(tCK*1e-9));
        clockDomainCrosser.clock1 = dramsimClkFreqHz; 
        clockDomainCrosser.clock2 = (cpuClkFreqHz == 0) ? dramsimClkFreqHz : cpuClkFreqHz; 
}

bool fileExists(string &path)
{
        struct stat stat_buf;
        if (stat(path.c_str(), &stat_buf) != 0) 
        {
                if (errno == ENOENT)
                {
                        return false; 
                }
                ERROR("Warning: some other kind of error happened with stat(), should probably check that"); 
        }
        return true;
}

string FilenameWithNumberSuffix(const string &filename, const string &extension, unsigned maxNumber=100)
{
        string currentFilename = filename+extension;
        if (!fileExists(currentFilename))
        {
                return currentFilename;
        }

        // otherwise, add the suffixes and test them out until we find one that works
        stringstream tmpNum; 
        tmpNum<<"."<<1; 
        for (unsigned i=1; i<maxNumber; i++)
        {
                currentFilename = filename+tmpNum.str()+extension;
                if (fileExists(currentFilename))
                {
                        currentFilename = filename; 
                        tmpNum.seekp(0);
                        tmpNum << "." << i;
                }
                else 
                {
                        return currentFilename;
                }
        }
        // if we can't find one, just give up and return whatever is the current filename
        ERROR("Warning: Couldn't find a suitable suffix for "<<filename); 
        return currentFilename; 
}
/**
 * This function creates up to 3 output files: 
 *         - The .log file if LOG_OUTPUT is set
 *         - the .vis file where csv data for each epoch will go
 *         - the .tmp file if verification output is enabled
 * The results directory is setup to be in PWD/TRACEFILENAME.[SIM_DESC]/DRAM_PARTNAME/PARAMS.vis
 * The environment variable SIM_DESC is also appended to output files/directories
 *
 * TODO: verification info needs to be generated per channel so it has to be
 * moved back to MemorySystem
 **/
void MultiChannelMemorySystem::InitOutputFiles(string traceFilename)
{
        size_t lastSlash;
        size_t deviceIniFilenameLength = deviceIniFilename.length();
        string sim_description_str;
        string deviceName;

        char *sim_description = getenv("SIM_DESC");
        if (sim_description)
        {
                        sim_description_str = string(sim_description);
        }


        // create a properly named verification output file if need be and open it
        // as the stream 'cmd_verify_out'
        if (VERIFICATION_OUTPUT)
        {
                string basefilename = deviceIniFilename.substr(deviceIniFilename.find_last_of("/")+1);
                string verify_filename =  "sim_out_"+basefilename;
                if (sim_description != NULL)
                {
                        verify_filename += "."+sim_description_str;
                }
                verify_filename += ".tmp";
                cmd_verify_out.open(verify_filename.c_str());
                if (!cmd_verify_out)
                {
                        ERROR("Cannot open "<< verify_filename);
                        abort(); 
                }
        }
        // This sets up the vis file output along with the creating the result
        // directory structure if it doesn't exist
        if (VIS_FILE_OUTPUT)
        {
                stringstream out,tmpNum;
                string path;
                string filename;

                if (!visFilename)
                {
                        path = "results/";
                        // chop off the .ini if it's there
                        if (deviceIniFilename.substr(deviceIniFilenameLength-4) == ".ini")
                        {
                                deviceName = deviceIniFilename.substr(0,deviceIniFilenameLength-4);
                                deviceIniFilenameLength -= 4;
                        }

                        // chop off everything past the last / (i.e. leave filename only)
                        if ((lastSlash = deviceName.find_last_of("/")) != string::npos)
                        {
                                deviceName = deviceName.substr(lastSlash+1,deviceIniFilenameLength-lastSlash-1);
                        }

                string rest;
                        // working backwards, chop off the next piece of the directory
                        if ((lastSlash = traceFilename.find_last_of("/")) != string::npos)
                        {
                                traceFilename = traceFilename.substr(lastSlash+1,traceFilename.length()-lastSlash-1);
                        }
                        if (sim_description != NULL)
                        {
                                traceFilename += "."+sim_description_str;
                        }

                        if (pwd.length() > 0)
                        {
                                path = pwd + "/" + path;
                        }

                        // create the directories if they don't exist 
                        mkdirIfNotExist(path);
                        path = path + traceFilename + "/";
                        mkdirIfNotExist(path);
                        path = path + deviceName + "/";
                        mkdirIfNotExist(path);

                        // finally, figure out the filename
                        string sched = "BtR";
                        string queue = "pRank";
                        if (schedulingPolicy == RankThenBankRoundRobin)
                        {
                                sched = "RtB";
                        }
                        if (queuingStructure == PerRankPerBank)
                        {
                                queue = "pRankpBank";
                        }

                        /* I really don't see how "the C++ way" is better than snprintf()  */
                        out << (TOTAL_STORAGE>>10) << "GB." << NUM_CHANS << "Ch." << NUM_RANKS <<"R." <<ADDRESS_MAPPING_SCHEME<<"."<<ROW_BUFFER_POLICY<<"."<< TRANS_QUEUE_DEPTH<<"TQ."<<CMD_QUEUE_DEPTH<<"CQ."<<sched<<"."<<queue;
                }
                else //visFilename given
                {
                        out << *visFilename;
                }
                if (sim_description)
                {
                        out << "." << sim_description;
                }

                //filename so far, without extension, see if it exists already
                filename = out.str();


                filename = FilenameWithNumberSuffix(filename, ".vis"); 
                path.append(filename);
                cerr << "writing vis file to " <<path<<endl;


                visDataOut.open(path.c_str());
                if (!visDataOut)
                {
                        ERROR("Cannot open '"<<path<<"'");
                        exit(-1);
                }
                //write out the ini config values for the visualizer tool
                IniReader::WriteValuesOut(visDataOut);

        }
        else
        {
                // cerr << "vis file output disabled\n";
        }
#ifdef LOG_OUTPUT
        string dramsimLogFilename("dramsim");
        if (sim_description != NULL)
        {
                dramsimLogFilename += "."+sim_description_str; 
        }

        dramsimLogFilename = FilenameWithNumberSuffix(dramsimLogFilename, ".log"); 

        dramsim_log.open(dramsimLogFilename.c_str(), ios_base::out | ios_base::trunc );

        if (!dramsim_log) 
        {
        ERROR("Cannot open "<< dramsimLogFilename);
        //        exit(-1); 
        }
#endif

}


void MultiChannelMemorySystem::mkdirIfNotExist(string path)
{
        struct stat stat_buf;
        // check if the directory exists
        if (stat(path.c_str(), &stat_buf) != 0) // nonzero return value on error, check errno
        {
                if (errno == ENOENT) 
                {
//                        DEBUG("\t directory doesn't exist, trying to create ...");

                        // set permissions dwxr-xr-x on the results directories
                        mode_t mode = (S_IXOTH | S_IXGRP | S_IXUSR | S_IROTH | S_IRGRP | S_IRUSR | S_IWUSR) ;
                        if (mkdir(path.c_str(), mode) != 0)
                        {
                                perror("Error Has occurred while trying to make directory: ");
                                cerr << path << endl;
                                abort();
                        }
                }
                else
                {
                        perror("Something else when wrong: "); 
                        abort();
                }
        }
        else // directory already exists
        {
                if (!S_ISDIR(stat_buf.st_mode))
                {
                        ERROR(path << "is not a directory");
                        abort();
                }
        }
}


MultiChannelMemorySystem::~MultiChannelMemorySystem()
{
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                delete channels[i];
        }
        channels.clear(); 

// flush our streams and close them up
#ifdef LOG_OUTPUT
        dramsim_log.flush();
        dramsim_log.close();
#endif
        if (VIS_FILE_OUTPUT) 
        {        
                visDataOut.flush();
                visDataOut.close();
        }
}
void MultiChannelMemorySystem::update()
{
        clockDomainCrosser.update(); 
}
void MultiChannelMemorySystem::actual_update() 
{
        if (currentClockCycle == 0)
        {
                InitOutputFiles(traceFilename);
                DEBUG("DRAMSim2 Clock Frequency ="<<clockDomainCrosser.clock1<<"Hz, CPU Clock Frequency="<<clockDomainCrosser.clock2<<"Hz"); 
        }

        if (currentClockCycle % EPOCH_LENGTH == 0)
        {
                (*csvOut) << "ms" <<currentClockCycle * tCK * 1E-6; 
                for (size_t i=0; i<NUM_CHANS; i++)
                {
                        channels[i]->printStats(false); 
                }
                csvOut->finalize();
        }

        for (size_t i=0; i<NUM_CHANS; i++)
        {
                channels[i]->update(); 
        }


        currentClockCycle++; 
}
unsigned MultiChannelMemorySystem::findChannelNumber(uint64_t addr)
{
        // Single channel case is a trivial shortcut case 
        if (NUM_CHANS == 1)
        {
                return 0; 
        }

        if (!isPowerOfTwo(NUM_CHANS))
        {
                ERROR("We can only support power of two # of channels.\n" <<
                                "I don't know what Intel was thinking, but trying to address map half a bit is a neat trick that we're not sure how to do"); 
                abort(); 
        }

        // only chan is used from this set 
        unsigned channelNumber,rank,bank,row,col;
        addressMapping(addr, channelNumber, rank, bank, row, col); 
        if (channelNumber >= NUM_CHANS)
        {
                ERROR("Got channel index "<<channelNumber<<" but only "<<NUM_CHANS<<" exist"); 
                abort();
        }
        //DEBUG("Channel idx = "<<channelNumber<<" totalbits="<<totalBits<<" channelbits="<<channelBits); 

        return channelNumber;

}
ostream &MultiChannelMemorySystem::getLogFile()
{
        return dramsim_log; 
}
bool MultiChannelMemorySystem::addTransaction(const Transaction &trans)
{
        // copy the transaction and send the pointer to the new transaction 
        return addTransaction(new Transaction(trans)); 
}

bool MultiChannelMemorySystem::addTransaction(Transaction *trans)
{
        unsigned channelNumber = findChannelNumber(trans->address); 
        return channels[channelNumber]->addTransaction(trans); 
}

bool MultiChannelMemorySystem::addTransaction(bool isWrite, uint64_t addr)
{
        unsigned channelNumber = findChannelNumber(addr); 
        return channels[channelNumber]->addTransaction(isWrite, addr); 
}

/*
        This function has two flavors: one with and without the address. 
        If the simulator won't give us an address and we have multiple channels, 
        we have to assume the worst and return false if any channel won't accept. 

        However, if the address is given, we can just map the channel and check just
        that memory controller
*/

bool MultiChannelMemorySystem::willAcceptTransaction(uint64_t addr)
{
        unsigned chan, rank,bank,row,col; 
        addressMapping(addr, chan, rank, bank, row, col); 
        return channels[chan]->WillAcceptTransaction(); 
}

bool MultiChannelMemorySystem::willAcceptTransaction()
{
        for (size_t c=0; c<NUM_CHANS; c++) {
                if (!channels[c]->WillAcceptTransaction())
                {
                        return false; 
                }
        }
        return true; 
}



void MultiChannelMemorySystem::printStats(bool finalStats) {

        (*csvOut) << "ms" <<currentClockCycle * tCK * 1E-6; 
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                PRINT("==== Channel ["<<i<<"] ====");
                channels[i]->printStats(finalStats); 
                PRINT("//// Channel ["<<i<<"] ////");
        }
        csvOut->finalize();
}
void MultiChannelMemorySystem::RegisterCallbacks( 
                TransactionCompleteCB *readDone,
                TransactionCompleteCB *writeDone,
                void (*reportPower)(double bgpower, double burstpower, double refreshpower, double actprepower))
{
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                channels[i]->RegisterCallbacks(readDone, writeDone, reportPower); 
        }
}

/*
 * The getters below are useful to external simulators interfacing with DRAMSim
 *
 * Return value: 0 on success, -1 on error
 */
int MultiChannelMemorySystem::getIniBool(const std::string& field, bool *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getBool(field, val);
}

int MultiChannelMemorySystem::getIniUint(const std::string& field, unsigned int *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getUint(field, val);
}

int MultiChannelMemorySystem::getIniUint64(const std::string& field, uint64_t *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getUint64(field, val);
}

int MultiChannelMemorySystem::getIniFloat(const std::string& field, float *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getFloat(field, val);
}

namespace DRAMSim {
MultiChannelMemorySystem *getMemorySystemInstance(const string &dev, const string &sys, const string &pwd, const string &trc, unsigned megsOfMemory, string *visfilename) 
{
        return new MultiChannelMemorySystem(dev, sys, pwd, trc, megsOfMemory, visfilename);
}
}
  contents: read

jobs: #include "SimulatorObject.h"
#include "Transaction.h"
#include "SystemConfiguration.h"
#include "MemorySystem.h"
#include "IniReader.h"
#include "ClockDomain.h"
#include "CSVWriter.h"


namespace DRAMSim {


class MultiChannelMemorySystem : public SimulatorObject 
{
        public: 

        MultiChannelMemorySystem(const string &dev, const string &sys, const string &pwd, const string &trc, unsigned megsOfMemory, string *visFilename=NULL, const IniReader::OverrideMap *paramOverrides=NULL);
                virtual ~MultiChannelMemorySystem();
                        bool addTransaction(Transaction *trans);
                        bool addTransaction(const Transaction &trans);
                        bool addTransaction(bool isWrite, uint64_t addr);
                        bool willAcceptTransaction(); 
                        bool willAcceptTransaction(uint64_t addr); 
                        void update();
                        void printStats(bool finalStats=false);
                        ostream &getLogFile();
                        void RegisterCallbacks( 
                                TransactionCompleteCB *readDone,
                                TransactionCompleteCB *writeDone,
                                void (*reportPower)(double bgpower, double burstpower, double refreshpower, double actprepower));
                        int getIniBool(const std::string &field, bool *val);
                        int getIniUint(const std::string &field, unsigned int *val);
                        int getIniUint64(const std::string &field, uint64_t *val);
                        int getIniFloat(const std::string &field, float *val);

        void InitOutputFiles(string tracefilename);
        void setCPUClockSpeed(uint64_t cpuClkFreqHz);

        //output file
        std::ofstream visDataOut;
        ofstream dramsim_log; 

        private:
                unsigned findChannelNumber(uint64_t addr);
                void actual_update(); 
                vector<MemorySystem*> channels; 
                unsigned megsOfMemory; 
                string deviceIniFilename;
                string systemIniFilename;
                string traceFilename;
                string pwd;
                string *visFilename;
                ClockDomain::ClockDomainCrosser clockDomainCrosser; 
                static void mkdirIfNotExist(string path);
                static bool fileExists(string path); 
                CSVWriter *csvOut; 


        };
}
  analyze: #include "PrintMacros.h"

/*
 * Enable or disable PRINT() statements.
 *
 * Set by flag in TraceBasedSim.cpp when compiling standalone DRAMSim tool.
 *
 * The DRAMSim libraries do not include the TraceBasedSim object and thus
 * library users can optionally override the weak definition below.
 */
int __attribute__((weak)) SHOW_SIM_OUTPUT = false;
    permissions: 




#ifndef PRINT_MACROS_H
#define PRINT_MACROS_H

#include <iostream>

extern int SHOW_SIM_OUTPUT;

#define ERROR(str) std::cerr<<"[ERROR ("<<__FILE__<<":"<<__LINE__<<")]: "<<str<<std::endl;

using std::ostream;

#ifdef DEBUG_BUILD
        #define DEBUG(str)  std::cerr<< str <<std::endl;
        #define DEBUGN(str) std::cerr<< str;
#else
        #define DEBUG(str) ;
        #define DEBUGN(str) ;
#endif

#ifdef NO_OUTPUT
        #undef DEBUG
        #undef DEBUGN
        #define DEBUG(str) ;
        #define DEBUGN(str) ;
        #define PRINT(str) ;
        #define PRINTN(str) ;
#else
        #ifdef LOG_OUTPUT
                #define PRINT(str)  { dramsim_log <<str<<std::endl; }
                #define PRINTN(str) { dramsim_log <<str; }
        #else
                #define PRINT(str)  if(SHOW_SIM_OUTPUT) { std::cout <<str<<std::endl; }
                #define PRINTN(str) if(SHOW_SIM_OUTPUT) { std::cout <<str; }
        #endif
#endif

#endif /*PRINT_MACROS_H*/
      contents: read # for actions/checkout to fetch code
      security-events: write # for github/codeql-action/upload-sarif to upload SARIF results
      actions: read # only required for a private repository by github/codeql-action/upload-sarif to get the Action run status
    name: Analyze
    runs-on: windows-latest

    steps: 



#include "Rank.h"
#include "MemoryController.h"

using namespace std;
using namespace DRAMSim;

Rank::Rank(ostream &dramsim_log_) :
        id(-1),
        dramsim_log(dramsim_log_),
        isPowerDown(false),
        refreshWaiting(false),
        readReturnCountdown(0),
        banks(NUM_BANKS, Bank(dramsim_log_)),
        bankStates(NUM_BANKS, BankState(dramsim_log_))

{

        memoryController = NULL;
        outgoingDataPacket = NULL;
        dataCyclesLeft = 0;
        currentClockCycle = 0;

#ifndef NO_STORAGE
#endif

}

// mutators
void Rank::setId(int id)
{
        this->id = id;
}

// attachMemoryController() must be called before any other Rank functions
// are called
void Rank::attachMemoryController(MemoryController *memoryController)
{
        this->memoryController = memoryController;
}
Rank::~Rank()
{
        for (size_t i=0; i<readReturnPacket.size(); i++)
        {
                delete readReturnPacket[i];
        }
        readReturnPacket.clear(); 
        delete outgoingDataPacket; 
}
void Rank::receiveFromBus(BusPacket *packet)
{
        if (DEBUG_BUS)
        {
                PRINTN(" -- R" << this->id << " Receiving On Bus    : ");
                packet->print();
        }
        if (VERIFICATION_OUTPUT)
        {
                packet->print(currentClockCycle,false);
        }

        switch (packet->busPacketType)
        {
        case READ:
                //make sure a read is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextRead ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        packet->print();
                        ERROR("== Error - Rank " << id << " received a READ when not allowed");
                        exit(0);
                }

                //update state table
                bankStates[packet->bank].nextPrecharge = max(bankStates[packet->bank].nextPrecharge, currentClockCycle + READ_TO_PRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + max(tCCD, BL/2));
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + READ_TO_WRITE_DELAY);
                }

                //get the read data and put it in the storage which delays until the appropriate time (RL)
#ifndef NO_STORAGE
                banks[packet->bank].read(packet);
#else
                packet->busPacketType = DATA;
#endif
                readReturnPacket.push_back(packet);
                readReturnCountdown.push_back(RL);
                break;
        case READ_P:
                //make sure a read is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextRead ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        ERROR("== Error - Rank " << id << " received a READ_P when not allowed");
                        exit(-1);
                }

                //update state table
                bankStates[packet->bank].currentBankState = Idle;
                bankStates[packet->bank].nextActivate = max(bankStates[packet->bank].nextActivate, currentClockCycle + READ_AUTOPRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        //will set next read/write for all banks - including current (which shouldnt matter since its now idle)
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + max(BL/2, tCCD));
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + READ_TO_WRITE_DELAY);
                }

                //get the read data and put it in the storage which delays until the appropriate time (RL)
#ifndef NO_STORAGE
                banks[packet->bank].read(packet);
#else
                packet->busPacketType = DATA;
#endif

                readReturnPacket.push_back(packet);
                readReturnCountdown.push_back(RL);
                break;
        case WRITE:
                //make sure a write is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextWrite ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        ERROR("== Error - Rank " << id << " received a WRITE when not allowed");
                        bankStates[packet->bank].print();
                        exit(0);
                }

                //update state table
                bankStates[packet->bank].nextPrecharge = max(bankStates[packet->bank].nextPrecharge, currentClockCycle + WRITE_TO_PRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + WRITE_TO_READ_DELAY_B);
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + max(BL/2, tCCD));
                }

                //take note of where data is going when it arrives
                incomingWriteBank = packet->bank;
                incomingWriteRow = packet->row;
                incomingWriteColumn = packet->column;
                delete(packet);
                break;
        case WRITE_P:
                //make sure a write is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextWrite ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        ERROR("== Error - Rank " << id << " received a WRITE_P when not allowed");
                        exit(0);
                }

                //update state table
                bankStates[packet->bank].currentBankState = Idle;
                bankStates[packet->bank].nextActivate = max(bankStates[packet->bank].nextActivate, currentClockCycle + WRITE_AUTOPRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + max(tCCD, BL/2));
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + WRITE_TO_READ_DELAY_B);
                }

                //take note of where data is going when it arrives
                incomingWriteBank = packet->bank;
                incomingWriteRow = packet->row;
                incomingWriteColumn = packet->column;
                delete(packet);
                break;
        case ACTIVATE:
                //make sure activate is allowed
                if (bankStates[packet->bank].currentBankState != Idle ||
                        currentClockCycle < bankStates[packet->bank].nextActivate)
                {
                        ERROR("== Error - Rank " << id << " received an ACT when not allowed");
                        packet->print();
                        bankStates[packet->bank].print();
                        exit(0);
                }

                bankStates[packet->bank].currentBankState = RowActive;
                bankStates[packet->bank].nextActivate = currentClockCycle + tRC;
                bankStates[packet->bank].openRowAddress = packet->row;

                //if AL is greater than one, then posted-cas is enabled - handle accordingly
                if (AL>0)
                {
                        bankStates[packet->bank].nextWrite = currentClockCycle + (tRCD-AL);
                        bankStates[packet->bank].nextRead = currentClockCycle + (tRCD-AL);
                }
                else
                {
                        bankStates[packet->bank].nextWrite = currentClockCycle + (tRCD-AL);
                        bankStates[packet->bank].nextRead = currentClockCycle + (tRCD-AL);
                }

                bankStates[packet->bank].nextPrecharge = currentClockCycle + tRAS;
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        if (i != packet->bank)
                        {
                                bankStates[i].nextActivate = max(bankStates[i].nextActivate, currentClockCycle + tRRD);
                        }
                }
                delete(packet); 
                break;
        case PRECHARGE:
                //make sure precharge is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextPrecharge)
                {
                        ERROR("== Error - Rank " << id << " received a PRE when not allowed");
                        exit(0);
                }

                bankStates[packet->bank].currentBankState = Idle;
                bankStates[packet->bank].nextActivate = max(bankStates[packet->bank].nextActivate, currentClockCycle + tRP);
                delete(packet); 
                break;
        case REFRESH:
                refreshWaiting = false;
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        if (bankStates[i].currentBankState != Idle)
                        {
                                ERROR("== Error - Rank " << id << " received a REF when not allowed");
                                exit(0);
                        }
                        bankStates[i].nextActivate = currentClockCycle + tRFC;
                }
                delete(packet); 
                break;
        case DATA:
                // TODO: replace this check with something that works?
                /*
                if(packet->bank != incomingWriteBank ||
                         packet->row != incomingWriteRow ||
                         packet->column != incomingWriteColumn)
                        {
                                cout << "== Error - Rank " << id << " received a DATA packet to the wrong place" << endl;
                                packet->print();
                                bankStates[packet->bank].print();
                                exit(0);
                        }
                */
#ifndef NO_STORAGE
                banks[packet->bank].write(packet);
#else
                // end of the line for the write packet
#endif
                delete(packet);
                break;
        default:
                ERROR("== Error - Unknown BusPacketType trying to be sent to Bank");
                exit(0);
                break;
        }
}

int Rank::getId() const
{
        return this->id;
}

void Rank::update()
{

        // An outgoing packet is one that is currently sending on the bus
        // do the book keeping for the packet's time left on the bus
        if (outgoingDataPacket != NULL)
        {
                dataCyclesLeft--;
                if (dataCyclesLeft == 0)
                {
                        //if the packet is done on the bus, call receiveFromBus and free up the bus
                        memoryController->receiveFromBus(outgoingDataPacket);
                        outgoingDataPacket = NULL;
                }
        }

        // decrement the counter for all packets waiting to be sent back
        for (size_t i=0;i<readReturnCountdown.size();i++)
        {
                readReturnCountdown[i]--;
        }


        if (readReturnCountdown.size() > 0 && readReturnCountdown[0]==0)
        {
                // RL time has passed since the read was issued; this packet is
                // ready to go out on the bus

                outgoingDataPacket = readReturnPacket[0];
                dataCyclesLeft = BL/2;

                // remove the packet from the ranks
                readReturnPacket.erase(readReturnPacket.begin());
                readReturnCountdown.erase(readReturnCountdown.begin());

                if (DEBUG_BUS)
                {
                        PRINTN(" -- R" << this->id << " Issuing On Data Bus : ");
                        outgoingDataPacket->print();
                        PRINT("");
                }

        }
}

//power down the rank
void Rank::powerDown()
{
        //perform checks
        for (size_t i=0;i<NUM_BANKS;i++)
        {
                if (bankStates[i].currentBankState != Idle)
                {
                        ERROR("== Error - Trying to power down rank " << id << " while not all banks are idle");
                        exit(0);
                }

                bankStates[i].nextPowerUp = currentClockCycle + tCKE;
                bankStates[i].currentBankState = PowerDown;
        }

        isPowerDown = true;
}

//power up the rank
void Rank::powerUp()
{
        if (!isPowerDown)
        {
                ERROR("== Error - Trying to power up rank " << id << " while it is not already powered down");
                exit(0);
        }

        isPowerDown = false;

        for (size_t i=0;i<NUM_BANKS;i++)
        {
                if (bankStates[i].nextPowerUp > currentClockCycle)
                {
                        ERROR("== Error - Trying to power up rank " << id << " before we're allowed to");
                        ERROR(bankStates[i].nextPowerUp << "    " << currentClockCycle);
                        exit(0);
                }
                bankStates[i].nextActivate = currentClockCycle + tXP;
                bankStates[i].currentBankState = Idle;
        }
}
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure CMake
        run: cmake -B ${{ 



#ifndef RANK_H
#define RANK_H

#include "SimulatorObject.h"
#include "BusPacket.h"
#include "SystemConfiguration.h"
#include "Bank.h"
#include "BankState.h"

using namespace std;
using namespace DRAMSim;

namespace DRAMSim
{
class MemoryController; //forward declaration
class Rank : public SimulatorObject
{
private:
        int id;
        ostream &dramsim_log; 
        unsigned incomingWriteBank;
        unsigned incomingWriteRow;
        unsigned incomingWriteColumn;
        bool isPowerDown;

public:
        //functions
        Rank(ostream &dramsim_log_);
        virtual ~Rank(); 
        void receiveFromBus(BusPacket *packet);
        void attachMemoryController(MemoryController *mc);
        int getId() const;
        void setId(int id);
        void update();
        void powerUp();
        void powerDown();

        //fields
        MemoryController *memoryController;
        BusPacket *outgoingDataPacket;
        unsigned dataCyclesLeft;
        bool refreshWaiting;

        //these are vectors so that each element is per-bank
        vector<BusPacket *> readReturnPacket;
        vector<unsigned> readReturnCountdown;
        vector<Bank> banks;
        vector<BankState> bankStates;

};
}
#endif
 }}

      # Build is not required unless generated source files are used
      # - name: 






//SimulatorObject.cpp
//
//Base class for all classes in the simulator
//

#include <cstdlib>
#include "SimulatorObject.h"

using namespace DRAMSim;
using namespace std;

void SimulatorObject::step()
{
        currentClockCycle++;
}


      #   run: cmake --build ${{ 







#ifndef SIMULATOROBJ_H
#define SIMULATOROBJ_H

//SimulatorObject.h
//
//Header file for simulator object class
//

#include <stdint.h>

namespace DRAMSim
{
class SimulatorObject
{
public:
        uint64_t currentClockCycle;

        void step();
        virtual void update()=0;
};
}

#endif
 }}

      - name: Initialize MSVC Code Analysis
        uses: microsoft/msvc-code-analysis-action@04825f6d9e00f87422d6bf04e1a38b1f3ed60d99
        # Provide a unique ID to access the sarif output path
        id: run-analysis
        with: 


#ifndef SYSCONFIG_H
#define SYSCONFIG_H

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdlib>
#include <stdint.h>
#include "PrintMacros.h"

#ifdef __APPLE__
#include <sys/types.h>
#endif

//SystemConfiguration.h
//
//Configuration values for the current system



//number of latencies per bucket in the latency histogram
//TODO: move to system ini file
#define HISTOGRAM_BIN_SIZE 10

extern std::ofstream cmd_verify_out; //used by BusPacket.cpp if VERIFICATION_OUTPUT is enabled
//extern std::ofstream visDataOut;

//TODO: namespace these to DRAMSim:: 
extern bool VERIFICATION_OUTPUT; // output suitable to feed to modelsim

extern bool DEBUG_TRANS_Q;
extern bool DEBUG_CMD_Q;
extern bool DEBUG_ADDR_MAP;
extern bool DEBUG_BANKSTATE;
extern bool DEBUG_BUS;
extern bool DEBUG_BANKS;
extern bool DEBUG_POWER;
extern bool USE_LOW_POWER;
extern bool VIS_FILE_OUTPUT;

extern uint64_t TOTAL_STORAGE;
extern unsigned NUM_BANKS;
extern unsigned NUM_BANKS_LOG;
extern unsigned NUM_RANKS;
extern unsigned NUM_RANKS_LOG;
extern unsigned NUM_CHANS;
extern unsigned NUM_CHANS_LOG;
extern unsigned NUM_ROWS;
extern unsigned NUM_ROWS_LOG;
extern unsigned NUM_COLS;
extern unsigned NUM_COLS_LOG;
extern unsigned DEVICE_WIDTH;
extern unsigned BYTE_OFFSET_WIDTH;
extern unsigned TRANSACTION_SIZE;
extern unsigned THROW_AWAY_BITS;
extern unsigned COL_LOW_BIT_WIDTH;

//in nanoseconds
extern unsigned REFRESH_PERIOD;
extern float tCK;

extern unsigned CL;
extern unsigned AL;
#define RL (CL+AL)
#define WL (RL-1)
extern unsigned BL;
extern unsigned tRAS;
extern unsigned tRCD;
extern unsigned tRRD;
extern unsigned tRC;
extern unsigned tRP;
extern unsigned tCCD;
extern unsigned tRTP;
extern unsigned tWTR;
extern unsigned tWR;
extern unsigned tRTRS;
extern unsigned tRFC;
extern unsigned tFAW;
extern unsigned tCKE;
extern unsigned tXP;

extern unsigned tCMD;

/* For power parameters (current and voltage), see externs in MemoryController.cpp */ 

extern unsigned NUM_DEVICES;

//same bank
#define READ_TO_PRE_DELAY (AL+BL/2+ max(tRTP,tCCD)-tCCD)
#define WRITE_TO_PRE_DELAY (WL+BL/2+tWR)
#define READ_TO_WRITE_DELAY (RL+BL/2+tRTRS-WL)
#define READ_AUTOPRE_DELAY (AL+tRTP+tRP)
#define WRITE_AUTOPRE_DELAY (WL+BL/2+tWR+tRP)
#define WRITE_TO_READ_DELAY_B (WL+BL/2+tWTR) //interbank
#define WRITE_TO_READ_DELAY_R (WL+BL/2+tRTRS-RL) //interrank

extern unsigned JEDEC_DATA_BUS_BITS;

//Memory Controller related parameters
extern unsigned TRANS_QUEUE_DEPTH;
extern unsigned CMD_QUEUE_DEPTH;

extern unsigned EPOCH_LENGTH;

extern unsigned TOTAL_ROW_ACCESSES;

extern std::string ROW_BUFFER_POLICY;
extern std::string SCHEDULING_POLICY;
extern std::string ADDRESS_MAPPING_SCHEME;
extern std::string QUEUING_STRUCTURE;

enum TraceType
{
        k6,
        mase,
        misc
};

enum AddressMappingScheme
{
        Scheme1,
        Scheme2,
        Scheme3,
        Scheme4,
        Scheme5,
        Scheme6,
        Scheme7
};

// used in MemoryController and CommandQueue
enum RowBufferPolicy
{
        OpenPage,
        ClosePage
};

// Only used in CommandQueue
enum QueuingStructure
{
        PerRank,
        PerRankPerBank
};

enum SchedulingPolicy
{
        RankThenBankRoundRobin,
        BankThenRankRoundRobin
};


// set by IniReader.cpp


namespace DRAMSim
{
typedef void (*returnCallBack_t)(unsigned id, uint64_t addr, uint64_t clockcycle);
typedef void (*powerCallBack_t)(double bgpower, double burstpower, double refreshpower, double actprepower);

extern RowBufferPolicy rowBufferPolicy;
extern SchedulingPolicy schedulingPolicy;
extern AddressMappingScheme addressMappingScheme;
extern QueuingStructure queuingStructure;
//
//FUNCTIONS
//

unsigned inline dramsim_log2(unsigned value)
{
        unsigned logbase2 = 0;
        unsigned orig = value;
        value>>=1;
        while (value>0)
        {
                value >>= 1;
                logbase2++;
        }
        if ((unsigned)1<<logbase2<orig)logbase2++;
        return logbase2;
}
inline bool isPowerOfTwo(unsigned long x)
{
        return (1UL<<dramsim_log2(x)) == x;
}


};

#endif

          cmakeBuildDirectory: ${{ 


//TraceBasedSim.cpp
//
//File to run a trace-based simulation
//

#include <iostream>
#include <fstream>
#include <sstream>
#include <getopt.h>
#include <map>
#include <list>

#include "SystemConfiguration.h"
#include "MemorySystem.h"
#include "MultiChannelMemorySystem.h"
#include "Transaction.h"
#include "IniReader.h"


using namespace DRAMSim;
using namespace std;

//#define RETURN_TRANSACTIONS 1

#ifndef _SIM_
int SHOW_SIM_OUTPUT = 1;
ofstream visDataOut; //mostly used in MemoryController

#ifdef RETURN_TRANSACTIONS
class TransactionReceiver
{
        private: 
                map<uint64_t, list<uint64_t> > pendingReadRequests; 
                map<uint64_t, list<uint64_t> > pendingWriteRequests; 

        public: 
                void add_pending(const Transaction &t, uint64_t cycle)
                {
                        // C++ lists are ordered, so the list will always push to the back and
                        // remove at the front to ensure ordering
                        if (t.transactionType == DATA_READ)
                        {
                                pendingReadRequests[t.address].push_back(cycle); 
                        }
                        else if (t.transactionType == DATA_WRITE)
                        {
                                pendingWriteRequests[t.address].push_back(cycle); 
                        }
                        else
                        {
                                ERROR("This should never happen"); 
                                exit(-1);
                        }
                }

                void read_complete(unsigned id, uint64_t address, uint64_t done_cycle)
                {
                        map<uint64_t, list<uint64_t> >::iterator it;
                        it = pendingReadRequests.find(address); 
                        if (it == pendingReadRequests.end())
                        {
                                ERROR("Cant find a pending read for this one"); 
                                exit(-1);
                        }
                        else
                        {
                                if (it->second.size() == 0)
                                {
                                        ERROR("Nothing here, either"); 
                                        exit(-1); 
                                }
                        }

                        uint64_t added_cycle = pendingReadRequests[address].front();
                        uint64_t latency = done_cycle - added_cycle;

                        pendingReadRequests[address].pop_front();
                        cout << "Read Callback:  0x"<< std::hex << address << std::dec << " latency="<<latency<<"cycles ("<< done_cycle<< "->"<<added_cycle<<")"<<endl;
                }
                void write_complete(unsigned id, uint64_t address, uint64_t done_cycle)
                {
                        map<uint64_t, list<uint64_t> >::iterator it;
                        it = pendingWriteRequests.find(address); 
                        if (it == pendingWriteRequests.end())
                        {
                                ERROR("Cant find a pending read for this one"); 
                                exit(-1);
                        }
                        else
                        {
                                if (it->second.size() == 0)
                                {
                                        ERROR("Nothing here, either"); 
                                        exit(-1); 
                                }
                        }

                        uint64_t added_cycle = pendingWriteRequests[address].front();
                        uint64_t latency = done_cycle - added_cycle;

                        pendingWriteRequests[address].pop_front();
                        cout << "Write Callback: 0x"<< std::hex << address << std::dec << " latency="<<latency<<"cycles ("<< done_cycle<< "->"<<added_cycle<<")"<<endl;
                }
};
#endif

void usage()
{
        cout << "DRAMSim2 Usage: " << endl;
        cout << "DRAMSim -t tracefile -s system.ini -d ini/device.ini [-c #] [-p pwd] [-q] [-S 2048] [-n] [-o OPTION_A=1234,tRC=14,tFAW=19]" <<endl;
        cout << "\t-t, --tracefile=FILENAME \tspecify a tracefile to run  "<<endl;
        cout << "\t-s, --systemini=FILENAME \tspecify an ini file that describes the memory system parameters  "<<endl;
        cout << "\t-d, --deviceini=FILENAME \tspecify an ini file that describes the device-level parameters"<<endl;
        cout << "\t-c, --numcycles=# \t\tspecify number of cycles to run the simulation for [default=30] "<<endl;
        cout << "\t-q, --quiet \t\t\tflag to suppress simulation output (except final stats) [default=no]"<<endl;
        cout << "\t-o, --option=OPTION_A=234,tFAW=14\t\t\toverwrite any ini file option from the command line"<<endl;
        cout << "\t-p, --pwd=DIRECTORY\t\tSet the working directory (i.e. usually DRAMSim directory where ini/ and results/ are)"<<endl;
        cout << "\t-S, --size=# \t\t\tSize of the memory system in megabytes [default=2048M]"<<endl;
        cout << "\t-n, --notiming \t\t\tDo not use the clock cycle information in the trace file"<<endl;
        cout << "\t-v, --visfile \t\t\tVis output filename"<<endl;
}
#endif

void *parseTraceFileLine(string &line, uint64_t &addr, enum TransactionType &transType, uint64_t &clockCycle, TraceType type, bool useClockCycle)
{
        size_t previousIndex=0;
        size_t spaceIndex=0;
        uint64_t *dataBuffer = NULL;
        string addressStr="", cmdStr="", dataStr="", ccStr="";

        switch (type)
        {
        case k6:
        {
                spaceIndex = line.find_first_of(" ", 0);

                addressStr = line.substr(0, spaceIndex);
                previousIndex = spaceIndex;

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                cmdStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);
                previousIndex = line.find_first_of(" ", spaceIndex);

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                ccStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);

                if (cmdStr.compare("P_MEM_WR")==0 ||
                        cmdStr.compare("BOFF")==0)
                {
                        transType = DATA_WRITE;
                }
                else if (cmdStr.compare("P_FETCH")==0 ||
                         cmdStr.compare("P_MEM_RD")==0 ||
                         cmdStr.compare("P_LOCK_RD")==0 ||
                         cmdStr.compare("P_LOCK_WR")==0)
                {
                        transType = DATA_READ;
                }
                else
                {
                        ERROR("== Unknown Command : "<<cmdStr);
                        exit(0);
                }

                istringstream a(addressStr.substr(2));//gets rid of 0x
                a>>hex>>addr;

                //if this is set to false, clockCycle will remain at 0, and every line read from the trace
                //  will be allowed to be issued
                if (useClockCycle)
                {
                        istringstream b(ccStr);
                        b>>clockCycle;
                }
                break;
        }
        case mase:
        {
                spaceIndex = line.find_first_of(" ", 0);

                addressStr = line.substr(0, spaceIndex);
                previousIndex = spaceIndex;

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                cmdStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);
                previousIndex = line.find_first_of(" ", spaceIndex);

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                ccStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);

                if (cmdStr.compare("IFETCH")==0||
                        cmdStr.compare("READ")==0)
                {
                        transType = DATA_READ;
                }
                else if (cmdStr.compare("WRITE")==0)
                {
                        transType = DATA_WRITE;
                }
                else
                {
                        ERROR("== Unknown command in tracefile : "<<cmdStr);
                }

                istringstream a(addressStr.substr(2));//gets rid of 0x
                a>>hex>>addr;

                //if this is set to false, clockCycle will remain at 0, and every line read from the trace
                //  will be allowed to be issued
                if (useClockCycle)
                {
                        istringstream b(ccStr);
                        b>>clockCycle;
                }

                break;
        }
        case misc:
                spaceIndex = line.find_first_of(" ", spaceIndex+1);
                if (spaceIndex == string::npos)
                {
                        ERROR("Malformed line: '"<< line <<"'");
                }

                addressStr = line.substr(previousIndex,spaceIndex);
                previousIndex=spaceIndex;

                spaceIndex = line.find_first_of(" ", spaceIndex+1);
                if (spaceIndex == string::npos)
                {
                        cmdStr = line.substr(previousIndex+1);
                }
                else
                {
                        cmdStr = line.substr(previousIndex+1,spaceIndex-previousIndex-1);
                        dataStr = line.substr(spaceIndex+1);
                }

                //convert address string -> number
                istringstream b(addressStr.substr(2)); //substr(2) chops off 0x characters
                b >>hex>> addr;

                // parse command
                if (cmdStr.compare("read") == 0)
                {
                        transType=DATA_READ;
                }
                else if (cmdStr.compare("write") == 0)
                {
                        transType=DATA_WRITE;
                }
                else
                {
                        ERROR("INVALID COMMAND '"<<cmdStr<<"'");
                        exit(-1);
                }
                if (SHOW_SIM_OUTPUT)
                {
                        DEBUGN("ADDR='"<<hex<<addr<<dec<<"',CMD='"<<transType<<"'");//',DATA='"<<dataBuffer[0]<<"'");
                }

                //parse data
                //if we are running in a no storage mode, don't allocate space, just return NULL
#ifndef NO_STORAGE
                if (dataStr.size() > 0 && transType == DATA_WRITE)
                {
                        // 32 bytes of data per transaction
                        dataBuffer = (uint64_t *)calloc(sizeof(uint64_t),4);
                        size_t strlen = dataStr.size();
                        for (int i=0; i < 4; i++)
                        {
                                size_t startIndex = i*16;
                                if (startIndex > strlen)
                                {
                                        break;
                                }
                                size_t charsLeft = min(((size_t)16), strlen - startIndex + 1);
                                string piece = dataStr.substr(i*16,charsLeft);
                                istringstream iss(piece);
                                iss >> hex >> dataBuffer[i];
                        }
                        PRINTN("\tDATA=");
                        BusPacket::printData(dataBuffer);
                }

                PRINT("");
#endif
                break;
        }
        return dataBuffer;
}

#ifndef _SIM_

void alignTransactionAddress(Transaction &trans)
{
        // zero out the low order bits which correspond to the size of a transaction

        unsigned throwAwayBits = THROW_AWAY_BITS;

        trans.address >>= throwAwayBits;
        trans.address <<= throwAwayBits;
}

/** 
 * Override options can be specified on the command line as -o key1=value1,key2=value2
 * this method should parse the key-value pairs and put them into a map 
 **/ 
IniReader::OverrideMap *parseParamOverrides(const string &kv_str)
{
        IniReader::OverrideMap *kv_map = new IniReader::OverrideMap(); 
        size_t start = 0, comma=0, equal_sign=0;
        // split the commas if they are there
        while (1)
        {
                equal_sign = kv_str.find('=', start); 
                if (equal_sign == string::npos)
                {
                        break;
                }

                comma = kv_str.find(',', equal_sign);
                if (comma == string::npos)
                {
                        comma = kv_str.length();
                }

                string key = kv_str.substr(start, equal_sign-start);
                string value = kv_str.substr(equal_sign+1, comma-equal_sign-1); 

                (*kv_map)[key] = value; 
                start = comma+1;

        }
        return kv_map; 
}

int main(int argc, char **argv)
{
        int c;
        TraceType traceType;
        string traceFileName;
        string systemIniFilename("system.ini");
        string deviceIniFilename;
        string pwdString;
        string *visFilename = NULL;
        unsigned megsOfMemory=2048;
        bool useClockCycle=true;

        IniReader::OverrideMap *paramOverrides = NULL; 

        unsigned numCycles=1000;
        //getopt stuff
        while (1)
        {
                static struct option long_options[] =
                {
                        {"deviceini", required_argument, 0, 'd'},
                        {"tracefile", required_argument, 0, 't'},
                        {"systemini", required_argument, 0, 's'},

                        {"pwd", required_argument, 0, 'p'},
                        {"numcycles",  required_argument,        0, 'c'},
                        {"option",  required_argument,        0, 'o'},
                        {"quiet",  no_argument, &SHOW_SIM_OUTPUT, 'q'},
                        {"help", no_argument, 0, 'h'},
                        {"size", required_argument, 0, 'S'},
                        {"visfile", required_argument, 0, 'v'},
                        {0, 0, 0, 0}
                };
                int option_index=0; //for getopt
                c = getopt_long (argc, argv, "t:s:c:d:o:p:S:v:qn", long_options, &option_index);
                if (c == -1)
                {
                        break;
                }
                switch (c)
                {
                case 0: //TODO: figure out what the hell this does, cuz it never seems to get called
                        if (long_options[option_index].flag != 0) //do nothing on a flag
                        {
                                printf("setting flag\n");
                                break;
                        }
                        printf("option %s",long_options[option_index].name);
                        if (optarg)
                        {
                                printf(" with arg %s", optarg);
                        }
                        printf("\n");
                        break;
                case 'h':
                        usage();
                        exit(0);
                        break;
                case 't':
                        traceFileName = string(optarg);
                        break;
                case 's':
                        systemIniFilename = string(optarg);
                        break;
                case 'd':
                        deviceIniFilename = string(optarg);
                        break;
                case 'c':
                        numCycles = atoi(optarg);
                        break;
                case 'S':
                        megsOfMemory=atoi(optarg);
                        break;
                case 'p':
                        pwdString = string(optarg);
                        break;
                case 'q':
                        SHOW_SIM_OUTPUT=false;
                        break;
                case 'n':
                        useClockCycle=false;
                        break;
                case 'o':
                        paramOverrides = parseParamOverrides(string(optarg)); 
                        break;
                case 'v':
                        visFilename = new string(optarg);
                        break;
                case '?':
                        usage();
                        exit(-1);
                        break;
                }
        }

        // get the trace filename
        string temp = traceFileName.substr(traceFileName.find_last_of("/")+1);

        //get the prefix of the trace name
        temp = temp.substr(0,temp.find_first_of("_"));
        if (temp=="mase")
        {
                traceType = mase;
        }
        else if (temp=="k6")
        {
                traceType = k6;
        }
        else if (temp=="misc")
        {
                traceType = misc;
        }
        else
        {
                ERROR("== Unknown Tracefile Type : "<<temp);
                exit(0);
        }


        // no default value for the default model name
        if (deviceIniFilename.length() == 0)
        {
                ERROR("Please provide a device ini file");
                usage();
                exit(-1);
        }


        //ignore the pwd argument if the argument is an absolute path
        if (pwdString.length() > 0 && traceFileName[0] != '/')
        {
                traceFileName = pwdString + "/" +traceFileName;
        }

        DEBUG("== Loading trace file '"<<traceFileName<<"' == ");

        ifstream traceFile;
        string line;


        MultiChannelMemorySystem *memorySystem = new MultiChannelMemorySystem(deviceIniFilename, systemIniFilename, pwdString, traceFileName, megsOfMemory, visFilename, paramOverrides);
        // set the frequency ratio to 1:1
        memorySystem->setCPUClockSpeed(0); 

        // don't need this anymore 
        delete paramOverrides;


#ifdef RETURN_TRANSACTIONS
        TransactionReceiver transactionReceiver; 
        /* create and register our callback functions */
        Callback_t *read_cb = new Callback<TransactionReceiver, void, unsigned, uint64_t, uint64_t>(&transactionReceiver, &TransactionReceiver::read_complete);
        Callback_t *write_cb = new Callback<TransactionReceiver, void, unsigned, uint64_t, uint64_t>(&transactionReceiver, &TransactionReceiver::write_complete);
        memorySystem->RegisterCallbacks(read_cb, write_cb, NULL);
#endif


        uint64_t addr;
        uint64_t clockCycle=0;
        enum TransactionType transType;

        void *data = NULL;
        int lineNumber = 0;
        Transaction *trans=NULL;
        bool pendingTrans = false;

        traceFile.open(traceFileName.c_str());

        if (!traceFile.is_open())
        {
                cout << "== Error - Could not open trace file"<<endl;
                exit(0);
        }

        for (size_t i=0;i<numCycles;i++)
        {
                if (!pendingTrans)
                {
                        if (!traceFile.eof())
                        {
                                getline(traceFile, line);

                                if (line.size() > 0)
                                {
                                        data = parseTraceFileLine(line, addr, transType,clockCycle, traceType,useClockCycle);
                                        trans = new Transaction(transType, addr, data);
                                        alignTransactionAddress(*trans); 

                                        if (i>=clockCycle)
                                        {
                                                if (!(*memorySystem).addTransaction(trans))
                                                {
                                                        pendingTrans = true;
                                                }
                                                else
                                                {
#ifdef RETURN_TRANSACTIONS
                                                        transactionReceiver.add_pending(trans, i); 
#endif
                                                        // the memory system accepted our request so now it takes ownership of it
                                                        trans = NULL; 
                                                }
                                        }
                                        else
                                        {
                                                pendingTrans = true;
                                        }
                                }
                                else
                                {
                                        DEBUG("WARNING: Skipping line "<<lineNumber<< " ('" << line << "') in tracefile");
                                }
                                lineNumber++;
                        }
                        else
                        {
                                //we're out of trace, set pending=false and let the thing spin without adding transactions
                                pendingTrans = false; 
                        }
                }

                else if (pendingTrans && i >= clockCycle)
                {
                        pendingTrans = !(*memorySystem).addTransaction(trans);
                        if (!pendingTrans)
                        {
#ifdef RETURN_TRANSACTIONS
                                transactionReceiver.add_pending(trans, i); 
#endif
                                trans=NULL;
                        }
                }

                (*memorySystem).update();
        }

        traceFile.close();
        memorySystem->printStats(true);
        // make valgrind happy
        if (trans)
        {
                delete trans;
        }
        delete(memorySystem);
}
#endif }}
          # Ruleset file that will determine what checks will be run
          ruleset: NativeRecommendedRules.ruleset

      # Upload SARIF file to GitHub Code Scanning Alerts
      - name: Upload SARIF to GitHub
        uses: github/codeql-action/upload-sarif@v2
        with: 
//Transaction.cpp
//
//Class file for transaction object
//        Transaction is considered requests sent from the CPU to
//        the memory controller (read, write, etc.)...

#include "Transaction.h"
#include "PrintMacros.h"

using std::endl;
using std::hex; 
using std::dec; 

namespace DRAMSim {

Transaction::Transaction(TransactionType transType, uint64_t addr, void *dat) :
        transactionType(transType),
        address(addr),
        data(dat)
{}

Transaction::Transaction(const Transaction &t)
        : transactionType(t.transactionType)
          , address(t.address)
          , data(NULL)
          , timeAdded(t.timeAdded)
          , timeReturned(t.timeReturned)
{
        #ifndef NO_STORAGE
        ERROR("Data storage is really outdated and these copies happen in an \n improper way, which will eventually cause problems. Please send an \n email to dramninjas [at] gmail [dot] com if you need data storage");
        abort(); 
        #endif
}

ostream &operator<<(ostream &os, const Transaction &t)
{
        if (t.transactionType == DATA_READ)
        {
                os<<"T [Read] [0x" << hex << t.address << "]" << dec <<endl;
        }
        else if (t.transactionType == DATA_WRITE)
        {
                os<<"T [Write] [0x" << hex << t.address << "] [" << dec << t.data << "]" <<endl;
        }
        else if (t.transactionType == RETURN_DATA)
        {
                os<<"T [Data] [0x" << hex << t.address << "] [" << dec << t.data << "]" <<endl;
        }
        return os; 
}
}

          sarif_file: ${{ 
#ifndef TRANSACTION_H
#define TRANSACTION_H

//Transaction.h
//
//Header file for transaction object

#include "SystemConfiguration.h"
#include "BusPacket.h"

using std::ostream; 

namespace DRAMSim
{
enum TransactionType
{
        DATA_READ,
        DATA_WRITE,
        RETURN_DATA
};

class Transaction
{
        Transaction();
public:
        //fields
        TransactionType transactionType;
        uint64_t address;
        void *data;
        uint64_t timeAdded;
        uint64_t timeReturned;


        friend ostream &operator<<(ostream &os, const Transaction &t);
        //functions
        Transaction(TransactionType transType, uint64_t addr, void *data);
        Transaction(const Transaction &t);

        BusPacketType getBusPacketType()
        {
                switch (transactionType)
                {
                        case DATA_READ:
                        if (rowBufferPolicy == ClosePage)
                        {
                                return READ_P;
                        }
                        else if (rowBufferPolicy == OpenPage)
                        {
                                return READ; 
                        }
                        else
                        {
                                ERROR("Unknown row buffer policy");
                                abort();
                        }
                        break;
                case DATA_WRITE:
                        if (rowBufferPolicy == ClosePage)
                        {
                                return WRITE_P;
                        }
                        else if (rowBufferPolicy == OpenPage)
                        {
                                return WRITE; 
                        }
                        else
                        {
                                ERROR("Unknown row buffer policy");
                                abort();
                        }
                        break;
                default:
                        ERROR("This transaction type doesn't have a corresponding bus packet type");
                        abort();
                }
        }
};

}

#endif
 }}

      # Upload SARIF file as an Artifact to download and view
      # - name: Upload SARIF as an Artifact
      #   uses: actions/upload-artifact@v3
      #   with: #!/bin/bash 

#script to add or remove the GPL header from all *.cpp and *.h files
# in a directory. Usage:
#
# ./addgpl.sh [add|remove] directory/


DIRECTORY=$2

if [ -d "$DIRECTORY" ]; then 
        FILES=`find $DIRECTORY -iname '*.h' -or -iname '*.cpp'`
else
        echo "Bad directory"
        exit
fi

if [ "$1" == "add" ] ; then 
        for f in $FILES
        do
                echo "adding to $f"
                mv $f $f.tmp
                cat gpl.txt $f.tmp > $f
        done
elif [ "$1" == "remove" ] ; then 
        NUMLINES=`wc -l gpl.txt | cut -f1 -d' '`
        for f in $FILES
        do 
                HEADER=`head --lines=$NUMLINES $f | diff -w gpl.txt -`
                if [ -z "$HEADER" ] ; then 
                        echo "deleting from $f"
                        mv $f $f.tmp
                        tail --lines=+$NUMLINES $f.tmp > $f
                else 
                        echo "header does not match, skipping $f"
                fi 

        done
fi


      #     name: #!/usr/bin/python 
"""

This script generates a series of commands to do parameter sweeps. One way to
use this script is to generate a big matrix of configurations and then run them
on different binaries to diff the output.  This can be used as a poor man's
regression test when doing code cleanups (i.e. where functionality is not
supposed to change as a result of a commit.

Or, if you just set a single binary and comment out the diff stuff at the
bottom, it is just a convenient way to do parameter sweeps. 

Since this uses the command line overrides (-o flag), it needs a fairly recent
commit of DRAMSim2
( see: https://github.com/dramninjasUMD/DRAMSim2/commit/e46f525bd274a0b3312002dce3efe83c769ea2ce )

Just redirect the output of this command to a file and then run it in bash. 

"""

import itertools 

parameters = {'QUEUING_STRUCTURE': ['per_rank', 'per_rank_per_bank'],
                                        'ROW_BUFFER_POLICY': ['open_page', 'close_page'],
                                        'SCHEDULING_POLICY': ['rank_then_bank_round_robin','bank_then_rank_round_robin']
                                        }

devices = ['DDR3_micron_64M_8B_x4_sg15.ini', 'DDR2_micron_32M_4B_x4_sg3E.ini'];

traces = ['k6_bsc_vector1.trc', 'k6_video_tracking_128kL2_trace.trc',  'k6_aoe_02_short.trc']
binaries = ['DRAMSim.master', 'DRAMSim.cleanup']

dramsim_flags = '-c 2000000 -n -S 8192 -q '

# get the parameter permutations

master_list = []
for k,v in parameters.iteritems():
#        print v
        master_list.append(v)

paramOverrideList=[]
for i in itertools.product(*master_list):
        tmp=[]
        for j,param in enumerate(i):
                tmp.append("%s=%s"%(parameters.keys()[j],param))
        paramOverrideList.append(",".join(tmp))
#print paramOverrideList

print "#!/bin/bash"
print "rm DRAMSim.*.vis"
i=0
for trace in traces: 
        for device in devices:
                for paramOverrides in paramOverrideList:
                        for executable in binaries:
                                output_file = "%s_%d"%(executable, i)
                                print "./%s -s system.ini -d ini/%s -t traces/%s -o %s %s -v %s &"%(executable, device, trace, paramOverrides, dramsim_flags, output_file)
                        i+=1

print "echo -n waiting"
print "wait"
print "echo OK"
print "echo Starting diff phase"
for x in range(i):
        diff_args="%s_%d.vis %s_%d.vis"%(binaries[0],x,binaries[1],x)
        print "echo %s_%d.vis and %s_%d.vis:"%(binaries[0],x,binaries[1],x)
        print "is_different=`diff -q %s`"%(diff_args)
        print "if [ -n \"$is_different\" ] ; then"        
        print "diff -u %s"%(diff_args); 
        print "fi"
      #     path: ${{ ; COPY THIS FILE AND MODIFY IT TO SUIT YOUR NEEDS
[driver]timer=timer.drv
[110Enh]
NUM_CHANS=1                                                                ; number of *logically independent* channels (i.e. each with a separate memory controller); should be a power of 2
JEDEC_DATA_BUS_BITS=64                                  ; Always 64 for DDRx; if you want multiple *ganged* channels, set this to N*64
TRANS_QUEUE_DEPTH=32                                        ; transaction queue, i.e., CPU-level commands such as:  READ 0xbeef
CMD_QUEUE_DEPTH=32                                                ; command queue, i.e., DRAM-level commands such as: CAS 544, RAS 4
EPOCH_LENGTH=100000                                                ; length of an epoch in cycles (granularity of simulation)
ROW_BUFFER_POLICY=open_page                 ; close_page or open_page
ADDRESS_MAPPING_SCHEME=scheme2        ;valid schemes 1-7; For multiple independent channels, use scheme7 since it has the most parallelism 
SCHEDULING_POLICY=rank_then_bank_round_robin  ; bank_then_rank_round_robin or rank_then_bank_round_robin 
QUEUING_STRUCTURE=per_rank                        ;per_rank or per_rank_per_bank

;for true/false, please use all lowercase
DEBUG_TRANS_Q=false
DEBUG_CMD_Q=false
DEBUG_ADDR_MAP=false
DEBUG_BUS=false
DEBUG_BANKSTATE=false
DEBUG_BANKS=false
DEBUG_POWER=false
VIS_FILE_OUTPUT=true

USE_LOW_POWER=true                                         ; go into low power mode when idle?
VERIFICATION_OUTPUT=false                         ; should be false for normal operation
TOTAL_ROW_ACCESSES=4        ;                                 maximum number of open page requests to send to the same row before forcing a row close (to prevent starvation) }}

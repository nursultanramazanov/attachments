# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs

name: Node.js CI

on: {
  "date": {
    "type": "date",
    "units": "utc"
  },
  "garageDoor": {
    "type": "bool"
  }
}
  push: // @flow
import SocketIO from 'socket.io'
import NedDB from 'nedb'
import Queue from 'queue'
import { Gpio } from 'onoff' // https://www.npmjs.com/package/onoff#writesyncvalue & https://pinout.xyz/pinout/pin13_gpio27
import * as Mam from '@iftt/mam' // https://devnet.thetangle.org/mam/
import TryteBuffer from '@iftt/tryte-buffer'
import FpgaProtocol from '@iftt/icc-fpga-protocol'
import garageProtocol from './garageProtocol.json'
import ServiceManager from './serviceManager'

import type { Instructions } from './serviceManager'

const debug = require('debug')('garage-client')

require('dotenv').config() // .env variables

type Options = {
  allowedOrigins: [string], // this is for talking with the web, you probably only want to allow your server
  tangleLocation: string,
  fpgaPort: string
}

class GarageClient extends FpgaProtocol {
  socket: SocketIO
  nedDB: NedDB
  reedSwitch: Gpio
  garageOpenerCloser: Gpio
  switchStatus: number
  provider: string
  mamState: Mam
  minWeightMagnitude: number
  serviceManager: ServiceManager
  garageProtocol: TryteBuffer
  jobQueue: Queue
  _onPortOpen: Function
  constructor (options: Options) {
    super(options.fpgaPort)
    debug('creating GarageClient')
    // server
    let origins = (options.allowedOrigins) ? options.allowedOrigins : (process.env.ORIGINS) ? process.env.ORIGINS : ['*:*']
    if (typeof origins === 'string') { origins = origins.split(',') }
    this.socket = new SocketIO(8001, { origins })
    this.setupIO()
    this.nedDB = new NedDB({ filename: './client.db', autoload: true })
    // pi GPIO prep
    this.reedSwitch = new Gpio(22, 'in', 'both', { debounceTimeout: 1250 }) // add 1 second-ish 'debounce' timer to remove an anomolies as reed switch activates. Time is not really a huge deal here, so we should be safe rather then sorry.
    this.garageOpenerCloser = new Gpio(27, 'out')
    this.switchStatus = this.reedSwitch.readSync()
    // iota tangle
    this.provider = (!options.tangleLocation) ? 'https://nodes.devnet.iota.org' : options.tangleLocation
    this.setupMaM()
    // Get active service(s) from db if it/they exist
    this.nedDB.findOne({ key: 'services' }, (err, doc) => {
      if (!err && doc) {
        let instructions: [Instructions] = doc.services
        this.serviceManager = new ServiceManager(instructions, this._actions.bind(this))
      } else {
        this.serviceManager = new ServiceManager(null, this._actions.bind(this))
      }
    })
    this.garageProtocol = new TryteBuffer(garageProtocol)
    // MaM attach queue handler
    this.jobQueue = Queue({ concurrency: 1, timeout: 1000 * 25, autostart: true }) // if the mam isn't posted in 25 seconds, give up. Only allow one job at a time and auto run them
  }

  deconstruct () {
    debug('deconstruct')
    this.socket.close()
  }

  _actions (action: { key: string, value: any }) {
    debug('_actions')
    // this device only has "date" and "garageDoor", thus we only have to worry about "garageDoor"
    let changeGarageState = false
    if (action.key === 'garageDoor') {
      if (action.value === 1 && this.switchStatus === parseInt(process.env.GARAGE_OPEN_STATE)) { // we want the garage to be closed
        changeGarageState = true
      } else if (action.value === 0 && this.switchStatus !== parseInt(process.env.GARAGE_OPEN_STATE)) { // we want the garage to be open
        changeGarageState = true
      }
    }
    if (action.key === 'garageDoor' && changeGarageState) { this.openCloseGarage() }
  }

  program (instructions: [Instructions]) {
    debug('program')
    const self = this
    self.serviceManager.clearServices()
    if (Array.isArray(instructions)) {
      instructions.forEach((instruction: Instructions) => self.serviceManager.addService(instruction))
    }
    self.nedDB.update({ key: 'services' }, { key: 'services', services: instructions }, { upsert: true })
  }

  setupIO () {
    debug('setupIO')
    const self = this
    self.socket.on('connection', (socket) => {
      socket.emit('ready', { id: socket.id, clientId: process.env.DEVICE_ID })
      socket.on('program', self.program.bind(self))
    })
  }

  setupMaM () {
    debug('setupMaM')
    const self = this
    if (this.provider === 'https://nodes.devnet.iota.org') {
      self.minWeightMagnitude = 9 // testnet difficulty
    } else {
      self.minWeightMagnitude = 14
    }
    self.mamState = Mam.init({
      provider: self.provider,
      attachToTangle: self.attachToTangle.bind(self) // we are using the fpga prepared attachment :D
    }, process.env.CLIENT_TANGLE_SEED, 2)
    self.nedDB.findOne({ key: 'mamstate' }, (err, doc) => {
      if (!err && doc) {
        self.mamState = doc.state
      } else {
        self.mamState = Mam.changeMode(self.mamState, 'public')
      }
    })
  }

  _onPortOpen () { // called when fpga device is ready...
    debug('_onPortOpen')
    this._watchGarageDoor()
  }

  openCloseGarage () {
    debug('openCloseGarage')
    const self = this
    self.garageOpenerCloser.writeSync(1)
    setTimeout(() => {
      self.garageOpenerCloser.writeSync(0)
    }, 750)
  }

  getRoot () {
    debug('getRoot')
    return this.mamState.channel.next_root
  }

  _watchGarageDoor () {
    debug('_watchGarageDoor')
    const self = this
    self.reedSwitch.watch((err: null | string, status: number) => {
      if (err) { console.log(err) } else if (status !== self.switchStatus) { // watch randomly returns values outside of true changes, and thus can be the same value
        self.switchStatus = status
        if (status === process.env.GARAGE_OPEN_STATE) { self.onGarageOpen() } else { self.onGarageClose() }
      }
    })
  }

  onGarageOpen () {
    debug('onGarageOpen')
    const self = this
    self.jobQueue.push(function () { self._publish(false, new Date()) })
  }

  onGarageClose () {
    debug('onGarageClose')
    const self = this
    self.jobQueue.push(function () { self._publish(true, new Date()) })
  }

  async _publish (garageDoor: boolean, date: Date) {
    debug('_publish')
    const self = this
    try {
      const trytes = self.garageProtocol.encode({
        date,
        garageDoor
      })
      const message = Mam.create(self.mamState, trytes)
      await Mam.attach(message.payload, message.address, 3, self.minWeightMagnitude)
      // update and store the state
      self.mamState = message.state
      this.nedDB.update({ key: 'mamstate' }, { key: 'mamstate', state: self.mamState }, { upsert: true })
      console.log('Client Root:', message.root)
    } catch (err) {}
  }
}

export default GarageClient
    branches: [ "main" ]
  pull_request: // @flow
import axios from 'axios'
import ProgramGenerator from '@iftt/program-generator'

const debug = require('debug')('service-manager')

type Service = {
  protocol: { string: { string: any } },
  getRoot: string
}

type Program = {
  condition: Object,
  action: { key: string, value: any }
}

export type Instructions = {
  serviceId: string,
  service: Service,
  program: Program
}

class ServiceManager {
  services: { string: ProgramGenerator }
  action: Function
  runningServices: number
  updateIp: Function
  addService: Function
  constructor (instructions?: null | [Instructions], action: Function) {
    debug('creating ServiceManager')
    const self = this
    self.runningServices = 0
    self.action = action
    self.services = {}
    if (Array.isArray(instructions)) { instructions.forEach(instruction => self.addService(instruction)) }
    self.updateIp = setInterval(self.updateLocation, 1000 * 60 * 15) // update every 15 minutes incase of
    self.updateLocation()
  }

  deconstruct () {
    debug('deconstruct')
    this.clearServices()
    clearInterval(this.updateIp)
  }

  updateLocation () {
    debug('updateLocation')
    // send a ping every 5 min so that the server knows the device's ip
    axios
      .post(`http://${(process.env.SERVER) ? process.env.SERVER : 'localhost'}/login`)
      .then((res) => {
        const token = res.data
        axios
          .post(`http://${(process.env.SERVER) ? process.env.SERVER : 'localhost'}/device/updateDeviceLocation`, {
            token,
            deviceId: process.env.DEVICE_ID
          })
          .catch((err) => {
            console.log(err)
          })
      })
      .catch((err) => {
        console.log(err)
      })
  }

  getServiceCount () {
    debug('getServiceCount')
    return this.runningServices
  }

  clearServices () {
    debug('clearServices')
    for (let serviceId in this.services) { this.removeServiceById(serviceId) }
  }

  removeServiceById (serviceId: string) {
    debug('removeServiceById')
    this.services[serviceId].deconstruct()
    this.services[serviceId].removeListener('action', this.action)
    delete this.services[serviceId]
    this.runningServices--
  }

  addService (instruction: Instructions) {
    debug('addService')
    this.services[instruction.serviceId] = new ProgramGenerator(instruction)
    this.services[instruction.serviceId].on('action', this.action)
    this.runningServices++
  }
}

export default ServiceManager
    branches: [ "main" ]

jobs: const test = require('tape')

test('timing test', function (t) {
  t.plan(1)

  t.equal(typeof Date.now, 'function')
})
  build: {
  "serviceId": "1234567",
  "service": {
    "protocol": {
      "date": {
        "type": "date",
        "units": "utc"
      },
      "location": {
        "type": "geo"
      },
      "winddir": {
        "type": "uint16",
        "units": "degrees"
      },
      "windspeedmph": {
        "type": "uint16",
        "units": "mph",
        "precision": 1
      },
      "windgustmph": {
        "type": "uint16",
        "units": "mph",
        "precision": 1
      },
      "maxdailygust": {
        "type": "uint16",
        "units": "mph",
        "precision": 1
      },
      "tempf": {
        "type": "uint16",
        "units": "fahrenheit",
        "precision": 1
      },
      "lastRain": {
        "type": "date",
        "units": "utc"
      },
      "hourlyrainin": {
        "type": "uint16",
        "units": "in/hr",
        "precision": 2
      },
      "eventrainin": {
        "type": "uint16",
        "units": "in/hr",
        "precision": 2
      },
      "dailyrainin": {
        "type": "uint16",
        "units": "in",
        "precision": 2
      },
      "weeklyrainin": {
        "type": "uint16",
        "units": "in",
        "precision": 2
      },
      "monthlyrainin": {
        "type": "uint16",
        "units": "in",
        "precision": 2
      },
      "totalrainin": {
        "type": "uint32",
        "units": "in",
        "precision": 2
      },
      "baromrelin": {
        "type": "uint16",
        "units": "inHg",
        "precision": 2
      },
      "baromabsin": {
        "type": "uint16",
        "units": "inHg",
        "precision": 2
      },
      "humidity": {
        "type": "uint8",
        "units": "percent"
      },
      "tempinf": {
        "type": "uint16",
        "units": "fahrenheit",
        "precision": 1
      },
      "humidityin": {
        "type": "uint8",
        "units": "in"
      },
      "uv": {
        "type": "uint16",
        "units": "index"
      },
      "solarradiation": {
        "type": "uint32",
        "units": "W/m^2",
        "precision": 1
      },
      "feelsLike": {
        "type": "uint16",
        "units": "fahrenheit",
        "precision": 1
      },
      "dewPoint": {
        "type": "uint16",
        "units": "fahrenheit",
        "precision": 2
      }
    },
    "getRoot": "http://192.168.0.46:3001/weather/getNextRoot"
  },
  "program": {
    "condition": {
      "and": [
        {"==": [{"var":"previous.eventrainin"}, 0]},
        {"!=": [{"var":"current.eventrainin"}, 0]}
      ]
    },
    "action": { "key": "garageDoor", "value": 1 }
  }
}

    runs-on: # yarn
yarn add @iftt/garage-client
# npm
npm i --save @iftt/garage-client

    strategy: API_TOKEN=1234567890
CLIENT_SECRET=TEST9SECRET
CLIENT_TANGLE_SEED=0000JYXUUZVHMCDLNEFA9ZBRM00000PJFLEPMNEFWXOHCTVZWBLCLE9HUOLYLWS9NMJDOKQMOKINXQA
DEVICE_ID=477a5971-3e9d-4eae-98fe-22cb4c153dc1
SERVER=192.168.0.46:3001
GARAGE_OPEN_STATE=1
# Linux & OS X
uuidgen
# Linux
cat /dev/urandom |tr -dc A-Z9|head -c${1:-81}
# OS X
cat /dev/urandom |LC_ALL=C tr -dc 'A-Z9' | fold -w 81 | head -n 1
# clone the repo
git clone https://github.com/iftt/garage-client.git
# install dependences
yarn # or npm install
# run the client
node runGarageClient.js
// ES6
import '@iftt/garage-client'
// ES5
const GarageClient = require('@iftt/garage-client').default

new GarageClient({
  tangleLocation: 'https://nodes.devnet.iota.org',
  fpgaPort: '/dev/ttyUSB1'
})
      matrix: DEBUG=garage-client,service-manager,icc-fpga-protocol,tryte-buffer,tryte-encode-decode node x
# or all
DEBUG=* node x
        node-version: [14.x, 16.x, 18.x]
        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/

    steps: ISC License (ISC)
  Copyright 2019 - IFTT

  Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
    - uses: actions/checkout@v4
    - name: Use Node.js ${{ #!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# npx pretty-quick --staged }}
      uses: actions/setup-node@v3
      with: {
  "label": "✅ Complete Use Cases",
  "position": 8
}
        node-version: ${{ {
  "label": "GitHub Exporter",
  "position": 2
} }}
        cache: 'npm'
    - run: npm ci
    - run: npm run build --if-present
    - run: npm test

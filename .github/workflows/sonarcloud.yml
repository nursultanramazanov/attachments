# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# This workflow helps you trigger a SonarCloud analysis of your code and populates
# GitHub Code Scanning alerts with the vulnerabilities found.
# Free for open source project.

# 1. Login to SonarCloud.io using your GitHub account

# 2. Import your project on SonarCloud
#     * Add your GitHub organization first, then add your repository as a new project.
#     * Please note that many languages are eligible for automatic analysis,
#       which means that the analysis will start automatically without the need to set up GitHub Actions.
#     * This behavior can be changed in Administration > Analysis Method.
#
# 3. Follow the SonarCloud in-product tutorial
#     * a. Copy/paste the Project Key and the Organization Key into the args parameter below
#          (You'll find this information in SonarCloud. Click on "Information" at the bottom left)
#
#     * b. Generate a new token and add it to your Github repository's secrets using the name SONAR_TOKEN
#          (On SonarCloud, click on your avatar on top-right > My account > Security
#           or go directly to https://sonarcloud.io/account/security/)

# Feel free to take a look at our documentation (https://docs.sonarcloud.io/getting-started/github/)
# or reach out to our community forum if you need some help (https://community.sonarsource.com/c/help/sc/9)

name: SonarCloud analysis

on: #ifndef MEMORYCONTROLLER_H
#define MEMORYCONTROLLER_H

//MemoryController.h
//
//Header file for memory controller object
//

#include "SimulatorObject.h"
#include "Transaction.h"
#include "SystemConfiguration.h"
#include "CommandQueue.h"
#include "BusPacket.h"
#include "BankState.h"
#include "Rank.h"
#include "CSVWriter.h"
#include <map>

using namespace std;

namespace DRAMSim
{
class MemorySystem;
class MemoryController : public SimulatorObject
{

public:
        //functions
        MemoryController(MemorySystem* ms, CSVWriter &csvOut_, ostream &dramsim_log_);
        virtual ~MemoryController();

        bool addTransaction(Transaction *trans);
        bool WillAcceptTransaction();
        void returnReadData(const Transaction *trans);
        void receiveFromBus(BusPacket *bpacket);
        void attachRanks(vector<Rank *> *ranks);
        void update();
        void printStats(bool finalStats = false);
        void resetStats(); 


        //fields
        vector<Transaction *> transactionQueue;
private:
        ostream &dramsim_log;
        vector< vector <BankState> > bankStates;
        //functions
        void insertHistogram(unsigned latencyValue, unsigned rank, unsigned bank);

        //fields
        MemorySystem *parentMemorySystem;

        CommandQueue commandQueue;
        BusPacket *poppedBusPacket;
        vector<unsigned>refreshCountdown;
        vector<BusPacket *> writeDataToSend;
        vector<unsigned> writeDataCountdown;
        vector<Transaction *> returnTransaction;
        vector<Transaction *> pendingReadTransactions;
        map<unsigned,unsigned> latencies; // latencyValue -> latencyCount
        vector<bool> powerDown;

        vector<Rank *> *ranks;

        //output file
        CSVWriter &csvOut; 

        // these packets are counting down waiting to be transmitted on the "bus"
        BusPacket *outgoingCmdPacket;
        unsigned cmdCyclesLeft;
        BusPacket *outgoingDataPacket;
        unsigned dataCyclesLeft;

        uint64_t totalTransactions;
        vector<uint64_t> grandTotalBankAccesses; 
        vector<uint64_t> totalReadsPerBank;
        vector<uint64_t> totalWritesPerBank;

        vector<uint64_t> totalReadsPerRank;
        vector<uint64_t> totalWritesPerRank;


        vector< uint64_t > totalEpochLatency;

        unsigned channelBitWidth;
        unsigned rankBitWidth;
        unsigned bankBitWidth;
        unsigned rowBitWidth;
        unsigned colBitWidth;
        unsigned byteOffsetWidth;


        unsigned refreshRank;

public:
        // energy values are per rank -- SST uses these directly, so make these public 
        vector< uint64_t > backgroundEnergy;
        vector< uint64_t > burstEnergy;
        vector< uint64_t > actpreEnergy;
        vector< uint64_t > refreshEnergy;

};
}

#endif

  push: //MemorySystem.cpp
//
//Class file for JEDEC memory system wrapper
//

#include "MemorySystem.h"
#include "IniReader.h"
#include <unistd.h>

using namespace std;


ofstream cmd_verify_out; //used in Rank.cpp and MemoryController.cpp if VERIFICATION_OUTPUT is set

unsigned NUM_DEVICES;
unsigned NUM_RANKS;
unsigned NUM_RANKS_LOG;

namespace DRAMSim {

powerCallBack_t MemorySystem::ReportPower = NULL;

MemorySystem::MemorySystem(unsigned id, unsigned int megsOfMemory, CSVWriter &csvOut_, ostream &dramsim_log_) :
                dramsim_log(dramsim_log_),
                ReturnReadData(NULL),
                WriteDataDone(NULL),
                systemID(id),
                csvOut(csvOut_)
{
        currentClockCycle = 0;

        DEBUG("===== MemorySystem "<<systemID<<" =====");


        //calculate the total storage based on the devices the user selected and the number of

        //calculate number of devices
        /************************
          This code has always been problematic even though it's pretty simple. I'll try to explain it 
          for my own sanity. 

          There are two main variables here that we could let the user choose:
          NUM_RANKS or TOTAL_STORAGE.  Since the density and width of the part is
          fixed by the device ini file, the only variable that is really
          controllable is the number of ranks. Users care more about choosing the
          total amount of storage, but with a fixed device they might choose a total
          storage that isn't possible. In that sense it's not as good to allow them
          to choose TOTAL_STORAGE (because any NUM_RANKS value >1 will be valid).

          However, users don't care (or know) about ranks, they care about total
          storage, so maybe it's better to let them choose and just throw an error
          if they choose something invalid. 

          A bit of background: 

          Each column contains DEVICE_WIDTH bits. A row contains NUM_COLS columns.
          Each bank contains NUM_ROWS rows. Therefore, the total storage per DRAM device is: 
                          PER_DEVICE_STORAGE = NUM_ROWS*NUM_COLS*DEVICE_WIDTH*NUM_BANKS (in bits)

         A rank *must* have a 64 bit output bus (JEDEC standard), so each rank must have:
                          NUM_DEVICES_PER_RANK = 64/DEVICE_WIDTH  
                        (note: if you have multiple channels ganged together, the bus width is 
                        effectively NUM_CHANS * 64/DEVICE_WIDTH)
         
        If we multiply these two numbers to get the storage per rank (in bits), we get:
                        PER_RANK_STORAGE = PER_DEVICE_STORAGE*NUM_DEVICES_PER_RANK = NUM_ROWS*NUM_COLS*NUM_BANKS*64 

        Finally, to get TOTAL_STORAGE, we need to multiply by NUM_RANKS
                        TOTAL_STORAGE = PER_RANK_STORAGE*NUM_RANKS (total storage in bits)

        So one could compute this in reverse -- compute NUM_DEVICES,
        PER_DEVICE_STORAGE, and PER_RANK_STORAGE first since all these parameters
        are set by the device ini. Then, TOTAL_STORAGE/PER_RANK_STORAGE = NUM_RANKS 

        The only way this could run into problems is if TOTAL_STORAGE < PER_RANK_STORAGE,
        which could happen for very dense parts.
        *********************/

        // number of bytes per rank
        unsigned long megsOfStoragePerRank = ((((long long)NUM_ROWS * (NUM_COLS * DEVICE_WIDTH) * NUM_BANKS) * ((long long)JEDEC_DATA_BUS_BITS / DEVICE_WIDTH)) / 8) >> 20;

        // If this is set, effectively override the number of ranks
        if (megsOfMemory != 0)
        {
                NUM_RANKS = megsOfMemory / megsOfStoragePerRank;
                NUM_RANKS_LOG = dramsim_log2(NUM_RANKS);
                if (NUM_RANKS == 0)
                {
                        PRINT("WARNING: Cannot create memory system with "<<megsOfMemory<<"MB, defaulting to minimum size of "<<megsOfStoragePerRank<<"MB");
                        NUM_RANKS=1;
                }
        }

        NUM_DEVICES = JEDEC_DATA_BUS_BITS/DEVICE_WIDTH;
        TOTAL_STORAGE = (NUM_RANKS * megsOfStoragePerRank); 

        DEBUG("CH. " <<systemID<<" TOTAL_STORAGE : "<< TOTAL_STORAGE << "MB | "<<NUM_RANKS<<" Ranks | "<< NUM_DEVICES <<" Devices per rank");


        memoryController = new MemoryController(this, csvOut, dramsim_log);

        // TODO: change to other vector constructor?
        ranks = new vector<Rank *>();

        for (size_t i=0; i<NUM_RANKS; i++)
        {
                Rank *r = new Rank(dramsim_log);
                r->setId(i);
                r->attachMemoryController(memoryController);
                ranks->push_back(r);
        }

        memoryController->attachRanks(ranks);

}



MemorySystem::~MemorySystem()
{
        /* the MemorySystem should exist for all time, nothing should be destroying it */  
//        ERROR("MEMORY SYSTEM DESTRUCTOR with ID "<<systemID);
//        abort();

        delete(memoryController);

        for (size_t i=0; i<NUM_RANKS; i++)
        {
                delete (*ranks)[i];
        }
        ranks->clear();
        delete(ranks);

        if (VERIFICATION_OUTPUT)
        {
                cmd_verify_out.flush();
                cmd_verify_out.close();
        }
}

bool MemorySystem::WillAcceptTransaction()
{
        return memoryController->WillAcceptTransaction();
}

bool MemorySystem::addTransaction(bool isWrite, uint64_t addr)
{
        TransactionType type = isWrite ? DATA_WRITE : DATA_READ;
        Transaction *trans = new Transaction(type,addr,NULL);
        // push_back in memoryController will make a copy of this during
        // addTransaction so it's kosher for the reference to be local 

        if (memoryController->WillAcceptTransaction()) 
        {
                return memoryController->addTransaction(trans);
        }
        else
        {
                pendingTransactions.push_back(trans);
                return true;
        }
}

bool MemorySystem::addTransaction(Transaction *trans)
{
        return memoryController->addTransaction(trans);
}

//prints statistics
void MemorySystem::printStats(bool finalStats)
{
        memoryController->printStats(finalStats);
}


//update the memory systems state
void MemorySystem::update()
{

        //PRINT(" ----------------- Memory System Update ------------------");

        //updates the state of each of the objects
        // NOTE - do not change order
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                (*ranks)[i]->update();
        }

        //pendingTransactions will only have stuff in it if MARSS is adding stuff
        if (pendingTransactions.size() > 0 && memoryController->WillAcceptTransaction())
        {
                memoryController->addTransaction(pendingTransactions.front());
                pendingTransactions.pop_front();
        }
        memoryController->update();

        //simply increments the currentClockCycle field for each object
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                (*ranks)[i]->step();
        }
        memoryController->step();
        this->step();

        //PRINT("\n"); // two new lines
}

void MemorySystem::RegisterCallbacks( Callback_t* readCB, Callback_t* writeCB,
                                      void (*reportPower)(double bgpower, double burstpower,
                                                          double refreshpower, double actprepower))
{
        ReturnReadData = readCB;
        WriteDataDone = writeCB;
        ReportPower = reportPower;
}

} /*namespace DRAMSim */



// This function can be used by autoconf AC_CHECK_LIB since
// apparently it can't detect C++ functions.
// Basically just an entry in the symbol table
extern "C"
{
        void libdramsim_is_present(void)
        {
                ;
        }
}

    branches: [ "main" ]
  pull_request: #ifndef MEMORYSYSTEM_H
#define MEMORYSYSTEM_H

//MemorySystem.h
//
//Header file for JEDEC memory system wrapper
//

#include "SimulatorObject.h"
#include "SystemConfiguration.h"
#include "MemoryController.h"
#include "Rank.h"
#include "Transaction.h"
#include "Callback.h"
#include "CSVWriter.h"
#include <deque>

namespace DRAMSim
{
typedef CallbackBase<void,unsigned,uint64_t,uint64_t> Callback_t;
class MemorySystem : public SimulatorObject
{
        ostream &dramsim_log;
public:
        //functions
        MemorySystem(unsigned id, unsigned megsOfMemory, CSVWriter &csvOut_, ostream &dramsim_log_);
        virtual ~MemorySystem();
        void update();
        bool addTransaction(Transaction *trans);
        bool addTransaction(bool isWrite, uint64_t addr);
        void printStats(bool finalStats);
        bool WillAcceptTransaction();
        void RegisterCallbacks(
            Callback_t *readDone,
            Callback_t *writeDone,
            void (*reportPower)(double bgpower, double burstpower, double refreshpower, double actprepower));

        //fields
        MemoryController *memoryController;
        vector<Rank *> *ranks;
        deque<Transaction *> pendingTransactions; 


        //function pointers
        Callback_t* ReturnReadData;
        Callback_t* WriteDataDone;
        //TODO: make this a functor as well?
        static powerCallBack_t ReportPower;
        unsigned systemID;

private:
        CSVWriter &csvOut;
};
}

#endif

    branches: [ "main" ]
  workflow_dispatch: #include <errno.h> 
#include <sstream> //stringstream
#include <stdlib.h> // getenv()
// for directory operations 
#include <sys/stat.h>
#include <sys/types.h>

#include "MultiChannelMemorySystem.h"
#include "AddressMapping.h"
#include "IniReader.h"



using namespace DRAMSim; 


MultiChannelMemorySystem::MultiChannelMemorySystem(const string &deviceIniFilename_, const string &systemIniFilename_, const string &pwd_, const string &traceFilename_, unsigned megsOfMemory_, string *visFilename_, const IniReader::OverrideMap *paramOverrides)
        :megsOfMemory(megsOfMemory_), deviceIniFilename(deviceIniFilename_),
        systemIniFilename(systemIniFilename_), traceFilename(traceFilename_),
        pwd(pwd_), visFilename(visFilename_), 
        clockDomainCrosser(new ClockDomain::Callback<MultiChannelMemorySystem, void>(this, &MultiChannelMemorySystem::actual_update)),
        csvOut(new CSVWriter(visDataOut))
{
        currentClockCycle=0; 
        if (visFilename)
                printf("CC VISFILENAME=%s\n",visFilename->c_str());

        if (!isPowerOfTwo(megsOfMemory))
        {
                ERROR("Please specify a power of 2 memory size"); 
                abort(); 
        }

        if (pwd.length() > 0)
        {
                //ignore the pwd argument if the argument is an absolute path
                if (deviceIniFilename[0] != '/')
                {
                        deviceIniFilename = pwd + "/" + deviceIniFilename;
                }

                if (systemIniFilename[0] != '/')
                {
                        systemIniFilename = pwd + "/" + systemIniFilename;
                }
        }

        DEBUG("== Loading device model file '"<<deviceIniFilename<<"' == ");
        IniReader::ReadIniFile(deviceIniFilename, false);
        DEBUG("== Loading system model file '"<<systemIniFilename<<"' == ");
        IniReader::ReadIniFile(systemIniFilename, true);

        // If we have any overrides, set them now before creating all of the memory objects
        if (paramOverrides)
                IniReader::OverrideKeys(paramOverrides);

        IniReader::InitEnumsFromStrings();
        if (!IniReader::CheckIfAllSet())
        {
                exit(-1);
        }

        if (NUM_CHANS == 0) 
        {
                ERROR("Zero channels"); 
                abort(); 
        }
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                MemorySystem *channel = new MemorySystem(i, megsOfMemory/NUM_CHANS, (*csvOut), dramsim_log);
                channels.push_back(channel);
        }
}
/* Initialize the ClockDomainCrosser to use the CPU speed 
        If cpuClkFreqHz == 0, then assume a 1:1 ratio (like for TraceBasedSim)
        */
void MultiChannelMemorySystem::setCPUClockSpeed(uint64_t cpuClkFreqHz)
{

        uint64_t dramsimClkFreqHz = (uint64_t)(1.0/(tCK*1e-9));
        clockDomainCrosser.clock1 = dramsimClkFreqHz; 
        clockDomainCrosser.clock2 = (cpuClkFreqHz == 0) ? dramsimClkFreqHz : cpuClkFreqHz; 
}

bool fileExists(string &path)
{
        struct stat stat_buf;
        if (stat(path.c_str(), &stat_buf) != 0) 
        {
                if (errno == ENOENT)
                {
                        return false; 
                }
                ERROR("Warning: some other kind of error happened with stat(), should probably check that"); 
        }
        return true;
}

string FilenameWithNumberSuffix(const string &filename, const string &extension, unsigned maxNumber=100)
{
        string currentFilename = filename+extension;
        if (!fileExists(currentFilename))
        {
                return currentFilename;
        }

        // otherwise, add the suffixes and test them out until we find one that works
        stringstream tmpNum; 
        tmpNum<<"."<<1; 
        for (unsigned i=1; i<maxNumber; i++)
        {
                currentFilename = filename+tmpNum.str()+extension;
                if (fileExists(currentFilename))
                {
                        currentFilename = filename; 
                        tmpNum.seekp(0);
                        tmpNum << "." << i;
                }
                else 
                {
                        return currentFilename;
                }
        }
        // if we can't find one, just give up and return whatever is the current filename
        ERROR("Warning: Couldn't find a suitable suffix for "<<filename); 
        return currentFilename; 
}
/**
 * This function creates up to 3 output files: 
 *         - The .log file if LOG_OUTPUT is set
 *         - the .vis file where csv data for each epoch will go
 *         - the .tmp file if verification output is enabled
 * The results directory is setup to be in PWD/TRACEFILENAME.[SIM_DESC]/DRAM_PARTNAME/PARAMS.vis
 * The environment variable SIM_DESC is also appended to output files/directories
 *
 * TODO: verification info needs to be generated per channel so it has to be
 * moved back to MemorySystem
 **/
void MultiChannelMemorySystem::InitOutputFiles(string traceFilename)
{
        size_t lastSlash;
        size_t deviceIniFilenameLength = deviceIniFilename.length();
        string sim_description_str;
        string deviceName;

        char *sim_description = getenv("SIM_DESC");
        if (sim_description)
        {
                        sim_description_str = string(sim_description);
        }


        // create a properly named verification output file if need be and open it
        // as the stream 'cmd_verify_out'
        if (VERIFICATION_OUTPUT)
        {
                string basefilename = deviceIniFilename.substr(deviceIniFilename.find_last_of("/")+1);
                string verify_filename =  "sim_out_"+basefilename;
                if (sim_description != NULL)
                {
                        verify_filename += "."+sim_description_str;
                }
                verify_filename += ".tmp";
                cmd_verify_out.open(verify_filename.c_str());
                if (!cmd_verify_out)
                {
                        ERROR("Cannot open "<< verify_filename);
                        abort(); 
                }
        }
        // This sets up the vis file output along with the creating the result
        // directory structure if it doesn't exist
        if (VIS_FILE_OUTPUT)
        {
                stringstream out,tmpNum;
                string path;
                string filename;

                if (!visFilename)
                {
                        path = "results/";
                        // chop off the .ini if it's there
                        if (deviceIniFilename.substr(deviceIniFilenameLength-4) == ".ini")
                        {
                                deviceName = deviceIniFilename.substr(0,deviceIniFilenameLength-4);
                                deviceIniFilenameLength -= 4;
                        }

                        // chop off everything past the last / (i.e. leave filename only)
                        if ((lastSlash = deviceName.find_last_of("/")) != string::npos)
                        {
                                deviceName = deviceName.substr(lastSlash+1,deviceIniFilenameLength-lastSlash-1);
                        }

                string rest;
                        // working backwards, chop off the next piece of the directory
                        if ((lastSlash = traceFilename.find_last_of("/")) != string::npos)
                        {
                                traceFilename = traceFilename.substr(lastSlash+1,traceFilename.length()-lastSlash-1);
                        }
                        if (sim_description != NULL)
                        {
                                traceFilename += "."+sim_description_str;
                        }

                        if (pwd.length() > 0)
                        {
                                path = pwd + "/" + path;
                        }

                        // create the directories if they don't exist 
                        mkdirIfNotExist(path);
                        path = path + traceFilename + "/";
                        mkdirIfNotExist(path);
                        path = path + deviceName + "/";
                        mkdirIfNotExist(path);

                        // finally, figure out the filename
                        string sched = "BtR";
                        string queue = "pRank";
                        if (schedulingPolicy == RankThenBankRoundRobin)
                        {
                                sched = "RtB";
                        }
                        if (queuingStructure == PerRankPerBank)
                        {
                                queue = "pRankpBank";
                        }

                        /* I really don't see how "the C++ way" is better than snprintf()  */
                        out << (TOTAL_STORAGE>>10) << "GB." << NUM_CHANS << "Ch." << NUM_RANKS <<"R." <<ADDRESS_MAPPING_SCHEME<<"."<<ROW_BUFFER_POLICY<<"."<< TRANS_QUEUE_DEPTH<<"TQ."<<CMD_QUEUE_DEPTH<<"CQ."<<sched<<"."<<queue;
                }
                else //visFilename given
                {
                        out << *visFilename;
                }
                if (sim_description)
                {
                        out << "." << sim_description;
                }

                //filename so far, without extension, see if it exists already
                filename = out.str();


                filename = FilenameWithNumberSuffix(filename, ".vis"); 
                path.append(filename);
                cerr << "writing vis file to " <<path<<endl;


                visDataOut.open(path.c_str());
                if (!visDataOut)
                {
                        ERROR("Cannot open '"<<path<<"'");
                        exit(-1);
                }
                //write out the ini config values for the visualizer tool
                IniReader::WriteValuesOut(visDataOut);

        }
        else
        {
                // cerr << "vis file output disabled\n";
        }
#ifdef LOG_OUTPUT
        string dramsimLogFilename("dramsim");
        if (sim_description != NULL)
        {
                dramsimLogFilename += "."+sim_description_str; 
        }

        dramsimLogFilename = FilenameWithNumberSuffix(dramsimLogFilename, ".log"); 

        dramsim_log.open(dramsimLogFilename.c_str(), ios_base::out | ios_base::trunc );

        if (!dramsim_log) 
        {
        ERROR("Cannot open "<< dramsimLogFilename);
        //        exit(-1); 
        }
#endif

}


void MultiChannelMemorySystem::mkdirIfNotExist(string path)
{
        struct stat stat_buf;
        // check if the directory exists
        if (stat(path.c_str(), &stat_buf) != 0) // nonzero return value on error, check errno
        {
                if (errno == ENOENT) 
                {
//                        DEBUG("\t directory doesn't exist, trying to create ...");

                        // set permissions dwxr-xr-x on the results directories
                        mode_t mode = (S_IXOTH | S_IXGRP | S_IXUSR | S_IROTH | S_IRGRP | S_IRUSR | S_IWUSR) ;
                        if (mkdir(path.c_str(), mode) != 0)
                        {
                                perror("Error Has occurred while trying to make directory: ");
                                cerr << path << endl;
                                abort();
                        }
                }
                else
                {
                        perror("Something else when wrong: "); 
                        abort();
                }
        }
        else // directory already exists
        {
                if (!S_ISDIR(stat_buf.st_mode))
                {
                        ERROR(path << "is not a directory");
                        abort();
                }
        }
}


MultiChannelMemorySystem::~MultiChannelMemorySystem()
{
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                delete channels[i];
        }
        channels.clear(); 

// flush our streams and close them up
#ifdef LOG_OUTPUT
        dramsim_log.flush();
        dramsim_log.close();
#endif
        if (VIS_FILE_OUTPUT) 
        {        
                visDataOut.flush();
                visDataOut.close();
        }
}
void MultiChannelMemorySystem::update()
{
        clockDomainCrosser.update(); 
}
void MultiChannelMemorySystem::actual_update() 
{
        if (currentClockCycle == 0)
        {
                InitOutputFiles(traceFilename);
                DEBUG("DRAMSim2 Clock Frequency ="<<clockDomainCrosser.clock1<<"Hz, CPU Clock Frequency="<<clockDomainCrosser.clock2<<"Hz"); 
        }

        if (currentClockCycle % EPOCH_LENGTH == 0)
        {
                (*csvOut) << "ms" <<currentClockCycle * tCK * 1E-6; 
                for (size_t i=0; i<NUM_CHANS; i++)
                {
                        channels[i]->printStats(false); 
                }
                csvOut->finalize();
        }

        for (size_t i=0; i<NUM_CHANS; i++)
        {
                channels[i]->update(); 
        }


        currentClockCycle++; 
}
unsigned MultiChannelMemorySystem::findChannelNumber(uint64_t addr)
{
        // Single channel case is a trivial shortcut case 
        if (NUM_CHANS == 1)
        {
                return 0; 
        }

        if (!isPowerOfTwo(NUM_CHANS))
        {
                ERROR("We can only support power of two # of channels.\n" <<
                                "I don't know what Intel was thinking, but trying to address map half a bit is a neat trick that we're not sure how to do"); 
                abort(); 
        }

        // only chan is used from this set 
        unsigned channelNumber,rank,bank,row,col;
        addressMapping(addr, channelNumber, rank, bank, row, col); 
        if (channelNumber >= NUM_CHANS)
        {
                ERROR("Got channel index "<<channelNumber<<" but only "<<NUM_CHANS<<" exist"); 
                abort();
        }
        //DEBUG("Channel idx = "<<channelNumber<<" totalbits="<<totalBits<<" channelbits="<<channelBits); 

        return channelNumber;

}
ostream &MultiChannelMemorySystem::getLogFile()
{
        return dramsim_log; 
}
bool MultiChannelMemorySystem::addTransaction(const Transaction &trans)
{
        // copy the transaction and send the pointer to the new transaction 
        return addTransaction(new Transaction(trans)); 
}

bool MultiChannelMemorySystem::addTransaction(Transaction *trans)
{
        unsigned channelNumber = findChannelNumber(trans->address); 
        return channels[channelNumber]->addTransaction(trans); 
}

bool MultiChannelMemorySystem::addTransaction(bool isWrite, uint64_t addr)
{
        unsigned channelNumber = findChannelNumber(addr); 
        return channels[channelNumber]->addTransaction(isWrite, addr); 
}

/*
        This function has two flavors: one with and without the address. 
        If the simulator won't give us an address and we have multiple channels, 
        we have to assume the worst and return false if any channel won't accept. 

        However, if the address is given, we can just map the channel and check just
        that memory controller
*/

bool MultiChannelMemorySystem::willAcceptTransaction(uint64_t addr)
{
        unsigned chan, rank,bank,row,col; 
        addressMapping(addr, chan, rank, bank, row, col); 
        return channels[chan]->WillAcceptTransaction(); 
}

bool MultiChannelMemorySystem::willAcceptTransaction()
{
        for (size_t c=0; c<NUM_CHANS; c++) {
                if (!channels[c]->WillAcceptTransaction())
                {
                        return false; 
                }
        }
        return true; 
}



void MultiChannelMemorySystem::printStats(bool finalStats) {

        (*csvOut) << "ms" <<currentClockCycle * tCK * 1E-6; 
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                PRINT("==== Channel ["<<i<<"] ====");
                channels[i]->printStats(finalStats); 
                PRINT("//// Channel ["<<i<<"] ////");
        }
        csvOut->finalize();
}
void MultiChannelMemorySystem::RegisterCallbacks( 
                TransactionCompleteCB *readDone,
                TransactionCompleteCB *writeDone,
                void (*reportPower)(double bgpower, double burstpower, double refreshpower, double actprepower))
{
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                channels[i]->RegisterCallbacks(readDone, writeDone, reportPower); 
        }
}

/*
 * The getters below are useful to external simulators interfacing with DRAMSim
 *
 * Return value: 0 on success, -1 on error
 */
int MultiChannelMemorySystem::getIniBool(const std::string& field, bool *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getBool(field, val);
}

int MultiChannelMemorySystem::getIniUint(const std::string& field, unsigned int *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getUint(field, val);
}

int MultiChannelMemorySystem::getIniUint64(const std::string& field, uint64_t *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getUint64(field, val);
}

int MultiChannelMemorySystem::getIniFloat(const std::string& field, float *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getFloat(field, val);
}

namespace DRAMSim {
MultiChannelMemorySystem *getMemorySystemInstance(const string &dev, const string &sys, const string &pwd, const string &trc, unsigned megsOfMemory, string *visfilename) 
{
        return new MultiChannelMemorySystem(dev, sys, pwd, trc, megsOfMemory, visfilename);
}
}

permissions: #include "SimulatorObject.h"
#include "Transaction.h"
#include "SystemConfiguration.h"
#include "MemorySystem.h"
#include "IniReader.h"
#include "ClockDomain.h"
#include "CSVWriter.h"


namespace DRAMSim {


class MultiChannelMemorySystem : public SimulatorObject 
{
        public: 

        MultiChannelMemorySystem(const string &dev, const string &sys, const string &pwd, const string &trc, unsigned megsOfMemory, string *visFilename=NULL, const IniReader::OverrideMap *paramOverrides=NULL);
                virtual ~MultiChannelMemorySystem();
                        bool addTransaction(Transaction *trans);
                        bool addTransaction(const Transaction &trans);
                        bool addTransaction(bool isWrite, uint64_t addr);
                        bool willAcceptTransaction(); 
                        bool willAcceptTransaction(uint64_t addr); 
                        void update();
                        void printStats(bool finalStats=false);
                        ostream &getLogFile();
                        void RegisterCallbacks( 
                                TransactionCompleteCB *readDone,
                                TransactionCompleteCB *writeDone,
                                void (*reportPower)(double bgpower, double burstpower, double refreshpower, double actprepower));
                        int getIniBool(const std::string &field, bool *val);
                        int getIniUint(const std::string &field, unsigned int *val);
                        int getIniUint64(const std::string &field, uint64_t *val);
                        int getIniFloat(const std::string &field, float *val);

        void InitOutputFiles(string tracefilename);
        void setCPUClockSpeed(uint64_t cpuClkFreqHz);

        //output file
        std::ofstream visDataOut;
        ofstream dramsim_log; 

        private:
                unsigned findChannelNumber(uint64_t addr);
                void actual_update(); 
                vector<MemorySystem*> channels; 
                unsigned megsOfMemory; 
                string deviceIniFilename;
                string systemIniFilename;
                string traceFilename;
                string pwd;
                string *visFilename;
                ClockDomain::ClockDomainCrosser clockDomainCrosser; 
                static void mkdirIfNotExist(string path);
                static bool fileExists(string path); 
                CSVWriter *csvOut; 


        };
}
  pull-requests: read # allows SonarCloud to decorate PRs with analysis results

jobs: #include "PrintMacros.h"

/*
 * Enable or disable PRINT() statements.
 *
 * Set by flag in TraceBasedSim.cpp when compiling standalone DRAMSim tool.
 *
 * The DRAMSim libraries do not include the TraceBasedSim object and thus
 * library users can optionally override the weak definition below.
 */
int __attribute__((weak)) SHOW_SIM_OUTPUT = false;
  Analysis: #ifndef PRINT_MACROS_H
#define PRINT_MACROS_H

#include <iostream>

extern int SHOW_SIM_OUTPUT;

#define ERROR(str) std::cerr<<"[ERROR ("<<__FILE__<<":"<<__LINE__<<")]: "<<str<<std::endl;

using std::ostream;

#ifdef DEBUG_BUILD
        #define DEBUG(str)  std::cerr<< str <<std::endl;
        #define DEBUGN(str) std::cerr<< str;
#else
        #define DEBUG(str) ;
        #define DEBUGN(str) ;
#endif

#ifdef NO_OUTPUT
        #undef DEBUG
        #undef DEBUGN
        #define DEBUG(str) ;
        #define DEBUGN(str) ;
        #define PRINT(str) ;
        #define PRINTN(str) ;
#else
        #ifdef LOG_OUTPUT
                #define PRINT(str)  { dramsim_log <<str<<std::endl; }
                #define PRINTN(str) { dramsim_log <<str; }
        #else
                #define PRINT(str)  if(SHOW_SIM_OUTPUT) { std::cout <<str<<std::endl; }
                #define PRINTN(str) if(SHOW_SIM_OUTPUT) { std::cout <<str; }
        #endif
#endif

#endif /*PRINT_MACROS_H*/
    runs-on: ubuntu-latest

    steps: DRAMSim

1. About DRAMSim ---------------------------------------------------------
        DRAMSim is a cycle accurate model of a DRAM memory controller, the DRAM
        modules which comprise system storage, and the bus by which they
        communicate. All major components in a modern memory system are modeled
        as their own respective objects within the source, including: ranks,
        banks, command queue, the memory controller, etc.

        We also added support and config files for STT-MRAM, 
        you can run the simulations the same way as DRAM. 
        Refer Asifuzzaman, K., etc. Enabling a reliable STT-MRAM main memory simulation (MEMSYS2017)
        for more info about STT-MRAM.

        The overarching goal is to have a simulator that is extremely small,
        portable, and accurate. The simulator core has a well-defined interface
        which allows it to be CPU simulator agnostic and should be easily
        modifiably to work with any simulator.  This core has no external run
        time or build time dependencies and has been tested with g++ on Linux
        as well as g++ on Cygwin on Windows.  

2. Building DRAMSim ---------------------------------------------------------

        To build an optimized DRAMSim simply type

        $ make

        For a debug build which contains debugging symbols and verbose output, run:

        $ make DEBUG=1

        this will compile an executable called DRAMSim which can run a
        trace-based simulation. 

        To build the DRAMSim library, type: 

        $ make libdramsim.so 


3. Running DRAMSim -----------------------------------------------------------

        First, run the preprocessor on the gzipped traces:

        cd traces
        ./traceParse.py k6_aoe_02_short.trc.gz

        Then go back to the DRAMSim directory and run the trace based simulator:
        cd ..
        ./DRAMSim -t traces/k6_aoe_02_short.trc -s system.ini -d ini/DDR3_micron_64M_8B_x4_sg15.ini -c 10000

4. DRAMSim Output -------------------------------------------------------------

The verbosity of the DRAMSim can be customized in the ini file by turning the
various debug flags on or off in the ini file. 

Below, we have provided a detailed explanation of the simulator output.  With
all DEBUG flags enabled, the following output is displayed for each cycle
executed.  

   NOTE : BP = Bus Packet
          T  = Transaction
          MC = MemoryController
          R# = Rank (index #)

-------------------------------------------------------------
 ----------------- Memory System Update ------------------
 ---------- Memory Controller Update Starting ------------ [8]
 -- R0 Receiving On Bus    : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 -- MC Issuing On Data Bus    : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
 ++ Adding Read energy to total energy
 -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
== New Transaction - Mapping Address [0x5dec800]
  Rank : 0
  Bank : 0
  Row  : 1502
  Col  : 800
 ++ Adding IDD3N to total energy [from rank 0]
 ++ Adding IDD3N to total energy [from rank 1]
== Printing transaction queue
  8]T [Read] [0x45bbfa4]
  9]T [Write] [0x55fbfa0] [5439E]
  10]T [Write] [0x55fbfa8] [1111]
== Printing bank states (According to MC)
[idle] [idle] [2029] [1502] 
[idle] [idle] [1502] [1502] 

== Printing Per Rank, Per Bank Queue
 = Rank 0
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec800] r[0] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec800] r[0] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec810] r[0] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec810] r[0] b[1] row[1502] col[800]
    Bank 2   size : 2
       0]BP [ACT] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
       1]BP [READ_P] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
    Bank 3   size : 1
       0]BP [READ_P] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 = Rank 1
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2   size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3   size : 0
-----------------------------------------------------



  Anything sent on the bus is encapsulated in an BusPacket (BP) object. 
  When printing, they display the following information:
                         BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
  The information displayed  is (in order):command type, physical address,
  rank #, bank#, row #, and column #.

  Lines beginning with " -- " indicate bus traffic, ie, 
     -- R0 Receiving On Bus       : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
     -- MC Issuing On Data Bus    : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
     -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
  Sender and receiver are indicated and the packet being sent is detailed.


  Lines beginning with " ++ " indicate power calculations, ie, 
                 ++ Adding Read energy to total energy
                  ++ Adding IDD3N to total energy [from rank 0]
                  ++ Adding IDD3N to total energy [from rank 1]
  The state of the system and the actions taken determine which current
  draw is used.  for further detail about each current, see micron data-
  sheet.

        If a pending transaction is in the transaction queue, it will
  be printed, as seen below:
                 == Printing transaction queue                
                           1]T [Read] [0x45bbfa4]
                          2]T [Write] [0x55fbfa0] [5439E]
                           3]T [Write] [0x55fbfa8] [1111]
  Currently, at the start of every cycle, the head of the transaction
  queue is removed, broken up into DRAM commands and placed in the
  appropriate command queues.  To do this, an address mapping scheme
  is applied to the transaction's physical address, the output of 
  which is seen below:
                        == New Transaction - Mapping Address [0x5dec800]
                           Rank : 0
                                 Bank : 0
                                 Row  : 1502
                                 Col  : 800

  If there are pending commands in the command queue, they will be
  printed.  The output is dependent on the designated structure for
  the command queue.  For example, per-rank/per-bank queues are 
  shown below:
   = Rank 1
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2   size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3   size : 0

  The state of each bank in the system is also displayed:
    == Printing bank states (According to MC)
    [idle] [idle] [2029] [1502] 
    [idle] [idle] [1502] [1502] 
  Banks can be in many states, including idle, row active (shown
  with the row that is active), refreshing, or precharging.  These
  states will update based on the commands being sent by the 
  controller.  

      - name: Analyze with SonarCloud

        # You can pin the exact commit or the version.
        # uses: SonarSource/sonarcloud-github-action@de2e56b42aa84d0b1c5b622644ac17e505c9a049
        uses: SonarSource/sonarcloud-github-action@de2e56b42aa84d0b1c5b622644ac17e505c9a049
        env:
          GITHUB_TOKEN: ${{ \documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{courier}
\usepackage[pdfborder=0 0 0]{hyperref}
\usepackage{url}
\usepackage[cm]{fullpage}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\setlength{\parindent}{0cm}
\setlength{\parskip}{0.3cm}
\begin{document}
\title{DRAMSim2}
\author{Elliott Cooper-Balis \\
                        Paul Rosenfeld \\
                        Bruce Jacob \\
                        University of Maryland \\
                        \texttt{\footnotesize dramninjas \textit{[at]} gmail \textit{[dot]} com}
}
\date{}
\maketitle
\HRule
\tableofcontents
\HRule
\lstset{basicstyle={\scriptsize\ttfamily},tabsize=2,frame=single}
\section{Why Do We Need to Simulate DRAM Systems This Accurately?}
Modern computer system performance is increasingly limited
by the performance of DRAM-based memory systems. As a result, there is great
interest in providing accurate simulations of DRAM based memory systems as part
of architectural research. Unfortunately, there is great difficulty associated
with the study of modern DRAM memory systems, arising from
the fact that DRAM-system performance depends on many
independent variables such as workload characteristics of memory access rate
and request sequence, memory-system architecture, memory-system configuration, DRAM
access protocol, and DRAM device timing parameters. As a result, system
architects and design engineers often disagree on the usefulness of a given
performance-enhancing feature, since the performance impact of that feature typically 
depends on the characteristics of specific workloads, memory-system architecture, 
memory-system configuration, DRAM access protocol and DRAM device timing parameters. 
\subsection{DRAM Scheduling Complexity is Growing}

\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{docs/why1.gif}
\caption{Timing diagram showing complexity of DRAM scheduling}
\label{timingcomplex}
\end{center}
\end{figure}
Figure \ref{timingcomplex} shows the pipelined scheduling of a DDR2 SDRAM device. Despite
the fact that the simulated memory system uses a closed-page policy and 
rotates through available banks on the DRAM device, which should simplify
scheduling considerably, the scheduling of this system is actually more
complex than earlier DRAM systems: for instance, new timing parameters
such as t_{RRD} and t_{FAW} are contributing to the growing
set of timing constraints placed on each successive generation of DRAM 
devices.

\subsection{DRAM performance characteristics changes every generation}
DRAM based memory systems are impacted primarily by two attributes: 
row cycle time and device datarate. Presently, DRAM row cycle times are 
decreasing at a rate of approximately 7\% per year, and DRAM device
datarates are increasing with each new generation of DRAM devices at the rate
of 100\% every three years, 
\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{docs/why2.gif}
\caption{DRAM row cycle time trends}
\label{classes}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{docs/why3.gif}
\caption{DRAM device data rate trends}
\label{classes}
\end{center}
\end{figure}
The difference in the scaling trends of the DRAM device means that 
fundamental DRAM device performance characteristics are changing 
every single generation, and the changing performance characteristics
cannot be accurately predicted by linear extrapolations. The result is 
that no computer architect can rest easy knowing that he or she has 
obtained X\% of performance improvement with a set of microarchitectural
techniques on the current generation memory system, because the same set 
of microarchitectural techniques may not to be as effective in a 
future memory system due to the differences in the scaling attributes 
of DRAM devices, 

\subsection{The Sales Pitch}
Our DRAM-system simulation work enables system architects not
only to explore the impact of a set of microarchitectual techniques on a 
given memory system but also to examine the effectiveness of those 
microarchitectural techniques on a future generation memory system with
future generations of DRAM devices.

\section{About DRAMSim2}
        DRAMSim2 is a cycle accurate model of a DRAM memory controller, the DRAM
        modules which comprise system storage, and the buses by which they
        communicate. 

        The overarching goal is to have a simulator that is small,
        portable, and accurate. The simulator core has a simple interface 
        which allows it to be CPU simulator agnostic and should to work with any simulator (see section \ref{library}).  This core has no external run
        time or build time dependencies and has been tested with g++ on Linux
        as well as g++ on Cygwin on Windows.  

\section{Getting DRAMSim2}

DRAMSim2 is available on \href{http://github.com/dramninjasUMD}{github}. If you have git installed you can clone our repository by typing:\\

\texttt{\$ git clone git://github.com/dramninjasUMD/DRAMSim2.git }



\section{Building DRAMSim2}
        To build an optimized standalone trace-based simulator called \texttt{DRAMSim} simply type:

        \texttt{\$ make}

        For a debug build which contains debugging symbols and verbose output, run:

        \texttt{\$ make DEBUG=1}

        To build the DRAMSim2 library, type: 

        \texttt{\$ make libdramsim.so }

\section{Running DRAMSim2}
\begin{minipage}{\textwidth}
\subsection{Trace-Based Simulation}

In standalone mode, DRAMSim2 can simulate memory system traces. While traces are not as accurate
as a real CPU model driving the memory model, they are convenient since they can be generated in a number of different
ways (instrumentation, hardware traces, CPU simulation, etc.) and reused. 

We've provided a few small sample traces in the \texttt{traces/} directory. These gzipped
traces should first be pre-processed before running through the simulator. 
To run the preprocessor (the preprocessor requires python): 
\begin{lstlisting}
cd traces/
./traceParse.py k6_aoe_02_short.trc.gz
\end{lstlisting}
        This should produce the file \texttt{traces/k6\_aoe\_02\_short.trc}. Then, go back to the DRAMSim2 directory and run the trace based simulator:

\begin{lstlisting}
cd .
./DRAMSim -t traces/k6_aoe_02_short.trc -s system.ini -d ini/DDR3_micron_64M_8B_x4_sg15.ini -c 1000
\end{lstlisting}
        This will run a 1000 cycle simulation of the \texttt{k6\_aoe\_02\_short} trace using 
        the specified DDR3 part. The -s, -d, and -t flags are required to run a simulation.

        A full list of the command line arguments can be obtained by typing:
\begin{lstlisting}
$ ./DRAMSim --help
DRAMSim2 Usage: 
DRAMSim -t tracefile -s system.ini -d ini/device.ini [-c #] [-p pwd] -q
        -t, --tracefile=FILENAME         specify a tracefile to run  
        -s, --systemini=FILENAME         specify an ini file that describes the memory system parameters  
        -d, --deviceini=FILENAME         specify an ini file that describes the device-level parameters
        -c, --numcycles=#                 specify number of cycles to run the simulation for [default=30] 
        -q, --quiet                         flag to suppress simulation output (except final stats) [default=no]
        -o, --option=OPTION_A=234                        overwrite any ini file option from the command line
        -p, --pwd=DIRECTORY                Set the working directory

\end{lstlisting}

        Some traces include timing information, which can be used
        by the simulator or ignored. The benefit of ignoring timing information is that requests
        will stream as fast as possible into the memory system and can serve as a good stress
        test. To toggle the use of clock cycles, please change the \texttt{useClockCycle} flag in \texttt{TraceBasedSim.cpp}.

        If you have a custom trace format you'd like to use, you can modify the \texttt{parseTraceFileLine()} function ton add
        support for your own trace formats. 

        The prefix of the filename determines which type of trace this function will use (ex: k6\_foo.trc) will use the k6 format 
        in \texttt{parseTraceFileLine()}.
\end{minipage}

\subsection{Library Interface}\label{library}
In addition to simulating memory traces, DRAMSim2 can also be built as a dynamic
shared library which is convenient for connecting it to CPU simulators or other
custom front ends.  A \texttt{MemorySystem} object encapsulates the
functionality of the memory system (i.e., the memory controller and DIMMs). The 
classes that comprise DRAMSim2 can be seen in figure \ref{classes}. A
simple example application is provided in the \texttt{example\_app/} directory.
At this time we have plans to provide code to integrate DRAMSim2 into 
\href{http://www.marss86.org/index.php/Home}{MARSSx86},
\href{http://www.cs.sandia.gov/sst/}{SST}, and (eventually)
\href{http://www.m5sim.org/}{M5}.

\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{docs/classes.png}
\caption{Block diagram of DRAMSim2. The \texttt{\footnotesize recv()} functions are actually called
\texttt{\footnotesize receiveFromBus()} but were abbreviated to save sapce.}
\label{classes}
\end{center}
\end{figure}

\section{Example Output}

\noindent\begin{minipage}{\textwidth}
The verbosity of the DRAMSim2 can be customized in the system.ini file by turning the
various debug flags on or off. 

Below, we have provided a detailed explanation of the simulator output.  With
all DEBUG flags enabled, the following output is displayed for each cycle
executed.  

   \textbf{NOTE} : BP = Bus Packet, T  = Transaction \\ 
                                        MC = MemoryController, R\# = Rank (index \#)

\begin{lstlisting}
 ----------------- Memory System Update ------------------
 ---------- Memory Controller Update Starting ------------ [8]
 -- R0 Receiving On Bus    : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 -- MC Issuing On Data Bus    : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
 ++ Adding Read energy to total energy
 -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
== New Transaction - Mapping Address [0x5dec800] (read)
  Rank : 0
  Bank : 0
  Row  : 1502
  Col  : 800
 ++ Adding IDD3N to total energy [from rank 0]
 ++ Adding IDD3N to total energy [from rank 1]
== Printing transaction queue
  8]T [Read] [0x45bbfa4]
  9]T [Write] [0x55fbfa0] [5439E]
  10]T [Write] [0x55fbfa8] [1111]
== Printing bank states (According to MC)
[idle] [idle] [2029] [1502] 
[idle] [idle] [1502] [1502] 

== Printing Per Rank, Per Bank Queue
 = Rank 0
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec800] r[0] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec800] r[0] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec810] r[0] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec810] r[0] b[1] row[1502] col[800]
    Bank 2   size : 2
       0]BP [ACT] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
       1]BP [READ_P] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
    Bank 3   size : 1
       0]BP [READ_P] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 = Rank 1
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2   size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3   size : 0
\end{lstlisting}
\end{minipage}

\begin{minipage}{\textwidth}
Anything sent on the bus is encapsulated in an BusPacket (BP) object. When
printing, they display the following information:
\begin{lstlisting}
BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
\end{lstlisting}
The information displayed  is (in order): command type, physical address, rank
\#, bank \#, row \#, and column \#.
\end{minipage}


\begin{minipage}{\textwidth}
Lines beginning with " -- " indicate bus traffic, ie, 
\begin{lstlisting}
     -- R0 Receiving On Bus       : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
     -- MC Issuing On Data Bus    : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
     -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
\end{lstlisting}
Sender and receiver are indicated and the packet being sent is detailed.
\end{minipage}

Lines beginning with " ++ " indicate power calculations, ie, 
\begin{lstlisting}
                 ++ Adding Read energy to total energy
                  ++ Adding IDD3N to total energy [from rank 0]
                  ++ Adding IDD3N to total energy [from rank 1]
\end{lstlisting}
The state of the system and the actions taken determine which current draw is used. For further detail about each current value, see Micron datasheet.  


If a pending transaction is in the transaction queue, it will be printed, as seen below:
\begin{lstlisting}
         == Printing transaction queue                
                1]T [Read] [0x45bbfa4]
                2]T [Write] [0x55fbfa0] [5439E]
                3]T [Write] [0x55fbfa8] [1111]
\end{lstlisting}
Currently, at the start of every cycle, the head of the transaction
queue is removed, broken up into DRAM commands and placed in the
appropriate command queues.  To do this, an address mapping scheme
is applied to the transaction's physical address, the output of 
which is seen below:
\begin{lstlisting}
        == New Transaction - Mapping Address [0x5dec800] (read)
         Rank : 0
                 Bank : 0
                 Row  : 1502
                 Col  : 800
\end{lstlisting}

If there are pending commands in the command queue, they will be
printed.  The output is dependent on the designated structure for
the command queue.  For example, per-rank/per-bank queues are 
shown below:
\begin{lstlisting}
   = Rank 1
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2   size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3   size : 0
\end{lstlisting}

The state of each bank in the system is also displayed:
\begin{lstlisting}
    == Printing bank states (According to MC)
    [idle] [idle] [2029] [1502] 
    [idle] [idle] [1502] [1502] 
\end{lstlisting}
Banks can be in many states, including idle, row active (shown
with the row that is active), refreshing, or precharging.  These
states will update based on the commands being sent by the 
controller.  

\section{Results Output}

In addition to printing memory statistics and debug information to standard out, DRAMSim2 also produces
a 'vis' file in the \texttt{results/} directory. A vis file is essentially a summary of relevant statistics that is generated
per epoch (the number of cycles per epoch can be set by changing the \texttt{EPOCH\_COUNT} parameter in the \texttt{system.ini} file). 

We are currently working on DRAMVis, which is a cross-platform viewer which parses the vis file and generates graphs that can be used
to analyze and compare results.

\end{document} }}  # Needed to get PR information
          SONAR_TOKEN: ${{ DRAMSim2: A cycle accurate DRAM Simulator
================================================================================
Elliott Cooper-Balis
Paul Rosenfeld
Bruce Jacob
University of Maryland
dramninjas [at] gmail [dot] com


1 About DRAMSim2 --------------------------------------------------------------------------------

DRAMSim2 is a cycle accurate model of a DRAM memory controller, the DRAM modules which comprise
system storage, and the buses by which they communicate.
The overarching goal is to have a simulator that is small, portable, and accurate. The simulator core has a
simple interface which allows it to be CPU simulator agnostic and should to work with any simulator (see
section 4.2). This core has no external run time or build time dependencies and has been tested with g++ on
Linux as well as g++ on Cygwin on Windows.

2 Getting DRAMSim2--------------------------------------------------------------------------------

DRAMSim2 is available on github. If you have git installed you can clone our repository by typing:

$ git clone git://github.com/dramninjasUMD/DRAMSim2.git

3 Building DRAMSim2--------------------------------------------------------------------------------

To build an optimized standalone trace-based simulator called DRAMSim simply type:
$ make
For a debug build which contains debugging symbols and verbose output, run:
$ make DEBUG=1

To build the DRAMSim2 library, type:
$ make libdramsim.so


4 Running DRAMSim2--------------------------------------------------------------------------------

4.1 Trace-Based Simulation--------------------------------------------------------------------------------
In standalone mode, DRAMSim2 can simulate memory system traces. While traces are not as accurate as a
real CPU model driving the memory model, they are convenient since they can be generated in a number of
different ways (instrumentation, hardware traces, CPU simulation, etc.) and reused.
We've provided a few small sample traces in the traces/ directory. These gzipped traces should first be pre-
processed before running through the simulator. To run the preprocessor (the preprocessor requires python):

cd traces/
./traceParse.py k6_aoe_02_short.trc.gz
This should produce the file traces/k6aoe02short.trc. Then, go back to the DRAMSim2 directory
and run the trace based simulator:
cd .
./DRAMSim -t traces/k6_aoe_02_short.trc -s system.ini -d ini/DDR3_micron_64M_8B_x4_sg15.ini -c 1000
This will run a 1000 cycle simulation of the k6aoe02short trace using the specified DDR3 part. The -s,
-d, and -t flags are required to run a simulation.
A full list of the command line arguments can be obtained by typing:

$ ./DRAMSim --help
DRAMSim2 Usage:
DRAMSim -t tracefile -s system.ini -d ini/device.ini [-c #] [-p pwd] -q
  -t, --tracefile=FILENAME specify a tracefile to run
  -s, --systemini=FILENAME specify an ini file that describes the memory system parameters
  -d, --deviceini=FILENAME specify an ini file that describes the device-level parameters
  -c, --numcycles=# specify number of cycles to run the simulation for [default=30]
  -q, --quiet flag to suppress simulation output (except final stats) [default=no]
  -o, --option=OPTION_A=234 overwrite any ini file option from the command line
  -p, --pwd=DIRECTORY Set the working directory
Some traces include timing information, which can be used by the simulator or ignored. The benefit of ignoring
timing information is that requests will stream as fast as possible into the memory system and can serve as a good
stress test. To toggle the use of clock cycles, please change the useClockCycle flag in TraceBasedSim.cpp.
If you have a custom trace format you'd like to use, you can modify the parseTraceFileLine() function
ton add support for your own trace formats.
The prefix of the filename determines which type of trace this function will use (ex: k6 foo.trc) will use the k6
format in parseTraceFileLine().

4.2 Library Interface--------------------------------------------------------------------------------

In addition to simulating memory traces, DRAMSim2 can also be built as a dynamic shared library which
is convenient for connecting it to CPU simulators or other custom front ends. A MemorySystem object
encapsulates the functionality of the memory system (i.e., the memory controller and DIMMs). The classes that
comprise DRAMSim2 can be seen in figure 1. A simple example application is provided in the exampleapp/
directory. At this time we have plans to provide code to integrate DRAMSim2 into MARSSx86, SST, and
(eventually) M5.

The verbosity of the DRAMSim2 can be customized in the system.ini file by turning the various debug flags on
or off.
Below, we have provided a detailed explanation of the simulator output. With all DEBUG flags enabled, the
following output is displayed for each cycle executed.
NOTE : BP = Bus Packet, T = Transaction
MC = MemoryController, R# = Rank (index #)
 ----------------- Memory System Update ------------------
 ---------- Memory Controller Update Starting ------------ [8]
 -- R0 Receiving On Bus : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 -- MC Issuing On Data Bus : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
 ++ Adding Read energy to total energy
 -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
== New Transaction - Mapping Address [0x5dec800] (read)
  Rank : 0
  Bank : 0
  Row : 1502
  Col : 800
 ++ Adding IDD3N to total energy [from rank 0]
 ++ Adding IDD3N to total energy [from rank 1]
== Printing transaction queue
  8]T [Read] [0x45bbfa4]
  9]T [Write] [0x55fbfa0] [5439E]
  10]T [Write] [0x55fbfa8] [1111]
== Printing bank states (According to MC)
[idle] [idle] [2029] [1502]
[idle] [idle] [1502] [1502]

== Printing Per Rank, Per Bank Queue
 = Rank 0
    Bank 0 size : 2
       0]BP [ACT] pa[0x5dec800] r[0] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec800] r[0] b[0] row[1502] col[800]
    Bank 1 size : 2
       0]BP [ACT] pa[0x5dec810] r[0] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec810] r[0] b[1] row[1502] col[800]
    Bank 2 size : 2
       0]BP [ACT] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
       1]BP [READ_P] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
    Bank 3 size : 1
       0]BP [READ_P] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 = Rank 1
    Bank 0 size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1 size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2 size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3 size : 0

Anything sent on the bus is encapsulated in an BusPacket (BP) object. When printing, they display the
following information:
BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
The information displayed is (in order): command type, physical address, rank #, bank #, row #, and column
#.


Lines beginning with " -- " indicate bus traffic, ie,
      -- R0 Receiving On Bus : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
      -- MC Issuing On Data Bus : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
      -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]

Sender and receiver are indicated and the packet being sent is detailed.
Lines beginning with " ++ " indicate power calculations, ie,
      ++ Adding Read energy to total energy
      ++ Adding IDD3N to total energy [from rank 0]
      ++ Adding IDD3N to total energy [from rank 1]

The state of the system and the actions taken determine which current draw is used. For further detail about
each current value, see Micron datasheet.
If a pending transaction is in the transaction queue, it will be printed, as seen below:
   == Printing transaction queue
     1]T [Read] [0x45bbfa4]
     2]T [Write] [0x55fbfa0] [5439E]
     3]T [Write] [0x55fbfa8] [1111]

Currently, at the start of every cycle, the head of the transaction queue is removed, broken up into DRAM
commands and placed in the appropriate command queues. To do this, an address mapping scheme is applied
to the transaction's physical address, the output of which is seen below:
  == New Transaction - Mapping Address [0x5dec800] (read)
   Rank : 0
      Bank : 0
      Row : 1502
      Col : 800

If there are pending commands in the command queue, they will be printed. The output is dependent on the
designated structure for the command queue. For example, per-rank/per-bank queues are shown below:
   = Rank 1
     Bank 0 size : 2
         0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
         1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
     Bank 1 size : 2
         0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
         1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
     Bank 2 size : 1
         0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
     Bank 3 size : 0

The state of each bank in the system is also displayed:
     == Printing bank states (According to MC)
     [idle] [idle] [2029] [1502]
     [idle] [idle] [1502] [1502]

Banks can be in many states, including idle, row active (shown with the row that is active), refreshing, or
precharging. These states will update based on the commands being sent by the controller.

6 Results Output--------------------------------------------------------------------------------

In addition to printing memory statistics and debug information to standard out, DRAMSim2 also produces a
'vis' file in the results/ directory. A vis file is essentially a summary of relevant statistics that is generated per
epoch (the number of cycles per epoch can be set by changing the EPOCH_COUNT parameter in the system.ini
file).
We are currently working on DRAMVis, which is a cross-platform viewer which parses the vis file and generates
graphs that can be used to analyze and compare results.





































                                                          6


Figure 1: Block diagram of DRAMSim2. The recv() functions are actually called receiveFromBus() but were
abbreviated to save sapce.





                                                 7

 }}   # Generate a token on Sonarcloud.io, add it to the secrets of this repo with the name SONAR_TOKEN (Settings > Secrets > Actions > add new repository secret)
        with: #include "Rank.h"
#include "MemoryController.h"

using namespace std;
using namespace DRAMSim;

Rank::Rank(ostream &dramsim_log_) :
        id(-1),
        dramsim_log(dramsim_log_),
        isPowerDown(false),
        refreshWaiting(false),
        readReturnCountdown(0),
        banks(NUM_BANKS, Bank(dramsim_log_)),
        bankStates(NUM_BANKS, BankState(dramsim_log_))

{

        memoryController = NULL;
        outgoingDataPacket = NULL;
        dataCyclesLeft = 0;
        currentClockCycle = 0;

#ifndef NO_STORAGE
#endif

}

// mutators
void Rank::setId(int id)
{
        this->id = id;
}

// attachMemoryController() must be called before any other Rank functions
// are called
void Rank::attachMemoryController(MemoryController *memoryController)
{
        this->memoryController = memoryController;
}
Rank::~Rank()
{
        for (size_t i=0; i<readReturnPacket.size(); i++)
        {
                delete readReturnPacket[i];
        }
        readReturnPacket.clear(); 
        delete outgoingDataPacket; 
}
void Rank::receiveFromBus(BusPacket *packet)
{
        if (DEBUG_BUS)
        {
                PRINTN(" -- R" << this->id << " Receiving On Bus    : ");
                packet->print();
        }
        if (VERIFICATION_OUTPUT)
        {
                packet->print(currentClockCycle,false);
        }

        switch (packet->busPacketType)
        {
        case READ:
                //make sure a read is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextRead ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        packet->print();
                        ERROR("== Error - Rank " << id << " received a READ when not allowed");
                        exit(0);
                }

                //update state table
                bankStates[packet->bank].nextPrecharge = max(bankStates[packet->bank].nextPrecharge, currentClockCycle + READ_TO_PRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + max(tCCD, BL/2));
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + READ_TO_WRITE_DELAY);
                }

                //get the read data and put it in the storage which delays until the appropriate time (RL)
#ifndef NO_STORAGE
                banks[packet->bank].read(packet);
#else
                packet->busPacketType = DATA;
#endif
                readReturnPacket.push_back(packet);
                readReturnCountdown.push_back(RL);
                break;
        case READ_P:
                //make sure a read is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextRead ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        ERROR("== Error - Rank " << id << " received a READ_P when not allowed");
                        exit(-1);
                }

                //update state table
                bankStates[packet->bank].currentBankState = Idle;
                bankStates[packet->bank].nextActivate = max(bankStates[packet->bank].nextActivate, currentClockCycle + READ_AUTOPRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        //will set next read/write for all banks - including current (which shouldnt matter since its now idle)
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + max(BL/2, tCCD));
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + READ_TO_WRITE_DELAY);
                }

                //get the read data and put it in the storage which delays until the appropriate time (RL)
#ifndef NO_STORAGE
                banks[packet->bank].read(packet);
#else
                packet->busPacketType = DATA;
#endif

                readReturnPacket.push_back(packet);
                readReturnCountdown.push_back(RL);
                break;
        case WRITE:
                //make sure a write is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextWrite ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        ERROR("== Error - Rank " << id << " received a WRITE when not allowed");
                        bankStates[packet->bank].print();
                        exit(0);
                }

                //update state table
                bankStates[packet->bank].nextPrecharge = max(bankStates[packet->bank].nextPrecharge, currentClockCycle + WRITE_TO_PRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + WRITE_TO_READ_DELAY_B);
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + max(BL/2, tCCD));
                }

                //take note of where data is going when it arrives
                incomingWriteBank = packet->bank;
                incomingWriteRow = packet->row;
                incomingWriteColumn = packet->column;
                delete(packet);
                break;
        case WRITE_P:
                //make sure a write is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextWrite ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        ERROR("== Error - Rank " << id << " received a WRITE_P when not allowed");
                        exit(0);
                }

                //update state table
                bankStates[packet->bank].currentBankState = Idle;
                bankStates[packet->bank].nextActivate = max(bankStates[packet->bank].nextActivate, currentClockCycle + WRITE_AUTOPRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + max(tCCD, BL/2));
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + WRITE_TO_READ_DELAY_B);
                }

                //take note of where data is going when it arrives
                incomingWriteBank = packet->bank;
                incomingWriteRow = packet->row;
                incomingWriteColumn = packet->column;
                delete(packet);
                break;
        case ACTIVATE:
                //make sure activate is allowed
                if (bankStates[packet->bank].currentBankState != Idle ||
                        currentClockCycle < bankStates[packet->bank].nextActivate)
                {
                        ERROR("== Error - Rank " << id << " received an ACT when not allowed");
                        packet->print();
                        bankStates[packet->bank].print();
                        exit(0);
                }

                bankStates[packet->bank].currentBankState = RowActive;
                bankStates[packet->bank].nextActivate = currentClockCycle + tRC;
                bankStates[packet->bank].openRowAddress = packet->row;

                //if AL is greater than one, then posted-cas is enabled - handle accordingly
                if (AL>0)
                {
                        bankStates[packet->bank].nextWrite = currentClockCycle + (tRCD-AL);
                        bankStates[packet->bank].nextRead = currentClockCycle + (tRCD-AL);
                }
                else
                {
                        bankStates[packet->bank].nextWrite = currentClockCycle + (tRCD-AL);
                        bankStates[packet->bank].nextRead = currentClockCycle + (tRCD-AL);
                }

                bankStates[packet->bank].nextPrecharge = currentClockCycle + tRAS;
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        if (i != packet->bank)
                        {
                                bankStates[i].nextActivate = max(bankStates[i].nextActivate, currentClockCycle + tRRD);
                        }
                }
                delete(packet); 
                break;
        case PRECHARGE:
                //make sure precharge is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextPrecharge)
                {
                        ERROR("== Error - Rank " << id << " received a PRE when not allowed");
                        exit(0);
                }

                bankStates[packet->bank].currentBankState = Idle;
                bankStates[packet->bank].nextActivate = max(bankStates[packet->bank].nextActivate, currentClockCycle + tRP);
                delete(packet); 
                break;
        case REFRESH:
                refreshWaiting = false;
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        if (bankStates[i].currentBankState != Idle)
                        {
                                ERROR("== Error - Rank " << id << " received a REF when not allowed");
                                exit(0);
                        }
                        bankStates[i].nextActivate = currentClockCycle + tRFC;
                }
                delete(packet); 
                break;
        case DATA:
                // TODO: replace this check with something that works?
                /*
                if(packet->bank != incomingWriteBank ||
                         packet->row != incomingWriteRow ||
                         packet->column != incomingWriteColumn)
                        {
                                cout << "== Error - Rank " << id << " received a DATA packet to the wrong place" << endl;
                                packet->print();
                                bankStates[packet->bank].print();
                                exit(0);
                        }
                */
#ifndef NO_STORAGE
                banks[packet->bank].write(packet);
#else
                // end of the line for the write packet
#endif
                delete(packet);
                break;
        default:
                ERROR("== Error - Unknown BusPacketType trying to be sent to Bank");
                exit(0);
                break;
        }
}

int Rank::getId() const
{
        return this->id;
}

void Rank::update()
{

        // An outgoing packet is one that is currently sending on the bus
        // do the book keeping for the packet's time left on the bus
        if (outgoingDataPacket != NULL)
        {
                dataCyclesLeft--;
                if (dataCyclesLeft == 0)
                {
                        //if the packet is done on the bus, call receiveFromBus and free up the bus
                        memoryController->receiveFromBus(outgoingDataPacket);
                        outgoingDataPacket = NULL;
                }
        }

        // decrement the counter for all packets waiting to be sent back
        for (size_t i=0;i<readReturnCountdown.size();i++)
        {
                readReturnCountdown[i]--;
        }


        if (readReturnCountdown.size() > 0 && readReturnCountdown[0]==0)
        {
                // RL time has passed since the read was issued; this packet is
                // ready to go out on the bus

                outgoingDataPacket = readReturnPacket[0];
                dataCyclesLeft = BL/2;

                // remove the packet from the ranks
                readReturnPacket.erase(readReturnPacket.begin());
                readReturnCountdown.erase(readReturnCountdown.begin());

                if (DEBUG_BUS)
                {
                        PRINTN(" -- R" << this->id << " Issuing On Data Bus : ");
                        outgoingDataPacket->print();
                        PRINT("");
                }

        }
}

//power down the rank
void Rank::powerDown()
{
        //perform checks
        for (size_t i=0;i<NUM_BANKS;i++)
        {
                if (bankStates[i].currentBankState != Idle)
                {
                        ERROR("== Error - Trying to power down rank " << id << " while not all banks are idle");
                        exit(0);
                }

                bankStates[i].nextPowerUp = currentClockCycle + tCKE;
                bankStates[i].currentBankState = PowerDown;
        }

        isPowerDown = true;
}

//power up the rank
void Rank::powerUp()
{
        if (!isPowerDown)
        {
                ERROR("== Error - Trying to power up rank " << id << " while it is not already powered down");
                exit(0);
        }

        isPowerDown = false;

        for (size_t i=0;i<NUM_BANKS;i++)
        {
                if (bankStates[i].nextPowerUp > currentClockCycle)
                {
                        ERROR("== Error - Trying to power up rank " << id << " before we're allowed to");
                        ERROR(bankStates[i].nextPowerUp << "    " << currentClockCycle);
                        exit(0);
                }
                bankStates[i].nextActivate = currentClockCycle + tXP;
                bankStates[i].currentBankState = Idle;
        }
}
          # Additional arguments for the sonarcloud scanner
          args: #ifndef RANK_H
#define RANK_H

#include "SimulatorObject.h"
#include "BusPacket.h"
#include "SystemConfiguration.h"
#include "Bank.h"
#include "BankState.h"

using namespace std;
using namespace DRAMSim;

namespace DRAMSim
{
class MemoryController; //forward declaration
class Rank : public SimulatorObject
{
private:
        int id;
        ostream &dramsim_log; 
        unsigned incomingWriteBank;
        unsigned incomingWriteRow;
        unsigned incomingWriteColumn;
        bool isPowerDown;

public:
        //functions
        Rank(ostream &dramsim_log_);
        virtual ~Rank(); 
        void receiveFromBus(BusPacket *packet);
        void attachMemoryController(MemoryController *mc);
        int getId() const;
        void setId(int id);
        void update();
        void powerUp();
        void powerDown();

        //fields
        MemoryController *memoryController;
        BusPacket *outgoingDataPacket;
        unsigned dataCyclesLeft;
        bool refreshWaiting;

        //these are vectors so that each element is per-bank
        vector<BusPacket *> readReturnPacket;
        vector<unsigned> readReturnCountdown;
        vector<Bank> banks;
        vector<BankState> bankStates;

};
}
#endif

            # Unique keys of your project and organization. You can find them in SonarCloud > Information (bottom-left menu)
            # mandatory
            -Dsonar.projectKey=
            -Dsonar.organization=
            # Comma-separated paths to directories containing main source files.
            #-Dsonar.sources= # optional, default is project base directory
            # When you need the analysis to take place in a directory other than the one from which it was launched
            #-Dsonar.projectBaseDir= # optional, default is .
            # Comma-separated paths to directories containing test source files.
            #-Dsonar.tests= # optional. For more info about Code Coverage, please refer to https://docs.sonarcloud.io/enriching/test-coverage/overview/
            # Adds more detail to both client and server-side analysis logs, activating DEBUG mode for the scanner, and adding client-side environment variables and system properties to the server-side log of analysis report processing.
            #-Dsonar.verbose= # optional, default is false

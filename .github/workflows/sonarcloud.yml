# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# This workflow helps you trigger a SonarCloud analysis of your code and populates
# GitHub Code Scanning alerts with the vulnerabilities found.
# Free for open source project.

# 1. Login to SonarCloud.io using your GitHub account

# 2. Import your project on SonarCloud
#     * Add your GitHub organization first, then add your repository as a new project.
#     * Please note that many languages are eligible for automatic analysis,
#       which means that the analysis will start automatically without the need to set up GitHub Actions.
#     * This behavior can be changed in Administration > Analysis Method.
#
# 3. Follow the SonarCloud in-product tutorial
#     * a. Copy/paste the Project Key and the Organization Key into the args parameter below
#          (You'll find this information in SonarCloud. Click on "Information" at the bottom left)
#
#     * b. Generate a new token and add it to your Github repository's secrets using the name SONAR_TOKEN
#          (On SonarCloud, click on your avatar on top-right > My account > Security
#           or go directly to https://sonarcloud.io/account/security/)

# Feel free to take a look at our documentation (https://docs.sonarcloud.io/getting-started/github/)
# or reach out to our community forum if you need some help (https://community.sonarsource.com/c/help/sc/9)

name: SonarCloud analysis

on: results/
*.o
*.po
*.dep
*.deppo
*.swp
DRAMSim
libdramsim.a
libdramsim.so
  push: #include "SystemConfiguration.h"
#include "AddressMapping.h"

namespace DRAMSim
{

void addressMapping(uint64_t physicalAddress, unsigned &newTransactionChan, unsigned &newTransactionRank, unsigned &newTransactionBank, unsigned &newTransactionRow, unsigned &newTransactionColumn)
{
        uint64_t tempA, tempB;
        unsigned transactionSize = TRANSACTION_SIZE;
        uint64_t transactionMask =  transactionSize - 1; //ex: (64 bit bus width) x (8 Burst Length) - 1 = 64 bytes - 1 = 63 = 0x3f mask
        unsigned channelBitWidth = NUM_CHANS_LOG;
        unsigned rankBitWidth = NUM_RANKS_LOG;
        unsigned bankBitWidth = NUM_BANKS_LOG;
        unsigned rowBitWidth = NUM_ROWS_LOG;
        unsigned colBitWidth = NUM_COLS_LOG;
        // this forces the alignment to the width of a single burst (64 bits = 8 bytes = 3 address bits for DDR parts)
        unsigned byteOffsetWidth = BYTE_OFFSET_WIDTH;
        // Since we're assuming that a request is for BL*BUS_WIDTH, the bottom bits
        // of this address *should* be all zeros if it's not, issue a warning

        if ((physicalAddress & transactionMask) != 0)
        {
                DEBUG("WARNING: address 0x"<<std::hex<<physicalAddress<<std::dec<<" is not aligned to the request size of "<<transactionSize); 
        }

        // each burst will contain JEDEC_DATA_BUS_BITS/8 bytes of data, so the bottom bits (3 bits for a single channel DDR system) are
        //         thrown away before mapping the other bits
        physicalAddress >>= byteOffsetWidth;

        // The next thing we have to consider is that when a request is made for a
        // we've taken into account the granulaity of a single burst by shifting 
        // off the bottom 3 bits, but a transaction has to take into account the
        // burst length (i.e. the requests will be aligned to cache line sizes which
        // should be equal to transactionSize above). 
        //
        // Since the column address increments internally on bursts, the bottom n 
        // bits of the column (colLow) have to be zero in order to account for the 
        // total size of the transaction. These n bits should be shifted off the 
        // address and also subtracted from the total column width. 
        //
        // I am having a hard time explaining the reasoning here, but it comes down
        // this: for a 64 byte transaction, the bottom 6 bits of the address must be 
        // zero. These zero bits must be made up of the byte offset (3 bits) and also
        // from the bottom bits of the column 
        // 
        // For example: cowLowBits = log2(64bytes) - 3 bits = 3 bits 
        unsigned colLowBitWidth = COL_LOW_BIT_WIDTH;

        physicalAddress >>= colLowBitWidth;
        unsigned colHighBitWidth = colBitWidth - colLowBitWidth; 
        if (DEBUG_ADDR_MAP)
        {
                DEBUG("Bit widths: ch:"<<channelBitWidth<<" r:"<<rankBitWidth<<" b:"<<bankBitWidth
                                <<" row:"<<rowBitWidth<<" colLow:"<<colLowBitWidth
                                << " colHigh:"<<colHighBitWidth<<" off:"<<byteOffsetWidth 
                                << " Total:"<< (channelBitWidth + rankBitWidth + bankBitWidth + rowBitWidth + colLowBitWidth + colHighBitWidth + byteOffsetWidth));
        }

        //perform various address mapping schemes
        if (addressMappingScheme == Scheme1)
        {
                //chan:rank:row:col:bank
                tempA = physicalAddress;
                physicalAddress = physicalAddress >> bankBitWidth;
                tempB = physicalAddress << bankBitWidth;
                newTransactionBank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> colHighBitWidth;
                tempB = physicalAddress << colHighBitWidth;
                newTransactionColumn = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rowBitWidth;
                tempB = physicalAddress << rowBitWidth;
                newTransactionRow = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rankBitWidth;
                tempB = physicalAddress << rankBitWidth;
                newTransactionRank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> channelBitWidth;
                tempB = physicalAddress << channelBitWidth;
                newTransactionChan = tempA ^ tempB;

        }
        else if (addressMappingScheme == Scheme2)
        {
                //chan:row:col:bank:rank
                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rankBitWidth;
                tempB = physicalAddress << rankBitWidth;
                newTransactionRank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> bankBitWidth;
                tempB = physicalAddress << bankBitWidth;
                newTransactionBank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> colHighBitWidth;
                tempB = physicalAddress << colHighBitWidth;
                newTransactionColumn = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rowBitWidth;
                tempB = physicalAddress << rowBitWidth;
                newTransactionRow = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> channelBitWidth;
                tempB = physicalAddress << channelBitWidth;
                newTransactionChan = tempA ^ tempB;

        }
        else if (addressMappingScheme == Scheme3)
        {
                //chan:rank:bank:col:row
                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rowBitWidth;
                tempB = physicalAddress << rowBitWidth;
                newTransactionRow = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> colHighBitWidth;
                tempB = physicalAddress << colHighBitWidth;
                newTransactionColumn = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> bankBitWidth;
                tempB = physicalAddress << bankBitWidth;
                newTransactionBank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rankBitWidth;
                tempB = physicalAddress << rankBitWidth;
                newTransactionRank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> channelBitWidth;
                tempB = physicalAddress << channelBitWidth;
                newTransactionChan = tempA ^ tempB;

        }
        else if (addressMappingScheme == Scheme4)
        {
                //chan:rank:bank:row:col
                tempA = physicalAddress;
                physicalAddress = physicalAddress >> colHighBitWidth;
                tempB = physicalAddress << colHighBitWidth;
                newTransactionColumn = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rowBitWidth;
                tempB = physicalAddress << rowBitWidth;
                newTransactionRow = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> bankBitWidth;
                tempB = physicalAddress << bankBitWidth;
                newTransactionBank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rankBitWidth;
                tempB = physicalAddress << rankBitWidth;
                newTransactionRank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> channelBitWidth;
                tempB = physicalAddress << channelBitWidth;
                newTransactionChan = tempA ^ tempB;

        }
        else if (addressMappingScheme == Scheme5)
        {
                //chan:row:col:rank:bank

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> bankBitWidth;
                tempB = physicalAddress << bankBitWidth;
                newTransactionBank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rankBitWidth;
                tempB = physicalAddress << rankBitWidth;
                newTransactionRank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> colHighBitWidth;
                tempB = physicalAddress << colHighBitWidth;
                newTransactionColumn = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rowBitWidth;
                tempB = physicalAddress << rowBitWidth;
                newTransactionRow = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> channelBitWidth;
                tempB = physicalAddress << channelBitWidth;
                newTransactionChan = tempA ^ tempB;


        }
        else if (addressMappingScheme == Scheme6)
        {
                //chan:row:bank:rank:col

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> colHighBitWidth;
                tempB = physicalAddress << colHighBitWidth;
                newTransactionColumn = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rankBitWidth;
                tempB = physicalAddress << rankBitWidth;
                newTransactionRank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> bankBitWidth;
                tempB = physicalAddress << bankBitWidth;
                newTransactionBank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rowBitWidth;
                tempB = physicalAddress << rowBitWidth;
                newTransactionRow = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> channelBitWidth;
                tempB = physicalAddress << channelBitWidth;
                newTransactionChan = tempA ^ tempB;


        }
        // clone of scheme 5, but channel moved to lower bits
        else if (addressMappingScheme == Scheme7)
        {
                //row:col:rank:bank:chan
                tempA = physicalAddress;
                physicalAddress = physicalAddress >> channelBitWidth;
                tempB = physicalAddress << channelBitWidth;
                newTransactionChan = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> bankBitWidth;
                tempB = physicalAddress << bankBitWidth;
                newTransactionBank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rankBitWidth;
                tempB = physicalAddress << rankBitWidth;
                newTransactionRank = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> colHighBitWidth;
                tempB = physicalAddress << colHighBitWidth;
                newTransactionColumn = tempA ^ tempB;

                tempA = physicalAddress;
                physicalAddress = physicalAddress >> rowBitWidth;
                tempB = physicalAddress << rowBitWidth;
                newTransactionRow = tempA ^ tempB;

        }

        else
        {
                ERROR("== Error - Unknown Address Mapping Scheme");
                exit(-1);
        }
        if (DEBUG_ADDR_MAP)
        {
                DEBUG("Mapped Ch="<<newTransactionChan<<" Rank="<<newTransactionRank
                                <<" Bank="<<newTransactionBank<<" Row="<<newTransactionRow
                                <<" Col="<<newTransactionColumn<<"\n"); 
        }

}
};
    branches: [ "main" ]
  pull_request: #ifndef ADDRESS_MAPPING_H
#define ADDRESS_MAPPING_H
namespace DRAMSim
{
        void addressMapping(uint64_t physicalAddress, unsigned &channel, unsigned &rank, unsigned &bank, unsigned &row, unsigned &col);
}

#endif
    branches: [ "main" ]
  workflow_dispatch: //Bank.cpp
//
//Class file for bank object
//

#include "Bank.h"
#include "BusPacket.h"

using namespace std;
using namespace DRAMSim;

Bank::Bank(ostream &dramsim_log_):
                currentState(dramsim_log_), 
                rowEntries(NUM_COLS),
                dramsim_log(dramsim_log_)
{}

/* The bank class is just a glorified sparse storage data structure
 * that keeps track of written data in case the simulator wants a
 * function DRAM model
 *
 * A vector of size NUM_COLS keeps a linked list of rows and their
 * associated values.
 *
 * write() adds an entry to the proper linked list or replaces the
 *         value in a row that was already written
 *
 * read() searches for a node with the right row value, if not found
 *         returns the tracer value 0xDEADBEEF
 * 
 *        TODO: if anyone wants to actually store data, see the 'data_storage' branch and perhaps try to merge that into master
 */



Bank::DataStruct *Bank::searchForRow(unsigned row, DataStruct *head)
{
        while (head != NULL)
        {
                if (head->row == row)
                {
                        //found it
                        return head;
                }
                //keep looking
                head = head->next;
        }
        //if we get here, didn't find it
        return NULL;
}

void Bank::read(BusPacket *busPacket)
{
        DataStruct *rowHeadNode = rowEntries[busPacket->column];
        DataStruct *foundNode = NULL;

        if ((foundNode = Bank::searchForRow(busPacket->row, rowHeadNode)) == NULL)
        {
                // the row hasn't been written before, so it isn't in the list
                //if(SHOW_SIM_OUTPUT) DEBUG("== Warning - Read from previously unwritten row " << busPacket->row);
                void *garbage = calloc(BL * (JEDEC_DATA_BUS_BITS/8),1);
                ((long *)garbage)[0] = 0xdeadbeef; // tracer value
                busPacket->data = garbage;
        }
        else // found it
        {
                busPacket->data = foundNode->data;
        }

        //the return packet should be a data packet, not a read packet
        busPacket->busPacketType = DATA;
}


void Bank::write(const BusPacket *busPacket)
{
        //TODO: move all the error checking to BusPacket so once we have a bus packet,
        //                        we know the fields are all legal

        if (busPacket->column >= NUM_COLS)
        {
                ERROR("== Error - Bus Packet column "<< busPacket->column <<" out of bounds");
                exit(-1);
        }

        // head of the list we need to search
        DataStruct *rowHeadNode = rowEntries[busPacket->column];
        DataStruct *foundNode = NULL;

        if ((foundNode = Bank::searchForRow(busPacket->row, rowHeadNode)) == NULL)
        {
                //not found
                DataStruct *newRowNode = (DataStruct *)malloc(sizeof(DataStruct));

                //insert at the head for speed
                //TODO: Optimize this data structure for speedier lookups?
                newRowNode->row = busPacket->row;
                newRowNode->data = busPacket->data;
                newRowNode->next = rowHeadNode;
                rowEntries[busPacket->column] = newRowNode;
        }
        else
        {
                // found it, just plaster in the new data
                foundNode->data = busPacket->data;
                if (DEBUG_BANKS)
                {
                        PRINTN(" -- Bank "<<busPacket->bank<<" writing to physical address 0x" << hex << busPacket->physicalAddress<<dec<<":");
                        busPacket->printData();
                        PRINT("");
                }
        }
}


permissions: 







#ifndef BANK_H
#define BANK_H

//Bank.h
//
//Header file for bank class
//

#include "SystemConfiguration.h"
#include "SimulatorObject.h"
#include "BankState.h"
#include "BusPacket.h"
#include <iostream>

namespace DRAMSim
{
class Bank
{
        typedef struct _DataStruct
        {
                unsigned row;
                void *data;
                struct _DataStruct *next;
        } DataStruct;

public:
        //functions
        Bank(ostream &dramsim_log_);
        void read(BusPacket *busPacket);
        void write(const BusPacket *busPacket);

        //fields
        BankState currentState;

private:
        // private member
        std::vector<DataStruct *> rowEntries;
        ostream &dramsim_log; 

        static DataStruct *searchForRow(unsigned row, DataStruct *head);
};
}

#endif

  pull-requests: read # allows SonarCloud to decorate PRs with analysis results

jobs: 







//BankState.cpp
//
//Class file for bank state object
//

#include "BankState.h"

using namespace std;
using namespace DRAMSim;

//All banks start precharged
BankState::BankState(ostream &dramsim_log_):
                dramsim_log(dramsim_log_),
                currentBankState(Idle),
                openRowAddress(0),
                nextRead(0),
                nextWrite(0),
                nextActivate(0),
                nextPrecharge(0),
                nextPowerUp(0),
                lastCommand(READ),
                stateChangeCountdown(0)
{}

void BankState::print()
{
        PRINT(" == Bank State ");
        if (currentBankState == Idle)
        {
                PRINT("    State : Idle" );
        }
        else if (currentBankState == RowActive)
        {
                PRINT("    State : Active" );
        }
        else if (currentBankState == Refreshing)
        {
                PRINT("    State : Refreshing" );
        }
        else if (currentBankState == PowerDown)
        {
                PRINT("    State : Power Down" );
        }

        PRINT("    OpenRowAddress : " << openRowAddress );
        PRINT("    nextRead       : " << nextRead );
        PRINT("    nextWrite      : " << nextWrite );
        PRINT("    nextActivate   : " << nextActivate );
        PRINT("    nextPrecharge  : " << nextPrecharge );
        PRINT("    nextPowerUp    : " << nextPowerUp );
}
  Analysis: 







#ifndef BANKSTATE_H
#define BANKSTATE_H

//BankState.h
//
//Header file for bank state class
//

#include "SystemConfiguration.h"
#include "BusPacket.h"

namespace DRAMSim
{
enum CurrentBankState
{
        Idle,
        RowActive,
        Precharging,
        Refreshing,
        PowerDown
};

class BankState
{
        ostream &dramsim_log; 
public:
        //Fields
        CurrentBankState currentBankState;
        unsigned openRowAddress;
        uint64_t nextRead;
        uint64_t nextWrite;
        uint64_t nextActivate;
        uint64_t nextPrecharge;
        uint64_t nextPowerUp;

        BusPacketType lastCommand;
        unsigned stateChangeCountdown;

        //Functions
        BankState(ostream &dramsim_log_);
        void print();
};
}

#endif

    runs-on: ubuntu-latest

    steps: 







//BusPacket.cpp
//
//Class file for bus packet object
//

#include "BusPacket.h"

using namespace DRAMSim;
using namespace std;

BusPacket::BusPacket(BusPacketType packtype, uint64_t physicalAddr, 
                unsigned col, unsigned rw, unsigned r, unsigned b, void *dat, 
                ostream &dramsim_log_) :
        dramsim_log(dramsim_log_),
        busPacketType(packtype),
        column(col),
        row(rw),
        bank(b),
        rank(r),
        physicalAddress(physicalAddr),
        data(dat)
{}

void BusPacket::print(uint64_t currentClockCycle, bool dataStart)
{
        if (this == NULL)
        {
                return;
        }

        if (VERIFICATION_OUTPUT)
        {
                switch (busPacketType)
                {
                case READ:
                        cmd_verify_out << currentClockCycle << ": read ("<<rank<<","<<bank<<","<<column<<",0);"<<endl;
                        break;
                case READ_P:
                        cmd_verify_out << currentClockCycle << ": read ("<<rank<<","<<bank<<","<<column<<",1);"<<endl;
                        break;
                case WRITE:
                        cmd_verify_out << currentClockCycle << ": write ("<<rank<<","<<bank<<","<<column<<",0 , 0, 'h0);"<<endl;
                        break;
                case WRITE_P:
                        cmd_verify_out << currentClockCycle << ": write ("<<rank<<","<<bank<<","<<column<<",1, 0, 'h0);"<<endl;
                        break;
                case ACTIVATE:
                        cmd_verify_out << currentClockCycle <<": activate (" << rank << "," << bank << "," << row <<");"<<endl;
                        break;
                case PRECHARGE:
                        cmd_verify_out << currentClockCycle <<": precharge (" << rank << "," << bank << "," << row <<");"<<endl;
                        break;
                case REFRESH:
                        cmd_verify_out << currentClockCycle <<": refresh (" << rank << ");"<<endl;
                        break;
                case DATA:
                        //TODO: data verification?
                        break;
                default:
                        ERROR("Trying to print unknown kind of bus packet");
                        exit(-1);
                }
        }
}
void BusPacket::print()
{
        if (this == NULL) //pointer use makes this a necessary precaution
        {
                return;
        }
        else
        {
                switch (busPacketType)
                {
                case READ:
                        PRINT("BP [READ] pa[0x"<<hex<<physicalAddress<<dec<<"] r["<<rank<<"] b["<<bank<<"] row["<<row<<"] col["<<column<<"]");
                        break;
                case READ_P:
                        PRINT("BP [READ_P] pa[0x"<<hex<<physicalAddress<<dec<<"] r["<<rank<<"] b["<<bank<<"] row["<<row<<"] col["<<column<<"]");
                        break;
                case WRITE:
                        PRINT("BP [WRITE] pa[0x"<<hex<<physicalAddress<<dec<<"] r["<<rank<<"] b["<<bank<<"] row["<<row<<"] col["<<column<<"]");
                        break;
                case WRITE_P:
                        PRINT("BP [WRITE_P] pa[0x"<<hex<<physicalAddress<<dec<<"] r["<<rank<<"] b["<<bank<<"] row["<<row<<"] col["<<column<<"]");
                        break;
                case ACTIVATE:
                        PRINT("BP [ACT] pa[0x"<<hex<<physicalAddress<<dec<<"] r["<<rank<<"] b["<<bank<<"] row["<<row<<"] col["<<column<<"]");
                        break;
                case PRECHARGE:
                        PRINT("BP [PRE] pa[0x"<<hex<<physicalAddress<<dec<<"] r["<<rank<<"] b["<<bank<<"] row["<<row<<"] col["<<column<<"]");
                        break;
                case REFRESH:
                        PRINT("BP [REF] pa[0x"<<hex<<physicalAddress<<dec<<"] r["<<rank<<"] b["<<bank<<"] row["<<row<<"] col["<<column<<"]");
                        break;
                case DATA:
                        PRINTN("BP [DATA] pa[0x"<<hex<<physicalAddress<<dec<<"] r["<<rank<<"] b["<<bank<<"] row["<<row<<"] col["<<column<<"] data["<<data<<"]=");
                        printData();
                        PRINT("");
                        break;
                default:
                        ERROR("Trying to print unknown kind of bus packet");
                        exit(-1);
                }
        }
}

void BusPacket::printData() const 
{
        if (data == NULL)
        {
                PRINTN("NO DATA");
                return;
        }
        PRINTN("'" << hex);
        for (int i=0; i < 4; i++)
        {
                PRINTN(((uint64_t *)data)[i]);
        }
        PRINTN("'" << dec);
}
      - name: Analyze with SonarCloud

        # You can pin the exact commit or the version.
        # uses: SonarSource/sonarcloud-github-action@de2e56b42aa84d0b1c5b622644ac17e505c9a049
        uses: SonarSource/sonarcloud-github-action@de2e56b42aa84d0b1c5b622644ac17e505c9a049
        env: 
#ifndef BUSPACKET_H
#define BUSPACKET_H
//BusPacket.h
//
//Header file for bus packet object
//

#include "SystemConfiguration.h"

namespace DRAMSim
{
enum BusPacketType
{
        READ,
        READ_P,
        WRITE,
        WRITE_P,
        ACTIVATE,
        PRECHARGE,
        REFRESH,
        DATA
};

class BusPacket
{
        BusPacket();
        ostream &dramsim_log; 
public:
        //Fields
        BusPacketType busPacketType;
        unsigned column;
        unsigned row;
        unsigned bank;
        unsigned rank;
        uint64_t physicalAddress;
        void *data;

        //Functions
        BusPacket(BusPacketType packtype, uint64_t physicalAddr, unsigned col, unsigned rw, unsigned r, unsigned b, void *dat, ostream &dramsim_log_);

        void print();
        void print(uint64_t currentClockCycle, bool dataStart);
        void printData() const;

};
}

#endif

          GITHUB_TOKEN: ${{ #ifndef _CSV_WRITER_H_
#define _CSV_WRITER_H_

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <vector>
#include <string>

#include <string.h>

using std::vector; 
using std::ostream;
using std::string; 
/*
 * CSVWriter: Writes CSV data with headers to an underlying ofstream 
 *         This wrapper is meant to look like an ofstream, but it captures 
 *         the names of each field and prints it out to a header before printing
 *         the CSV data below. 
 *
 *         Note: the first finalize() will not print the values out, only the headers.
 *         One way to fix this problem would be to use a sstringstream (or something) 
 *         to buffer out the values and flush them all in one go instead of passing them 
 *         directly to the underlying stream as is the case now. 
 *
 *         Example usage: 
 *
 *         CSVWriter sw(cout);               // send output to cout
 *         sw <<"Bandwidth" << 0.5; // value ignored
 *         sw <<"Latency" << 5;     // value ignored
 *         sw.finalize();                      // flush the header 
 *         sw <<"Bandwidth" << 1.5; // field name ignored
 *         sw <<"Latency" << 15;     // field name ignored
 *         sw.finalize();                                                         // values printed to csv line
 *         sw <<"Bandwidth" << 2.5; // field name ignored
 *         sw <<"Latency" << 25;     // field name ignored
 *         sw.finalize();                                                         // values printed to csv line
 *
 *         The output of this example will be: 
 *
 *         Bandwidth,Latency
 *         1.5,15
 *         2.5,25
 *
 */


namespace DRAMSim {

        class CSVWriter {
                public :
                struct IndexedName {
                        static const size_t MAX_TMP_STR = 64; 
                        static const unsigned SINGLE_INDEX_LEN = 4; 
                        string str; 

                        // functions 
                        static bool isNameTooLong(const char *baseName, unsigned numIndices)
                        {
                                return (strlen(baseName)+(numIndices*SINGLE_INDEX_LEN)) > MAX_TMP_STR;
                        }
                        static void checkNameLength(const char *baseName, unsigned numIndices)
                        {
                                if (isNameTooLong(baseName, numIndices))
                                {
                                        ERROR("Your string "<<baseName<<" is too long for the max stats size ("<<MAX_TMP_STR<<", increase MAX_TMP_STR"); 
                                        exit(-1); 
                                }
                        }
                        IndexedName(const char *baseName, unsigned channel)
                        {
                                checkNameLength(baseName,1);
                                char tmp_str[MAX_TMP_STR]; 
                                snprintf(tmp_str, MAX_TMP_STR,"%s[%u]", baseName, channel); 
                                str = string(tmp_str); 
                        }
                        IndexedName(const char *baseName, unsigned channel, unsigned rank)
                        {
                                checkNameLength(baseName,2);
                                char tmp_str[MAX_TMP_STR]; 
                                snprintf(tmp_str, MAX_TMP_STR,"%s[%u][%u]", baseName, channel, rank); 
                                str = string(tmp_str); 
                        }
                        IndexedName(const char *baseName, unsigned channel, unsigned rank, unsigned bank)
                        {
                                checkNameLength(baseName,3);
                                char tmp_str[MAX_TMP_STR]; 
                                snprintf(tmp_str, MAX_TMP_STR,"%s[%u][%u][%u]", baseName, channel, rank, bank); 
                                str = string(tmp_str);
                        }

                };
                // where the output will eventually go 
                ostream &output; 
                vector<string> fieldNames; 
                bool finalized; 
                unsigned idx; 
                public: 

                // Functions
                void finalize()
                {
                        //TODO: tag unlikely
                        if (!finalized)
                        {
                                for (unsigned i=0; i<fieldNames.size(); i++)
                                {
                                        output << fieldNames[i] << ",";
                                }
                                output << std::endl << std::flush;
                                finalized=true; 
                        }
                        else
                        {
                                if (idx < fieldNames.size()) 
                                {
                                        printf(" Number of fields doesn't match values (fields=%u, values=%u), check each value has a field name before it\n", idx, (unsigned)fieldNames.size());
                                }
                                idx=0; 
                                output << std::endl; 
                        }
                }

                // Constructor 
                CSVWriter(ostream &_output) : output(_output), finalized(false), idx(0)
                {}

                // Insertion operators for field names
                CSVWriter &operator<<(const char *name)
                {
                        if (!finalized)
                        {
//                                cout <<"Adding "<<name<<endl;
                                fieldNames.push_back(string(name));
                        }
                        return *this; 
                }

                CSVWriter &operator<<(const string &name)
                {
                        if (!finalized)
                        {
                                fieldNames.push_back(string(name));
                        }
                        return *this; 
                }

                CSVWriter &operator<<(const IndexedName &indexedName)
                {
                        if (!finalized)
                        {
//                                cout <<"Adding "<<indexedName.str<<endl;
                                fieldNames.push_back(indexedName.str);
                        }
                        return *this; 
                }

                bool isFinalized()
                {
//                        printf("obj=%p", this); 
                        return finalized; 
                }

                ostream &getOutputStream()
                {
                        return output; 
                }
                // Insertion operators for value types 
                // All of the other types just need to pass through to the underlying
                // ofstream, so just write this small wrapper function to make the
                // whole thing less verbose
#define ADD_TYPE(T) \
                CSVWriter &operator<<(T value) \
                {                                \
                        if (finalized)                \
                        {                             \
                                output << value <<",";     \
                                idx++;                     \
                        }                             \
                        return *this;                 \
                }                      

        ADD_TYPE(int);
        ADD_TYPE(unsigned); 
        ADD_TYPE(long);
        ADD_TYPE(uint64_t);
        ADD_TYPE(float);
        ADD_TYPE(double);

        //disable copy constructor and assignment operator
        private:
                CSVWriter(const CSVWriter &); 
                CSVWriter &operator=(const CSVWriter &);

        }; // class CSVWriter


} // namespace DRAMSim

#endif // _CSV_WRITER_H_ }}  # Needed to get PR information
          SONAR_TOKEN: ${{ 


#include <stdint.h> // uint64_t

#ifndef CALLBACK_H
#define CALLBACK_H

namespace DRAMSim
{

template <typename ReturnT, typename Param1T, typename Param2T,
typename Param3T>
class CallbackBase
{
public:
        virtual ~CallbackBase() = 0;
        virtual ReturnT operator()(Param1T, Param2T, Param3T) = 0;
};

template <typename Return, typename Param1T, typename Param2T, typename Param3T>
DRAMSim::CallbackBase<Return,Param1T,Param2T,Param3T>::~CallbackBase() {}

template <typename ConsumerT, typename ReturnT,
typename Param1T, typename Param2T, typename Param3T >
class Callback: public CallbackBase<ReturnT,Param1T,Param2T,Param3T>
{
private:
        typedef ReturnT (ConsumerT::*PtrMember)(Param1T,Param2T,Param3T);

public:
        Callback( ConsumerT* const object, PtrMember member) :
                        object(object), member(member)
        {
        }

        Callback( const Callback<ConsumerT,ReturnT,Param1T,Param2T,Param3T>& e ) :
                        object(e.object), member(e.member)
        {
        }

        ReturnT operator()(Param1T param1, Param2T param2, Param3T param3)
        {
                return (const_cast<ConsumerT*>(object)->*member)
                       (param1,param2,param3);
        }

private:

        ConsumerT* const object;
        const PtrMember  member;
};

typedef CallbackBase <void, unsigned, uint64_t, uint64_t> TransactionCompleteCB;
} // namespace DRAMSim

#endif }}   # Generate a token on Sonarcloud.io, add it to the secrets of this repo with the name SONAR_TOKEN (Settings > Secrets > Actions > add new repository secret)
        with: #include "ClockDomain.h"

using namespace std;



namespace ClockDomain
{
        // "Default" crosser with a 1:1 ratio
        ClockDomainCrosser::ClockDomainCrosser(ClockUpdateCB *_callback)
                : callback(_callback), clock1(1UL), clock2(1UL), counter1(0UL), counter2(0UL)
        {
        }
        ClockDomainCrosser::ClockDomainCrosser(uint64_t _clock1, uint64_t _clock2, ClockUpdateCB *_callback) 
                : callback(_callback), clock1(_clock1), clock2(_clock2), counter1(0), counter2(0)
        {
                //cout << "CTOR: callback address: " << (uint64_t)(this->callback) << "\t ratio="<<clock1<<"/"<<clock2<< endl;
        }

        ClockDomainCrosser::ClockDomainCrosser(double ratio, ClockUpdateCB *_callback)
                : callback(_callback), counter1(0), counter2(0)
        {
                // Compute numerator and denominator for ratio, then pass that to other constructor.
                double x = ratio;

                const int MAX_ITER = 15;
                size_t i;
                unsigned ns[MAX_ITER], ds[MAX_ITER];
                double zs[MAX_ITER];
                ds[0] = 0;
                ds[1] = 1;
                zs[1] = x;
                ns[1] = (int)x; 

                for (i = 1; i<MAX_ITER-1; i++)
                {
                        if (fabs(x - (double)ns[i]/(double)ds[i]) < 0.00005)
                        {
                                //printf("ANSWER= %u/%d\n",ns[i],ds[i]);
                                break;
                        }
                        //TODO: or, if the answers are the same as the last iteration, stop 

                        zs[i+1] = 1.0f/(zs[i]-(int)floor(zs[i])); // 1/(fractional part of z_i)
                        ds[i+1] = ds[i]*(int)floor(zs[i+1])+ds[i-1];
                        double tmp = x*ds[i+1];
                        double tmp2 = tmp - (int)tmp;
                        ns[i+1] = tmp2 >= 0.5 ? ceil(tmp) : floor(tmp); // ghetto implementation of a rounding function
                        //printf("i=%lu, z=%20f n=%5u d=%5u\n",i,zs[i],ns[i],ds[i]);
                }

                //printf("APPROXIMATION= %u/%d\n",ns[i],ds[i]);
                this->clock1=ns[i];
                this->clock2=ds[i];

                //cout << "CTOR: callback address: " << (uint64_t)(this->callback) << "\t ratio="<<clock1<<"/"<<clock2<< endl;
        }

        void ClockDomainCrosser::update()
        {
                //short circuit case for 1:1 ratios
                if (clock1 == clock2 && callback)
                {
                        (*callback)();
                        return; 
                }

                // Update counter 1.
                counter1 += clock1;

                while (counter2 < counter1)
                {
                        counter2 += clock2;
                        //cout << "CALLBACK: counter1= " << counter1 << "; counter2= " << counter2 << "; " << endl;
                        //cout << "callback address: " << (uint64_t)callback << endl;
                        if (callback)
                        {
                                //cout << "Callback() " << (uint64_t)callback<< "Counters: 1="<<counter1<<", 2="<<counter2 <<endl;
                                (*callback)();
                        }
                }

                if (counter1 == counter2)
                {
                        counter1 = 0;
                        counter2 = 0;
                }
        }



        void TestObj::cb()
        {
                        cout << "In Callback\n";
        }

        int TestObj::test()
        {
                ClockUpdateCB *callback = new Callback<TestObj, void>(this, &TestObj::cb);

                //ClockDomainCrosser x(5,2,&cb);
                //ClockDomainCrosser x(2,5,NULL);
                //ClockDomainCrosser x(37,41,NULL);
                //ClockDomainCrosser x(41,37,NULL);
                //cout << "(main) callback address: " << (uint64_t)&cb << endl;
                ClockDomainCrosser x(0.5, callback);
                cout <<"------------------------------------------\n";
                ClockDomainCrosser y(0.3333, callback);
                cout <<"------------------------------------------\n";
                ClockDomainCrosser z(0.9, callback);
                cout <<"------------------------------------------\n";


                for (int i=0; i<10; i++)
                {

                        x.update();
                        cout << "UPDATE: counter1= " << x.counter1 << "; counter2= " << x.counter2 << "; " << endl;
                }

                return 0;
        }


}
          # Additional arguments for the sonarcloud scanner
          args: #include <iostream>

#include <cmath>
#include <stdint.h>

namespace ClockDomain
{

    template <typename ReturnT>
    class CallbackBase
    {
        public:
        virtual ReturnT operator()() = 0;
    };


    template <typename ConsumerT, typename ReturnT>
    class Callback: public CallbackBase<ReturnT>
    {
        private:
        typedef ReturnT (ConsumerT::*PtrMember)();

        public:
        Callback(ConsumerT* const object, PtrMember member) : object(object), member(member) {}

        Callback(const Callback<ConsumerT,ReturnT> &e) : object(e.object), member(e.member) {}

        ReturnT operator()()
        {
            return (const_cast<ConsumerT*>(object)->*member)();
        }

        private:
        ConsumerT* const object;
        const PtrMember  member;
    };

    typedef CallbackBase <void> ClockUpdateCB;


        class ClockDomainCrosser
        {
                public:
                ClockUpdateCB *callback;
                uint64_t clock1, clock2;
                uint64_t counter1, counter2;
                ClockDomainCrosser(ClockUpdateCB *_callback);
                ClockDomainCrosser(uint64_t _clock1, uint64_t _clock2, ClockUpdateCB *_callback);
                ClockDomainCrosser(double ratio, ClockUpdateCB *_callback);
                void update();
        };


        class TestObj
        {
                public:
                TestObj() {}
                void cb();
                int test();
        };
}
            # Unique keys of your project and organization. You can find them in SonarCloud > Information (bottom-left menu)
            # mandatory
            -Dsonar.projectKey=
            -Dsonar.organization=
            # Comma-separated paths to directories containing main source files.
            #-Dsonar.sources= # optional, default is project base directory
            # When you need the analysis to take place in a directory other than the one from which it was launched
            #-Dsonar.projectBaseDir= # optional, default is .
            # Comma-separated paths to directories containing test source files.
            #-Dsonar.tests= # optional. For more info about Code Coverage, please refer to https://docs.sonarcloud.io/enriching/test-coverage/overview/
            # Adds more detail to both client and server-side analysis logs, activating DEBUG mode for the scanner, and adding client-side environment variables and system properties to the server-side log of analysis report processing.
            #-Dsonar.verbose= # optional, default is false

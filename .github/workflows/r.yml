# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
#
# See https://github.com/r-lib/actions/tree/master/examples#readme for
# additional example workflows available for the R community.

name: R

on: AddSegments <- function (x, y, half.width.factor = 0.45, ...) {
  ## Add horizontal line segments at the specified x and y points.
  ## The main use for this function is to add reference lines to
  ## side-by-side boxplots.
  ##
  ## Args:
  ##   x: A vector of equally spaced values on which the segments
  ##     should center.
  ##   y:  The value of each line segment on the vertical axis.
  ##   half.width.factor: What fraction of the distance between
  ##     consecutive x values should be taken up by the line segments.
  ##     .5 == all of it.
  ##   ...: Extra arguments to be passed to 'segments'
  ##
  dx = diff(x)
  if (!(all(dx) == dx[1])) {
    stop("need equally spaced x's in add.segments")
  }
  dx <- dx[1]
  half.width = half.width.factor * dx
  x0 <- x - half.width
  x1 <- x + half.width
  segments(x0, y, x1, y, ...)
}
  push: BoxplotMcmcMatrix <- function(X, ylim = range(X), col.names,
                              row.names, truth, colors = NULL,
                              las = 0, ...) {
  ## Creates an organized set of boxplots for a sequence of MCMC draws
  ## of a matrix.
  ##
  ## Args:
  ##   X: A 3-way array representing the draws of the matrix to be
  ##     plotted.  The first index is the observation number.  The
  ##     second and third indices correspond to rows and columns of
  ##     the simulated matrices.
  ##   ylim:  Limits for the vertical axes.
  ##   col.names: Names for the column headings in the plot.  If
  ##     missing, these will be taken from the dimnames of X.
  ##   row.names: Names for the row headings in the plot.  If missing,
  ##     these will be taken from the dimnames of X.
  ##   truth: Either a scalar or a matrix with dimensions matching
  ##     X[1, , ], giving reference values to be plotted for each
  ##     coordinate.
  ##   colors:  A vector of colors to use for the boxes.
  ##   ...:  Extra arguments passed to boxplot.
  stopifnot(is.array(X) && length(dim(X)) == 3)
  nr <- dim(X)[2]
  nc <- dim(X)[3]
  have.truth <- FALSE
  if (!missing(truth)) {
    have.truth <- TRUE
    if (length(truth) == 1) {
      truth <- matrix(truth, nrow = nr, ncol = nc)
    }
    else if ((nrow(truth) != nr) || (ncol(truth) != nc)) {
      stop("dimension of  'truth' does not match dimension of 'X'\n")
    }
  }
  if (missing(row.names)) {
    row.names <- dimnames(X)[[2]]
  }
  if (is.null(row.names)) {
    row.names <- as.character(1:nr)
  }
  if (length(row.names) != nr) {
    stop("need ", nr, " entries in 'row.names'.  Have ", length(row.names), ".")
  }
  if (missing(col.names)) {
    col.names <- dimnames(X)[[3]]
  }
  if (is.null(col.names)) {
    col.names <- paste(1:nc)
  }
  if (length(col.names) != nc) {
    stop("need ", nc, " entries in 'col.names'.  Have ", length(col.names), ".")
  }
  opar <- par(mfrow = c(nr, 1), mar = rep(0, 4), oma = c(4, 8, 4, 4), las = las)
  on.exit(par(opar))
  rng <- range(X)
  for (j in 1:nr) {
    boxplot(split(X[, j, ], col(X[, j, ])), ylim = ylim,
            axes = FALSE, col = colors, ...)
    if (have.truth) {
      AddSegments(1:nc, truth[j, ], lwd = 3)
    }
    box()
    if (j %% 2) {
      axis(side = 2)
    } else {
      axis(side = 4)
    }
    mtext(row.names[j], side = 2, cex = par("cex.lab"),
          font = par("font.lab"), line = 2.5)
    if (j == nr) {
      axis(side = 1, at = 1:nc, labels = col.names)
    }
  }
}
    branches: [ "main" ]
  pull_request: BoxplotTrue <- function(x, truth=NULL, vnames=NULL, center=FALSE,
                        se.truth = NULL, color="white", truth.color = "black",
                        ylim = NULL, ...) {
  ## Compares the marginal distributions of the columns of a matrix
  ## against a vector of true values.  Useful for validating an MCMC
  ## algorithm against simulated data where you know the true
  ## parameter values.
  ##
  ## Args:
  ##   x: A matrix of data to plot.  Rows are observations/MCMC
  ##     iterations.  Columns are variables.  Each column gets its own
  ##     box.
  ##   truth: A vector of "true" numeric values to compare against the
  ##     boxplots of x.
  ##   vnames:  A character vector to use as the boxplot labels.
  ##   center: Logical.  If TRUE then the value of 'truth' is
  ##     subtracted from each column of x before plotting.
  ##   se.truth: If the true standard errors from the simulation are
  ##     known then setting se.truth will add reference lines at +/- 2
  ##     standard errors.
  ##   color:  A vector of colors to use for the different boxes.
  ##   truth.color: A vector of colors to use for the segments showing the true
  ##     values.
  ##   ylim:  A sorted 2-vector giving the limits of the vertical axis.
  ##   ...:  Extra arguments passed to boxplot.
  ##
  if(!is.null(truth)){
    if(length(truth)!=ncol(x))
      stop("truth and x don't conform in boxplot.true")
    if(!is.null(se.truth)){
      if(length(se.truth)!=length(truth)){
        stop("truth and se.truth don't conform in boxplot.true")
      }
    }
  }

  if(!is.null(se.truth) && is.null(truth)){
    stop("need to supply argument 'truth' to plot se.truth in boxplot.true")
  }

  if (is.null(ylim)) {
    ylim <- range(x, na.rm = TRUE)
    if (!is.null(truth)) {
      ylim <- range(truth, ylim, na.rm = TRUE)
      if (!is.null(se.truth)) {
        ylim <- range(ylim, truth - 2 * se.truth, truth + 2 * se.truth)
      }
    }
  }

  if(center && !is.null(truth)){
    x <- x - matrix(rep(truth, nrow(x)), ncol=length(truth), byrow=TRUE)
    truth <- truth-truth
  }
  nx <- ncol(x)
  if(is.null(vnames)) vnames <- paste(1:nx)

  if(length(color) < nx) color <- rep(color, length.out=nx)
  boxplot(split(x, col(x)), names = vnames, col = color, ylim = ylim, ...)

  if(!is.null(truth)){
    AddSegments(1:ncol(x), truth, lwd = 3, col = truth.color)
    if(!is.null(se.truth)){
      AddSegments(1:ncol(x), truth + 2 * se.truth, lwd = 1, lty = 2)
      AddSegments(1:ncol(x), truth - 2 * se.truth, lwd = 1, lty = 2)
    }
  }
}
    branches: [ "main" ]

permissions: ## A collection of utilities for checking whether objects match
## various concepts.

check.scalar.probability <- function(x) {
  okay <- is.numeric(x) && length(x) == 1 && x >= 0 && x <= 1
  if (!okay) {
    stop("Expected a scalar probability.")
  }
  return(TRUE)
}

check.positive.scalar <- function(x) {
  okay <- is.numeric(x) && length(x) == 1 && x > 0
  if (!okay) {
    stop("Expected a positive scalar.")
  }
  return(TRUE)
}

check.nonnegative.scalar <- function(x) {
  okay <- is.numeric(x) && length(x) == 1 && x >= 0
  if (!okay) {
    stop("Expected a non-negative scalar.")
  }
  return(TRUE)
}

check.scalar.integer <- function(x) {
  okay <- is.numeric(x) && (length(x) == 1) && (abs(x - as.integer(x)) < 1e-10)
  if (!okay) {
    stop("Expected a scalar integer.")
  }
  return(TRUE)
}

check.scalar.boolean <- function(x) {
  if (!is.logical(x) || !(length(x) == 1)) {
    stop("Expected a scalar boolean value.")
  }
  return(TRUE)
}

check.probability.distribution <- function(x) {
  okay <- is.numeric(x) && isTRUE(all.equal(sum(x), 1)) && all(x >= 0)
  if (!okay) {
    stop("Expected a discrete probability distribution.")
  }
  return(TRUE)
}

  contents: read

jobs: CheckMcmcMatrix <- function(draws, truth, confidence = .95,
                            control.multiple.comparisons = TRUE,
                            burn = 0) {
  ## A utility for unit testing an MCMC algorithm.  Check that an MCMC ensemble
  ## contains the 'true' values used to simulate the fake data driving the MCMC
  ## test.
  ##
  ## Args:
  ##   draws: A matrix of MCMC draws.  Each row is a draw.  Each column is a
  ##     variable in the distribution being sampled by the MCMC.
  ##   truth: The true values used to verify the draws.  A vector of the same
  ##     dimension as ncol(draws).
  ##   confidence: The probability content of the central interval for each
  ##     variable.
  ##   control.multiple.comparisons: If FALSE then the check will fail if any of
  ##     the true values falls outside the corresponding central interval from
  ##     the MCMC sample.  If TRUE then the check will pass as long the fraction
  ##     of intervals covering the true values exceeds a lower bound.  The lower
  ##     bound is the lower limit of the binoimal confidence interval for the
  ##     coverage rate, assuming a true coverage rate of 'confidence'.
  ##
  ## Returns:
  ##   TRUE if the check passes.  FALSE otherwise.
  stopifnot(is.matrix(draws), length(truth) == ncol(draws))
  if (burn > 0) {
    draws <- draws[-(1:burn), , drop = FALSE]
  }
  stopifnot(nrow(draws) > 0)
  alpha <- 1 - confidence
  intervals <- apply(draws, 2, quantile, c(alpha / 2, 1 - (alpha / 2)))
  ## intervals is a 2-row matrix.

  inside <- truth >= intervals[1, ] & truth <= intervals[2, ]
  if (control.multiple.comparisons) {
    fraction.inside <- sum(inside) / length(inside)
    binomial.se <- sqrt(confidence * (1 - confidence) / ncol(draws))
    lower.limit <- confidence - 2 * binomial.se
    return(fraction.inside >= lower.limit)
  } else {
    return(all(inside))
  }
}

McmcMatrixReport <- function(draws, truth, confidence = .95, burn = 0) {
  ## A report that can be put in the 'info' field of an expect_that call when
  ## the MCMC matrix checked by CheckMcmcMatrix fails to cover the true values.
  ##
  ## Args:
  ##   draws: A matrix of MCMC draws.  Each row is a draw.  Each column is a
  ##     variable in the distribution being sampled by the MCMC.
  ##   truth: The true values used to verify the draws.  A vector of the same
  ##     dimension as ncol(draws).
  ##   confidence: The probability content of the central interval for each
  ##     variable.
  ##
  ## Returns:
  ##   A textual representation of a three column matrix.  Each row matches a
  ##   variable in draws, and gives the lower and upper bounds for the credible
  ##   interval used to check the values.  The final column lists the true
  ##   values that are supposed to be inside the credible intervals.  The value
  ##   is returned as a character string that is expected to be fed to cat() or
  ##   print() so that it will render correctly in R CMD CHECK output.
  alpha <- 1 - confidence
  if (burn > 0) {
    draws <- draws[-(1:burn), , drop = FALSE]
  }
  stopifnot(nrow(draws) > 0)
  intervals <- t(apply(draws, 2, quantile, c(alpha / 2, (1 - alpha / 2))))
  ans <- cbind(intervals, truth)
  return(paste(capture.output(print(ans)), collapse = "\n"))
}

CheckMcmcVector <- function(draws, truth, confidence = .95, burn = 0) {
  ## A utility for unit testing an MCMC algorithm.  Check that an MCMC ensemble
  ## contains the 'true' value used to simulate the fake data driving the MCMC
  ## test.
  ##
  ## Args:
  ##   draws:  A numeric vector of Monte Carlo draws.
  ##   truth:  A scalar value used to verify the draws.
  ##   confidence: The probability content of the central interval formed from
  ##     the distribution of 'draws'.
  ##
  ## Details:
  ##   A central interval is formed by taking the middle (1 - confidence)
  ##   proportion of the empirical distribution of 'draws'.  If 'truth' is
  ##   contained in this interval the test is a success and TRUE is returned.
  ##   Otherwise the test is a failure, and FALSE is returned.
  ##
  ## Returns:
  ##    TRUE, if the interval described above covers 'truth', and FALSE otherwise.
  stopifnot(is.numeric(draws),
    is.numeric(truth),
    length(truth) == 1)
  if (burn > 0) {
    draws <- draws[-(1:burn)]
  }
  stopifnot(length(draws) > 0)

  alpha <- 1 - confidence
  interval <- quantile(draws, c(alpha / 2, 1 - (alpha/2)))
  return(truth >= interval[1] && truth <= interval[2])
}
  build: circles <- function(center, radius, ...) {
  ## Args:
  ##   center: A two-column matrix giving the coordinates of the circle center.
  ##     If a single circle is to be drawn then a 2-element vector can be passed
  ##     instead.
  ##   radius:  The radii of the circles.
  ##   ...: Extra arguments passed to 'segments'.  See 'par' for options
  ##     controlling line type, line width, color, etc.
  ##
  ## Effects:
  ##   One or more circles are drawn on the current graphics device at the given
  ##   locations.
  ##
  ## Returns:
  ##   Invisibly returns NULL.
  if (!is.matrix(center)) {
    stopifnot(is.numeric(center), length(center == 2))
    center <- matrix(center, nrow = 1)
  }
  stopifnot(is.matrix(center), ncol(center) == 2)

  stopifnot(is.numeric(radius))
  if (nrow(center) == 1 && length(radius) > 1) {
    center <- matrix(rep(center, 2 * length(radius)),
      nrow = length(radius),
      byrow = TRUE)
  }
  if (nrow(center) > 1 && length(radius) == 1) {
    radius <- rep(radius, nrow(center))
  }
  stopifnot(length(radius) == nrow(center))

  theta <- seq(0, 2 * pi, length = 50)
  unit.circle <- cbind(cos(theta), sin(theta))

  for (i in 1:length(radius)) {
    circle <- radius[i] * unit.circle
    circle[, 1] <- circle[, 1] + center[i, 1]
    circle[, 2] <- circle[, 2] + center[i, 2]
    rotated.index <- c(nrow(circle), 1:(nrow(circle) - 1))
    segments(circle[, 1], circle[, 2],
      circle[rotated.index, 1], circle[rotated.index, 2], ...)
  }
  return(invisible(NULL))
}
    runs-on: macos-latest
    strategy: CompareDensities <- function (x,
                              legend.text = NULL,
                              legend.location = "topright",
                              legend.title = NULL,
                              xlim = NULL,
                              ylim = NULL,
                              xlab = "parameter",
                              ylab = "density",
                              main = "",
                              lty = NULL,
                              col = "black",
                              axes = TRUE,
                              na.rm = TRUE,
                              ...) {
  ## Draws a figure on the current graphics device comparing the
  ## kernel density estimates of the given variables.
  ##
  ## Args:
  ##   x: A list of numeric vectors or a matrix whose columns are to
  ##     be compared.
  ##   legend.text: The labels to be used in the legend.
  ##   legend.location:  The location of the legend.  See 'legend'.
  ##   legend.title:  The legend title.
  ##   xlim:  Limits of the horizontal axis.
  ##   ylim:  Limits of the vertical axis.
  ##   xlab:  Label for the horizonal axis.
  ##   ylab:  Label for the vertical axis.
  ##   main:  Main title.
  ##   lty: The line types to use for the different densities.  See
  ##     par().  If NULL then lty = 1:number of densities.
  ##   col:  Colors to use for the density lines.
  ##   axes:  logical.  Should axes and a box be drawn around the figure?
  ##   na.rm: Should missing values be allowed?  If not, then density
  ##     will fail with an error message.
  ##   ...: Extra arguments passed to 'plot', and 'lines'.
  ##
  ## Returns:
  ##   invisible(NULL)
  if (is.matrix(x)) {
    x <- split(x, col(x))
  }
  if (!is.list(x)) {
    stop("x must be a matrix or a list")
  }
  nx <- length(x)
  if (is.null(lty)) {
    lty <- 1:nx
  }
  stopifnot(length(lty) == nx)

  density.table <- vector(length = 0, mode = "list")
  for (j in 1:nx) {
    if (!all(is.na(x[[j]]))) {
      density.table[[j]] <- density(x[[j]], na.rm = na.rm)
    } else {
      density.table[[j]] <- NA
    }
  }
  if (is.null(xlim)) {
    xlim <- range(unlist(x), na.rm = na.rm)
  }
  if (is.null(ylim)) {
    ylim <- 0
    for (j in 1:length(density.table)) {
      if (!all(is.na(density.table[[j]]))) {
        ylim <- range(c(ylim, density.table[[j]]$y), na.rm = na.rm)
      }
    }
  }
  if (length(col) == 1)
    col <- rep(col, nx)
  plot(density.table[[1]], xlim = xlim, ylim = ylim, xlab = xlab,
       ylab = ylab, main = main, col = col[1], lty = lty[1], axes = axes,
       ...)
  for (j in 2:nx) {
    if (!all(is.na(density.table[[j]]))) {
      lines(density.table[[j]], lty = lty[j], col = col[j], ...)
    }
  }

  if (is.null(legend.text) && !is.null(names(x))) {
    legend.text <- names(x)
  }

  if (!is.null(legend.location) &&
      !is.null(legend.text) &&
      length(legend.text) > 0) {
    rx <- xlim[2] - xlim[1]
    ry <- ylim[2] - ylim[1]
    legend(legend.location,
           lty = lty,
           legend = legend.text,
           title = legend.title,
           col = col,
           bg = "white")
  }
  return(invisible(NULL))
}
      matrix: CompareDynamicDistributions <- function(
    list.of.curves,
    timestamps,
    style = c("dynamic", "boxplot"),
    xlab = "Time",
    ylab = "",
    frame.labels = rep("", length(list.of.curves)),
    main = "",
    actuals = NULL,
    col.actuals = "blue",
    pch.actuals = 1,
    cex.actuals = 1,
    vertical.cuts = NULL,
    ...) {
  ## Produce a plot showing several stacked dynamic distributions over the same
  ## horizontal axis.
  ##
  ## Args:
  ##   list.of.curves: A list of matrices, all having the same number of
  ##     columns.  Each matrix represents a distribution of curves, with rows
  ##     corresponding to individual curves, and columns to time points.
  ##   timestamps: A vector of time stamps, with length matching the number of
  ##     columns in each element of list.of.curves.
  ##   style: Should the curves be represented using a dynamic distribution
  ##     plot, or boxplots.  Boxplots are better for small numbers of time
  ##     points.  Dynamic distribution plots are better for large numbers of
  ##     time points.
  ##   xlab:  Label for the horizontal axis.
  ##   ylab:  Label for the (outer) vertical axis.
  ##   frame.labels: Labels for the vertical axis of each subplot. The length
  ##     must match the number of plot.
  ##   main:  Main title for the plot.
  ##   actuals: If non-NULL, actuals should be a numeric vector giving the
  ##     actual "true" value at each time point.
  ##   col.actuals:  Color to use for the actuals.  See 'par'.
  ##   pch.actuals:  Plotting character(s) to use for the actuals.  See 'par'.
  ##   cex.actuals:  Scale factor for actuals.  See 'par'.
  ##   vertical.cuts: If non-NULL then this must be a vector of the same type as
  ##     'timestamps' with length matching the number of plots.  A vertical line
  ##     will be drawn at this location for each plot.  Entries with the value
  ##     NA signal that no vertical line should be drawn for that entry.
  ##   ...: Extra arguments passed to PlotDynamicDistribution or
  ##     TimeSeriesBoxplot.
  style <- match.arg(style)
  stopifnot(is.list(list.of.curves),
            length(list.of.curves) >= 1,
            all(sapply(list.of.curves, is.matrix)),
            length(unique(sapply(list.of.curves, ncol))) == 1)
  stopifnot(length(timestamps) == ncol(list.of.curves[[1]]))
  stopifnot(is.character(frame.labels),
            length(frame.labels) == length(list.of.curves))
  if (!is.null(actuals)) {
    stopifnot(is.numeric(actuals),
              length(actuals) == length(timestamps))
  }
  if (!is.null(vertical.cuts)) {
    stopifnot(length(vertical.cuts) == length(list.of.curves))
  }
  nplots <- length(list.of.curves)
  if (nplots > 1) {
    ylab.space <- if (ylab != "") 4.1 else 2
    original.par <- par(mfrow = c(nplots, 1),
                        mar = c(0, 4.1, 0, 2.1),
                        oma = c(5.1, ylab.space, 4.1, 2))
    on.exit(par(original.par))
  }
  for (i in seq_along(list.of.curves)) {
    if (style == "dynamic") {
      PlotDynamicDistribution(list.of.curves[[i]],
                              timestamps = timestamps,
                              axes = FALSE,
                              ylab = frame.labels[i],
                              ...)
    } else if (style == "boxplot") {
      TimeSeriesBoxplot(list.of.curves[[i]],
                        axes = FALSE,
                        time = timestamps,
                        ylab = frame.labels[i],
                        ...)
      box()
    }

    if (IsOdd(i)) {
      axis(2)
    } else {
      axis(4)
    }
    if (!is.null(vertical.cuts) && !is.na(vertical.cuts[i])) {
      abline(v = vertical.cuts[i], lwd = 2)
    }
    if (!is.null(actuals)) {
      points(timestamps, actuals, col = col.actuals, pch = pch.actuals,
             cex = cex.actuals)
    }
  }

  if (inherits(timestamps, "Date")) {
    axis.Date(1, timestamps, xpd = NA)
  } else if (inherits(timestamps, "POSIXt")) {
    axis.POSIXct(1, as.POSIXct(timestamps), xpd = NA)
  } else {
    axis(1, xpd = NA)
  }

  title(main = main, xlab = xlab, ylab = ylab, outer = TRUE)
  return(invisible(NULL))
}
        r-version: ['3.6.3', '4.1.1']

    steps: CompareManyDensities <- function(list.of.arrays,
                                 style = c("density", "box"),
                                 main = "",
                                 color = NULL,
                                 gap = 0,
                                 burn = 0,
                                 suppress.labels = FALSE,
                                 x.same.scale = TRUE,
                                 y.same.scale = FALSE,
                                 xlim = NULL,
                                 ylim = NULL,
                                 legend.location = c("top", "right"),
                                 legend.cex = 1,
                                 reflines = NULL,
                                 ...) {
  ## Produce a plot that compares the marginal distribution of each
  ## element of a vector or matrix across several groups.
  ##
  ## Args:
  ##   list.of.arrays: A list of arrays representing the MCMC draws of
  ##     the vector or matrix in question.  Each list element
  ##     represents a different group.  The first index in each list
  ##     list element represents the Monte Carlo draw number (or
  ##     iteration).  The remaining indices represent the variables to
  ##     be plotted.  If the first list element has variable names
  ##     assigned to its indices, these will be used to label the
  ##     plots.
  ##   style:  The style of plot to use for comparing distributions.
  ##   main:  The main title of the plot.
  ##   color:  A vector of colors to be used for representing the groups.
  ##   gap:  The gap (in lines) between plots).
  ##   burn:  The number of MCMC iterations to be discarded as burn-in.
  ##   suppress.labels: Logical.  If FALSE then the dimnames (if any)
  ##     of the first element in list.of.arrays will be used to
  ##     annotate the plot.  If TRUE then no labels will be used.
  ##   x.same.scale: Logical indicating whether the same horizontal
  ##     scale should be used for all the plots.
  ##   y.same.scale: Logical indicating whether the same vertical
  ##     scale should be used for all the plots.  This argument is
  ##     ignored if style == "box".
  ##   xlim: Either NULL, or a pair of numbers giving limits for the
  ##     horizontal axis.  If xlim is set then the same xlim values
  ##     will be used for all plots and the x.same.scale argument will
  ##     be ignored.
  ##   ylim: Either NULL, or a pair of numbers giving limits for the
  ##     vertical axis.  If ylim is set then the same ylim values
  ##     will be used for all plots and the y.same.scale argument will
  ##     be ignored.  This argument is ignored if style == "box".
  ##   legend.location: The location of the legend, either on top or
  ##     at the right.  It can also be NULL in which case no legend
  ##     will appear.  The legend names will be taken from
  ##     names(list.of.arrays).  If it does not have names, then no
  ##     legend will be produced.
  ##   legend.cex:  The relative scale factor to use for the legend text.
  ##   reflines: This can be NULL, in which case no reference lines
  ##     are drawn, it can be a single real number in which case a
  ##     reference line will be drawn at that value in each panel, or
  ##     it can be a vector with length equal to the number of panels,
  ##     in which case a reference line will be drawn at each
  ##     panel-specific value.
  ##   ...: Extra arguments passed to either CompareDensities, or
  ##     boxplot.
  ##
  GetDensityLimits <- function(x) {
    ## Args:
    ##   x is a matrix or a 3-way array
    ## Returns:
    ##   The upper limit of the density() function applied to each
    ##   column in x.
    dmax <- function(x) {return(max(density(x)$y))}
    if (is.matrix(x)) {
      return(max(apply(x, 2, dmax)))
    } else {
      return(max(apply(x, c(2, 3), dmax)))
    }
  }

  style <- match.arg(style)
  stopifnot(is.list(list.of.arrays))
  stopifnot(all(sapply(list.of.arrays, function(x) length(dim(x))) ==
  length(dim(list.of.arrays[[1]]))))

  if (!is.null(reflines)) stopifnot(is.numeric(reflines))

  ## Deduce the number of rows and column necessary, and find row,
  ## column, or plot labels.
  ndim <- length(dim(list.of.arrays[[1]]) )
  have.matrix.labels <- FALSE
  vector.labels <- NULL
  if (ndim == 3) {
    ## Handle the case of matrix valued inputs.  The first index
    ## counts Monte Carlo draws.
    dims <- dim(list.of.arrays[[1]])
    nr <- dims[2]
    nc <- dims[3]
    nvars <- nr * nc
    matrix.data <- TRUE
    dim.names <- dimnames(list.of.arrays[[1]])
    if (!is.null(dim.names)) {
      have.matrix.labels <- TRUE
      row.labels <- dim.names[[2]]
      column.labels <- dim.names[[3]]
    }
  } else if (ndim == 2) {
    ## Handle the case of vector valued inputs.  The first index
    ## counts Monte Carlo draws.
    nvars <- ncol(list.of.arrays[[1]])
    nr <- floor(sqrt(nvars))
    nc <- ceiling(nvars / nr)
    matrix.data <- FALSE
    vector.labels <- colnames(list.of.arrays[[1]])
  } else {
    stop("The input to CompareManyDensities must be a list of ",
         "matrices or 3-way arrays.")
  }

  layout.matrix <- matrix(1:(nr * nc), nrow = nr, ncol = nc, byrow = TRUE)
  if (!is.null(legend.location) && !is.null(names(list.of.arrays))) {
    use.legend <- TRUE
    legend.location <- match.arg(legend.location)
    number.of.plots <- nr * nc
    if (legend.location == "top") {
      layout.matrix <- rbind(number.of.plots + 1, layout.matrix)
    } else if (legend.location == "right") {
      layout.matrix <- cbind(layout.matrix, number.of.plots + 1)
    }
  } else {
    use.legend <- FALSE
  }

  ## Set graphical parameters: margins and the number of plots.  If a
  ## title was supplied we need to leave additional space to print it.
  top.margin <- 4
  if (main != "") {
    top.margin <- top.margin + 4.1
  }
  if (use.legend) {
    if (legend.location == "top") {
      legend.buffer <- max(strheight(names(list.of.arrays),
                                     units = "inches",
                                     cex = legend.cex))
      legend.buffer <- legend.buffer * 1 * 2.54
      if (x.same.scale) {
        legend.buffer <- legend.buffer + .5
      }
      layout(layout.matrix,
             heights = c(lcm(legend.buffer), rep(1, nr)))
    } else if (legend.location == "right") {
      legend.buffer <- max(strwidth(names(list.of.arrays),
                                    units = "inches",
                                    cex = legend.cex))
      legend.buffer <- legend.buffer * 2.54 + legend.cex
      layout(layout.matrix, widths = c(rep(1, nc), lcm(legend.buffer)))
    }
  } else {
    layout(layout.matrix)
  }

  original.par <- par(oma = c(4, 4, top.margin, 4),
                      mar = rep(gap/2, 4),
                      xpd = FALSE)
  on.exit(par(original.par))

  ## Deduce xlim and ylim, if necessary.
  if (x.same.scale && is.null(xlim)) {
    xlim <- range(unlist(list.of.arrays), na.rm = TRUE)
  }
  if (style == "box") {
    ylim <- NULL
  }
  if (y.same.scale && is.null(ylim) && style == "density") {
    ylim <- range(c(0, sapply(list.of.arrays, GetDensityLimits)),
                  na.rm = TRUE)
  }

  ## Set up the color scheme, if necessary.
  number.of.groups <- length(list.of.arrays)
  if (is.null(color)) {
    color <- 1:number.of.groups + 1 ## skip black
  }

  variable.number <- 0
  for (i in 1:nr) {
    for (j in 1:nc) {
      variable.number <- variable.number + 1
      if (variable.number <= nvars) {
        ## Assemble the list of values to be plotted in this panel.
        values <- list()
        for (g in 1:number.of.groups) {
          iterations <- 1:(dim(list.of.arrays[[g]])[1])
          if (burn > 0) {
            iterations <- iterations[-(1:burn)]
          }
          if (matrix.data) {
            values[[g]] <- list.of.arrays[[g]][iterations, i, j]
          } else {
            values[[g]] <- list.of.arrays[[g]][iterations, variable.number]
          }
        }

        ## Make the plot for this panel.
        if (style == "density") {
          CompareDensities(values, col = color, xlim = xlim, ylim = ylim,
                           xaxt = "n", yaxt = "n", ...)
          if (!is.null(reflines)) {
            if (length(reflines) == 1) {
              abline(v = reflines, lwd = 2, ...)
            } else {
              abline(v = reflines[variable.number], lwd = 2, ...)
            }
          }
        } else if (style == "box") {
          boxplot(values, col = color, xaxt = "n", yaxt = "n",
                  ylim = xlim, horizontal = TRUE, ...)
          if (!is.null(reflines)) {
            if (length(reflines) == 1) {
              abline(h = reflines, lwd = 2, ...)
            } else {
              abline(h = reflines[variable.number], lwd = 2, ...)
            }
          }
        }

        ## If the panel needs a label, add the label.
        if (!suppress.labels && !is.null(vector.labels)) {
          mtext(vector.labels[variable.number], line = -2)
        }

      } else {
        ## This block puts empty plots on the bottom row that are
        ## place holders for shared axes.
        if (is.null(ylim)) {
          ylim <- range(unlist(list.of.arrays), na.rm = TRUE)
        }
        if (is.null(xlim)) {
          xlim <- range(unlist(list.of.arrays), na.rm = TRUE)
        }
        plot(xlim, ylim, type = "n", xaxt = "n", yaxt = "n")
      }

      ##------------------------------------------------------------
      ## Put axes and row/column labels where they belong.
      if (i == nr) {
        ## Bottom row
        if (IsOdd(j)) {
          if (x.same.scale) {
            axis(1)
          }
        } else {
          if (have.matrix.labels && !suppress.labels) {
            mtext(column.labels[j], side = 1, line = 2)
          }
        }
      }

      if (i == 1) {
        ## top row
        if (IsEven(j)) {
          if (x.same.scale) {
            axis(3)
          }
        } else {
          if (have.matrix.labels && !suppress.labels) {
            mtext(column.labels[j], side = 3, line = 2)
          }
        }
      }

      if (j == nc) {
        ## right column
        if (IsEven(i)) {
          if (y.same.scale && style == "density") {
            axis(4)
          }
        } else {
          if (have.matrix.labels && !suppress.labels) {
            mtext(row.labels[i], side = 4, line = 2)
          }
        }
      }

      if (j == 1) {
        ## left column
        if (IsOdd(i)) {
          if (y.same.scale && style == "density") {
            axis(2)
          }
        } else {
          if (have.matrix.labels && !suppress.labels) {
            mtext(row.labels[i], side = 2, line = 2)
          }
        }
      }

    } ## Ends loop over j (columns).
  }   ## Ends loop over i (rows).

  if (use.legend) {
    plot(1, xlim = c(0, 1), ylim = c(0, 1), xlab = "", ylab = "",
         type = "n", axes = FALSE, xpd = NA)
    if (legend.location == "top") {
      xjust <- 0.5
      yjust <- 0
      legend.x <- .5
      legend.y <- 1
    } else {
      xjust <- 1
      yjust <- .5
      legend.x <- 1
      legend.y <- .5
    }

    if (style == "density") {
      legend(legend.x,
             legend.y,
             legend = names(list.of.arrays),
             col = color,
             lty = 1:length(list.of.arrays),
             bg = "white",
             horiz = (legend.location == "top"),
             xjust = xjust,
             yjust = yjust,
             cex = legend.cex,
             xpd = NA,
             bty = "n")
    } else if (style == "box") {
      legend(legend.x,
             legend.y,
             legend = names(list.of.arrays),
             fill = color,
             bg = "white",
             horiz = (legend.location == "top"),
             xjust = xjust,
             yjust = yjust,
             cex = legend.cex,
             xpd = NA,
             bty = "n")
    }
  }
  ## Add the main title, if one was supplied.
  if (main != "") {
    title(main = main, outer = TRUE, cex.main = 2, line = 5)
  }
}
      - uses: actions/checkout@v4
      - name: Set up R ${{ matrix.r-version }}
        uses: r-lib/actions/setup-r@f57f1301a053485946083d7a45022b278929a78a
        with: CompareManyTs <- function (list.of.ts, burn = 0, type = "l", gap
                           = 0, boxes = TRUE, thin = 1, labels = NULL,
                           same.scale = TRUE, ylim = NULL, refline =
                           NULL, color = NULL, ...) {
  ## Compare several sets of parallel time series.
  ## Args:
  ##   list.of.ts: A list of time series matrices, data.frames or
  ##     3-dimensional arrays, all of the same size.  The list
  ##     elements correspond to groups.  The first index of the array
  ##     in each list element corresponds to time.  The subsequent
  ##     indices correspond to variables to be plotted.
  ##   burn: The nuumber of initial observations to be discarded as
  ##     burn-in (when plotting MCMC output).
  ##   type:  The plotting type to use when plotting the time series.
  ##   gap:  The amount of space to put between plots.
  ##   boxes:  Logical.  Should boxes be drawn around the plots?
  ##   thin: Plot every thin'th observation.  This can reduce the
  ##     amount of time it takes to make the plot if there are many long
  ##     time series.
  ##   labels:  A character vector to use as labels for individual plots.
  ##   same.scale: Logical.  If TRUE then all plots are shown on the
  ##     same verical scale, and vertical axes are drawn.  If FALSE
  ##     then each plot gets its own scale.
  ##   ylim: The scale of the vertical axis.  If non-NULL then
  ##     same.scale will be set to TRUE.
  ##   refline: The scalar value at which a thin dotted horizontal
  ##     line should be plotted in each panel.  This is useful for
  ##     highlighting zero, for example.
  ##   color:  A vector of colors to use for the plots.
  ##   ...:  Extra arguments passed to 'plot' and 'axis'.
  ##
  add.refline <- function(refline, i) {
    if (is.null(refline))
      return()
    if (length(refline) == 1)
      y <- refline
    else y <- refline[i]
    abline(h = y, lty = 3)
  }
  stopifnot(is.list(list.of.ts))

  for (i in 1:length(list.of.ts)) {
    if (is.data.frame(list.of.ts[[i]])) {
      ## Converting a data.frame directly to an array can return an
      ## error related to dimnames.  Converting to a matrix is easier,
      ## and a matrix is a subclass of array.
      list.of.ts[[i]] <- as.matrix(list.of.ts[[i]])
    } else {
      list.of.ts[[i]] <- as.array(list.of.ts[[i]])
    }
  }

  stopifnot(all(sapply(list.of.ts, is.array)))
  ngroups <- length(list.of.ts)

  ## Ensure that all the list elements are of the same dimension.
  ndim <- sapply(list.of.ts, function(x) length(dim(x)))
  stopifnot(all(ndim == ndim[1]))

  ## Handle arrays by converting them to matrices.
  if (ndim[1] == 3) {
    dim <- dim(list.of.ts[[1]])
    for (i in 1:ngroups) {
      list.of.ts[[i]] <- matrix(aperm(list.of.ts[[i]], c(1, 3, 2)),
                                nrow = dim[1])
    }
  }

  ## Remove burn-in.
  if (burn > 0) {
    for (i in 1:ngroups) {
      list.of.ts[[i]] <- list.of.ts[[i]][-(1:burn), ]
    }
  }

  nvars <- ncol(list.of.ts[[1]])
  nobs <- nrow(list.of.ts[[1]])
  stopifnot(all(sapply(list.of.ts, ncol) == nvars))
  stopifnot(all(sapply(list.of.ts, nrow) == nobs))

  nrows <- max(1, floor(sqrt(nvars)))
  ncols <- ceiling(nvars/nrows)

  index <- thin * (1:floor(nobs/thin))
  for (i in 1:ngroups) {
    list.of.ts[[i]] <- list.of.ts[[i]][index, , drop = FALSE]
  }
  nobs <- length(index)

  if (is.null(color)) {
    color <- 1:ngroups
  }
  if (!is.null(ylim)) {
    same.scale <- TRUE
  }
  if (is.null(ylim)) {
    ylim <- range(sapply(list.of.ts, range, na.rm = TRUE))
  }

  opar <- par(mfrow = c(nrows, ncols),
              mar = rep(gap/2, 4),
              oma = c(4, 4, 4, 4))
  on.exit(par(opar))

  m <- 0
  for (j in 1:nrows) {
    for (k in 1:ncols) {
      m <- m + 1
      if (m > nvars) {
        plot(index, rep(ylim, len = nobs), type = "n", axes = FALSE)
      } else {
        if (same.scale == FALSE) {
          ylim <- range(sapply(list.of.ts, function(x) range(x[, m])))
        }
        plot(index, list.of.ts[[1]][, m], axes = FALSE,
             type = "n", ylim = ylim, ...)
        for (group in 1:ngroups) {
          lines(index, list.of.ts[[group]][, m],
                type = type, col = color[group], lty = group)
        }
        if (is.null(labels)) {
          labels <- colnames(list.of.ts[[1]])
        }

        if (!is.null(labels)) {
          text(min(index), max(ylim), labels[m], pos = 4)
        }
        add.refline(refline, m)
        if (boxes) {
          box()
        }
      }
      if (j == nrows & IsOdd(k)) {
        axis(1, xpd = NA, ...)
      }
      else if (j == 1 & IsEven(k)) {
        axis(3, xpd = NA, ...)
      }
      if (k == 1 & same.scale == TRUE & IsOdd(j))
        axis(2, xpd = NA, ...)
      else if (k == ncols & same.scale == TRUE & IsEven(j))
        axis(4, xpd = NA, ...)
    }
  }
}
          r-version: ${{ CompareVectorBoxplots <- function(draws, main = NULL, colors = NULL,
                                  burn = 0, ...) {
  ## Creates a boxplot comparing the distributions of several vector
  ## valued parameters.
  ## Args:
  ##   draws: A list of MCMC draws.  Each list element is a matrix
  ##     with rows corresponding to MCMC iterations and columns to
  ##     variables.
  ##   main:  Main title of the plot.
  ##   colors:  Colors to use for the boxplots.  This should either be
  ##   burn: The number of initial MCMC iterations to discard before
  ##     making the plot.
  ##   ...: Extra arguments passed to 'boxplot'.
  stopifnot(is.list(draws))
  stopifnot(all(sapply(draws, is.matrix)))
  dimension <- ncol(draws[[1]])
  stopifnot(all(sapply(draws, ncol) == dimension))
  number.of.components <- length(draws)

  list.position <- 0
  y <- list()
  for (column in 1:dimension) {
    for (component in 1:number.of.components) {
      list.position <- list.position + 1
      y[[list.position]] <- draws[[component]][, column]
      if (burn > 0) y[[list.position]] <- y[[list.position]][-(1:burn)]
    }
  }

  if (length(colors) == 1) {
    colors <- rep(colors, number.of.components)
  }
  if(!is.null(colors)) {
    stopifnot(length(colors) == number.of.components)
  }
  boxplot(y, col = colors, main = main, axes = FALSE, ...)
  axis(2)
  box()
  split.positions <- number.of.components * (1:(dimension-1)) + .5
  tick.positions <- number.of.components * (0:(dimension-1)) +
    .5*(number.of.components + 1)

  vnames <- colnames(draws[[1]])
  if (is.null(vnames)) {
    tick.labels <- paste(1:dimension)
  } else {
    tick.labels <- vnames
  }
  axis(side = 1, at = tick.positions, labels = tick.labels)
  abline(v = split.positions)

  component.names <- names(draws)
  if (is.null(component.names)) {
    component.names <- paste(0:(number.of.components - 1))
  }

  if(!is.null(colors)) {
    legend("topright", fill = colors,
           legend = component.names,
           title = "Component",
           bg = "white")
  }

  return(invisible(NULL))
} }}
      - name: Install dependencies
        run: |
          install.packages(c("remotes", "rcmdcheck"))
          remotes::install_deps(dependencies = TRUE)
        shell: Rscript {0}
      - name: Check
        run: rcmdcheck::rcmdcheck(args = "--no-manual", error_on = "error")
        shell: Rscript {0}

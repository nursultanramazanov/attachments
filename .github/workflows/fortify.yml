# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

################################################################################################################################################
# Fortify Application Security provides your team with solutions to empower DevSecOps practices, enable cloud transformation, and secure your  #
# software supply chain. To learn more about Fortify, start a free trial or contact our sales team, visit fortify.com.                         #
#                                                                                                                                              #
# Use this starter workflow as a basis for integrating Fortify Application Security Testing into your GitHub workflows. This template          #
# demonstrates the steps to package the code+dependencies, initiate a scan, and optionally import SAST vulnerabilities into GitHub Security    #
# Code Scanning Alerts. Additional information is available in the workflow comments and the Fortify AST Action / fcli / Fortify product       #
# documentation. If you need additional assistance, please contact Fortify support.                                                            #
################################################################################################################################################

name: Fortify AST Scan

# Customize trigger events based on your DevSecOps process and/or policy
on: DRAMSim

1. About DRAMSim ---------------------------------------------------------
        DRAMSim is a cycle accurate model of a DRAM memory controller, the DRAM
        modules which comprise system storage, and the bus by which they
        communicate. All major components in a modern memory system are modeled
        as their own respective objects within the source, including: ranks,
        banks, command queue, the memory controller, etc.

        We also added support and config files for STT-MRAM, 
        you can run the simulations the same way as DRAM. 
        Refer Asifuzzaman, K., etc. Enabling a reliable STT-MRAM main memory simulation (MEMSYS2017)
        for more info about STT-MRAM.

        The overarching goal is to have a simulator that is extremely small,
        portable, and accurate. The simulator core has a well-defined interface
        which allows it to be CPU simulator agnostic and should be easily
        modifiably to work with any simulator.  This core has no external run
        time or build time dependencies and has been tested with g++ on Linux
        as well as g++ on Cygwin on Windows.  

2. Building DRAMSim ---------------------------------------------------------

        To build an optimized DRAMSim simply type

        $ make

        For a debug build which contains debugging symbols and verbose output, run:

        $ make DEBUG=1

        this will compile an executable called DRAMSim which can run a
        trace-based simulation. 

        To build the DRAMSim library, type: 

        $ make libdramsim.so 


3. Running DRAMSim -----------------------------------------------------------

        First, run the preprocessor on the gzipped traces:

        cd traces
        ./traceParse.py k6_aoe_02_short.trc.gz

        Then go back to the DRAMSim directory and run the trace based simulator:
        cd ..
        ./DRAMSim -t traces/k6_aoe_02_short.trc -s system.ini -d ini/DDR3_micron_64M_8B_x4_sg15.ini -c 10000

4. DRAMSim Output -------------------------------------------------------------

The verbosity of the DRAMSim can be customized in the ini file by turning the
various debug flags on or off in the ini file. 

Below, we have provided a detailed explanation of the simulator output.  With
all DEBUG flags enabled, the following output is displayed for each cycle
executed.  

   NOTE : BP = Bus Packet
          T  = Transaction
          MC = MemoryController
          R# = Rank (index #)

-------------------------------------------------------------
 ----------------- Memory System Update ------------------
 ---------- Memory Controller Update Starting ------------ [8]
 -- R0 Receiving On Bus    : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 -- MC Issuing On Data Bus    : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
 ++ Adding Read energy to total energy
 -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
== New Transaction - Mapping Address [0x5dec800]
  Rank : 0
  Bank : 0
  Row  : 1502
  Col  : 800
 ++ Adding IDD3N to total energy [from rank 0]
 ++ Adding IDD3N to total energy [from rank 1]
== Printing transaction queue
  8]T [Read] [0x45bbfa4]
  9]T [Write] [0x55fbfa0] [5439E]
  10]T [Write] [0x55fbfa8] [1111]
== Printing bank states (According to MC)
[idle] [idle] [2029] [1502] 
[idle] [idle] [1502] [1502] 

== Printing Per Rank, Per Bank Queue
 = Rank 0
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec800] r[0] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec800] r[0] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec810] r[0] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec810] r[0] b[1] row[1502] col[800]
    Bank 2   size : 2
       0]BP [ACT] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
       1]BP [READ_P] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
    Bank 3   size : 1
       0]BP [READ_P] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 = Rank 1
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2   size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3   size : 0
-----------------------------------------------------



  Anything sent on the bus is encapsulated in an BusPacket (BP) object. 
  When printing, they display the following information:
                         BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
  The information displayed  is (in order):command type, physical address,
  rank #, bank#, row #, and column #.

  Lines beginning with " -- " indicate bus traffic, ie, 
     -- R0 Receiving On Bus       : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
     -- MC Issuing On Data Bus    : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
     -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
  Sender and receiver are indicated and the packet being sent is detailed.


  Lines beginning with " ++ " indicate power calculations, ie, 
                 ++ Adding Read energy to total energy
                  ++ Adding IDD3N to total energy [from rank 0]
                  ++ Adding IDD3N to total energy [from rank 1]
  The state of the system and the actions taken determine which current
  draw is used.  for further detail about each current, see micron data-
  sheet.

        If a pending transaction is in the transaction queue, it will
  be printed, as seen below:
                 == Printing transaction queue                
                           1]T [Read] [0x45bbfa4]
                          2]T [Write] [0x55fbfa0] [5439E]
                           3]T [Write] [0x55fbfa8] [1111]
  Currently, at the start of every cycle, the head of the transaction
  queue is removed, broken up into DRAM commands and placed in the
  appropriate command queues.  To do this, an address mapping scheme
  is applied to the transaction's physical address, the output of 
  which is seen below:
                        == New Transaction - Mapping Address [0x5dec800]
                           Rank : 0
                                 Bank : 0
                                 Row  : 1502
                                 Col  : 800

  If there are pending commands in the command queue, they will be
  printed.  The output is dependent on the designated structure for
  the command queue.  For example, per-rank/per-bank queues are 
  shown below:
   = Rank 1
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2   size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3   size : 0

  The state of each bank in the system is also displayed:
    == Printing bank states (According to MC)
    [idle] [idle] [2029] [1502] 
    [idle] [idle] [1502] [1502] 
  Banks can be in many states, including idle, row active (shown
  with the row that is active), refreshing, or precharging.  These
  states will update based on the commands being sent by the 
  controller.  

  push:
    branches: [ "main" ]
  pull_request:                         \texttt{\footnotesize dramninjas \textit{[at]} gmail \textit{[dot]} com}
}
\date{}
\maketitle
\HRule
\tableofcontents
\HRule
\lstset{basicstyle={\scriptsize\ttfamily},tabsize=2,frame=single}
\section{Why Do We Need to Simulate DRAM Systems This Accurately?}
Modern computer system performance is increasingly limited
by the performance of DRAM-based memory systems. As a result, there is great
interest in providing accurate simulations of DRAM based memory systems as part
of architectural research. Unfortunately, there is great difficulty associated
with the study of modern DRAM memory systems, arising from
the fact that DRAM-system performance depends on many
independent variables such as workload characteristics of memory access rate
and request sequence, memory-system architecture, memory-system configuration, DRAM
access protocol, and DRAM device timing parameters. As a result, system
architects and design engineers often disagree on the usefulness of a given
performance-enhancing feature, since the performance impact of that feature typically 
depends on the characteristics of specific workloads, memory-system architecture, 
memory-system configuration, DRAM access protocol and DRAM device timing parameters. 
\subsection{DRAM Scheduling Complexity is Growing}

\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{docs/why1.gif}
\caption{Timing diagram showing complexity of DRAM scheduling}
\label{timingcomplex}
\end{center}
\end{figure}
Figure \ref{timingcomplex} shows the pipelined scheduling of a DDR2 SDRAM device. Despite
the fact that the simulated memory system uses a closed-page policy and 
rotates through available banks on the DRAM device, which should simplify
scheduling considerably, the scheduling of this system is actually more
complex than earlier DRAM systems: for instance, new timing parameters
such as t_{RRD} and t_{FAW} are contributing to the growing
set of timing constraints placed on each successive generation of DRAM 
devices.

\subsection{DRAM performance characteristics changes every generation}
DRAM based memory systems are impacted primarily by two attributes: 
row cycle time and device datarate. Presently, DRAM row cycle times are 
decreasing at a rate of approximately 7\% per year, and DRAM device
datarates are increasing with each new generation of DRAM devices at the rate
of 100\% every three years, 
\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{docs/why2.gif}
\caption{DRAM row cycle time trends}
\label{classes}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{docs/why3.gif}
\caption{DRAM device data rate trends}
\label{classes}
\end{center}
\end{figure}
The difference in the scaling trends of the DRAM device means that 
fundamental DRAM device performance characteristics are changing 
every single generation, and the changing performance characteristics
cannot be accurately predicted by linear extrapolations. The result is 
that no computer architect can rest easy knowing that he or she has 
obtained X\% of performance improvement with a set of microarchitectural
techniques on the current generation memory system, because the same set 
of microarchitectural techniques may not to be as effective in a 
future memory system due to the differences in the scaling attributes 
of DRAM devices, 

\subsection{The Sales Pitch}
Our DRAM-system simulation work enables system architects not
only to explore the impact of a set of microarchitectual techniques on a 
given memory system but also to examine the effectiveness of those 
microarchitectural techniques on a future generation memory system with
future generations of DRAM devices.

\section{About DRAMSim2}
        DRAMSim2 is a cycle accurate model of a DRAM memory controller, the DRAM
        modules which comprise system storage, and the buses by which they
        communicate. 

        The overarching goal is to have a simulator that is small,
        portable, and accurate. The simulator core has a simple interface 
        which allows it to be CPU simulator agnostic and should to work with any simulator (see section \ref{library}).  This core has no external run
        time or build time dependencies and has been tested with g++ on Linux
        as well as g++ on Cygwin on Windows.  

\section{Getting DRAMSim2}

DRAMSim2 is available on \href{http://github.com/dramninjasUMD}{github}. If you have git installed you can clone our repository by typing:\\

\texttt{\$ git clone git://github.com/dramninjasUMD/DRAMSim2.git }



\section{Building DRAMSim2}
        To build an optimized standalone trace-based simulator called \texttt{DRAMSim} simply type:

        \texttt{\$ make}

        For a debug build which contains debugging symbols and verbose output, run:

        \texttt{\$ make DEBUG=1}

        To build the DRAMSim2 library, type: 

        \texttt{\$ make libdramsim.so }

\section{Running DRAMSim2}
\begin{minipage}{\textwidth}
\subsection{Trace-Based Simulation}

In standalone mode, DRAMSim2 can simulate memory system traces. While traces are not as accurate
as a real CPU model driving the memory model, they are convenient since they can be generated in a number of different
ways (instrumentation, hardware traces, CPU simulation, etc.) and reused. 

We've provided a few small sample traces in the \texttt{traces/} directory. These gzipped
traces should first be pre-processed before running through the simulator. 
To run the preprocessor (the preprocessor requires python): 
\begin{lstlisting}
cd traces/
./traceParse.py k6_aoe_02_short.trc.gz
\end{lstlisting}
        This should produce the file \texttt{traces/k6\_aoe\_02\_short.trc}. Then, go back to the DRAMSim2 directory and run the trace based simulator:

\begin{lstlisting}
cd .
./DRAMSim -t traces/k6_aoe_02_short.trc -s system.ini -d ini/DDR3_micron_64M_8B_x4_sg15.ini -c 1000
\end{lstlisting}
        This will run a 1000 cycle simulation of the \texttt{k6\_aoe\_02\_short} trace using 
        the specified DDR3 part. The -s, -d, and -t flags are required to run a simulation.

        A full list of the command line arguments can be obtained by typing:
\begin{lstlisting}
$ ./DRAMSim --help
DRAMSim2 Usage: 
DRAMSim -t tracefile -s system.ini -d ini/device.ini [-c #] [-p pwd] -q
        -t, --tracefile=FILENAME         specify a tracefile to run  
        -s, --systemini=FILENAME         specify an ini file that describes the memory system parameters  
        -d, --deviceini=FILENAME         specify an ini file that describes the device-level parameters
        -c, --numcycles=#                 specify number of cycles to run the simulation for [default=30] 
        -q, --quiet                         flag to suppress simulation output (except final stats) [default=no]
        -o, --option=OPTION_A=234                        overwrite any ini file option from the command line
        -p, --pwd=DIRECTORY                Set the working directory

\end{lstlisting}

        Some traces include timing information, which can be used
        by the simulator or ignored. The benefit of ignoring timing information is that requests
        will stream as fast as possible into the memory system and can serve as a good stress
        test. To toggle the use of clock cycles, please change the \texttt{useClockCycle} flag in \texttt{TraceBasedSim.cpp}.

        If you have a custom trace format you'd like to use, you can modify the \texttt{parseTraceFileLine()} function ton add
        support for your own trace formats. 

        The prefix of the filename determines which type of trace this function will use (ex: k6\_foo.trc) will use the k6 format 
        in \texttt{parseTraceFileLine()}.
\end{minipage}

\subsection{Library Interface}\label{library}
In addition to simulating memory traces, DRAMSim2 can also be built as a dynamic
shared library which is convenient for connecting it to CPU simulators or other
custom front ends.  A \texttt{MemorySystem} object encapsulates the
functionality of the memory system (i.e., the memory controller and DIMMs). The 
classes that comprise DRAMSim2 can be seen in figure \ref{classes}. A
simple example application is provided in the \texttt{example\_app/} directory.
At this time we have plans to provide code to integrate DRAMSim2 into 
\href{http://www.marss86.org/index.php/Home}{MARSSx86},
\href{http://www.cs.sandia.gov/sst/}{SST}, and (eventually)
\href{http://www.m5sim.org/}{M5}.

\begin{figure}[h]
\begin{center}
\includegraphics[width=\linewidth]{docs/classes.png}
\caption{Block diagram of DRAMSim2. The \texttt{\footnotesize recv()} functions are actually called
\texttt{\footnotesize receiveFromBus()} but were abbreviated to save sapce.}
\label{classes}
\end{center}
\end{figure}

\section{Example Output}

\noindent\begin{minipage}{\textwidth}
The verbosity of the DRAMSim2 can be customized in the system.ini file by turning the
various debug flags on or off. 

Below, we have provided a detailed explanation of the simulator output.  With
all DEBUG flags enabled, the following output is displayed for each cycle
executed.  

   \textbf{NOTE} : BP = Bus Packet, T  = Transaction \\ 
                                        MC = MemoryController, R\# = Rank (index \#)

\begin{lstlisting}
 ----------------- Memory System Update ------------------
 ---------- Memory Controller Update Starting ------------ [8]
 -- R0 Receiving On Bus    : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 -- MC Issuing On Data Bus    : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
 ++ Adding Read energy to total energy
 -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
== New Transaction - Mapping Address [0x5dec800] (read)
  Rank : 0
  Bank : 0
  Row  : 1502
  Col  : 800
 ++ Adding IDD3N to total energy [from rank 0]
 ++ Adding IDD3N to total energy [from rank 1]
== Printing transaction queue
  8]T [Read] [0x45bbfa4]
  9]T [Write] [0x55fbfa0] [5439E]
  10]T [Write] [0x55fbfa8] [1111]
== Printing bank states (According to MC)
[idle] [idle] [2029] [1502] 
[idle] [idle] [1502] [1502] 

== Printing Per Rank, Per Bank Queue
 = Rank 0
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec800] r[0] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec800] r[0] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec810] r[0] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec810] r[0] b[1] row[1502] col[800]
    Bank 2   size : 2
       0]BP [ACT] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
       1]BP [READ_P] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
    Bank 3   size : 1
       0]BP [READ_P] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 = Rank 1
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2   size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3   size : 0
\end{lstlisting}
\end{minipage}

\begin{minipage}{\textwidth}
Anything sent on the bus is encapsulated in an BusPacket (BP) object. When
printing, they display the following information:
\begin{lstlisting}
BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
\end{lstlisting}
The information displayed  is (in order): command type, physical address, rank
\#, bank \#, row \#, and column \#.
\end{minipage}


\begin{minipage}{\textwidth}
Lines beginning with " -- " indicate bus traffic, ie, 
\begin{lstlisting}
     -- R0 Receiving On Bus       : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
     -- MC Issuing On Data Bus    : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
     -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
\end{lstlisting}
Sender and receiver are indicated and the packet being sent is detailed.
\end{minipage}

Lines beginning with " ++ " indicate power calculations, ie, 
\begin{lstlisting}
                 ++ Adding Read energy to total energy
                  ++ Adding IDD3N to total energy [from rank 0]
                  ++ Adding IDD3N to total energy [from rank 1]
\end{lstlisting}
The state of the system and the actions taken determine which current draw is used. For further detail about each current value, see Micron datasheet.  


If a pending transaction is in the transaction queue, it will be printed, as seen below:
\begin{lstlisting}
         == Printing transaction queue                
                1]T [Read] [0x45bbfa4]
                2]T [Write] [0x55fbfa0] [5439E]
                3]T [Write] [0x55fbfa8] [1111]
\end{lstlisting}
Currently, at the start of every cycle, the head of the transaction
queue is removed, broken up into DRAM commands and placed in the
appropriate command queues.  To do this, an address mapping scheme
is applied to the transaction's physical address, the output of 
which is seen below:
\begin{lstlisting}
        == New Transaction - Mapping Address [0x5dec800] (read)
         Rank : 0
                 Bank : 0
                 Row  : 1502
                 Col  : 800
\end{lstlisting}

If there are pending commands in the command queue, they will be
printed.  The output is dependent on the designated structure for
the command queue.  For example, per-rank/per-bank queues are 
shown below:
\begin{lstlisting}
   = Rank 1
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2   size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3   size : 0
\end{lstlisting}

The state of each bank in the system is also displayed:
\begin{lstlisting}
    == Printing bank states (According to MC)
    [idle] [idle] [2029] [1502] 
    [idle] [idle] [1502] [1502] 
\end{lstlisting}
Banks can be in many states, including idle, row active (shown
with the row that is active), refreshing, or precharging.  These
states will update based on the commands being sent by the 
controller.  

\section{Results Output}

In addition to printing memory statistics and debug information to standard out, DRAMSim2 also produces
a 'vis' file in the \texttt{results/} directory. A vis file is essentially a summary of relevant statistics that is generated
per epoch (the number of cycles per epoch can be set by changing the \texttt{EPOCH\_COUNT} parameter in the \texttt{system.ini} file). 

We are currently working on DRAMVis, which is a cross-platform viewer which parses the vis file and generates graphs that can be used
to analyze and compare results.

\end{document}
    # The branches below must be a subset of the branches above
    branches: [ "main" ]
  schedule: 1 About DRAMSim2 --------------------------------------------------------------------------------

DRAMSim2 is a cycle accurate model of a DRAM memory controller, the DRAM modules which comprise
system storage, and the buses by which they communicate.
The overarching goal is to have a simulator that is small, portable, and accurate. The simulator core has a
simple interface which allows it to be CPU simulator agnostic and should to work with any simulator (see
section 4.2). This core has no external run time or build time dependencies and has been tested with g++ on
Linux as well as g++ on Cygwin on Windows.

2 Getting DRAMSim2--------------------------------------------------------------------------------

DRAMSim2 is available on github. If you have git installed you can clone our repository by typing:

$ git clone git://github.com/dramninjasUMD/DRAMSim2.git

3 Building DRAMSim2--------------------------------------------------------------------------------

To build an optimized standalone trace-based simulator called DRAMSim simply type:
$ make
For a debug build which contains debugging symbols and verbose output, run:
$ make DEBUG=1

To build the DRAMSim2 library, type:
$ make libdramsim.so


4 Running DRAMSim2--------------------------------------------------------------------------------

4.1 Trace-Based Simulation--------------------------------------------------------------------------------
In standalone mode, DRAMSim2 can simulate memory system traces. While traces are not as accurate as a
real CPU model driving the memory model, they are convenient since they can be generated in a number of
different ways (instrumentation, hardware traces, CPU simulation, etc.) and reused.
We've provided a few small sample traces in the traces/ directory. These gzipped traces should first be pre-
processed before running through the simulator. To run the preprocessor (the preprocessor requires python):

cd traces/
./traceParse.py k6_aoe_02_short.trc.gz
This should produce the file traces/k6aoe02short.trc. Then, go back to the DRAMSim2 directory
and run the trace based simulator:
cd .
./DRAMSim -t traces/k6_aoe_02_short.trc -s system.ini -d ini/DDR3_micron_64M_8B_x4_sg15.ini -c 1000
This will run a 1000 cycle simulation of the k6aoe02short trace using the specified DDR3 part. The -s,
-d, and -t flags are required to run a simulation.
A full list of the command line arguments can be obtained by typing:

$ ./DRAMSim --help
DRAMSim2 Usage:
DRAMSim -t tracefile -s system.ini -d ini/device.ini [-c #] [-p pwd] -q
  -t, --tracefile=FILENAME specify a tracefile to run
  -s, --systemini=FILENAME specify an ini file that describes the memory system parameters
  -d, --deviceini=FILENAME specify an ini file that describes the device-level parameters
  -c, --numcycles=# specify number of cycles to run the simulation for [default=30]
  -q, --quiet flag to suppress simulation output (except final stats) [default=no]
  -o, --option=OPTION_A=234 overwrite any ini file option from the command line
  -p, --pwd=DIRECTORY Set the working directory
Some traces include timing information, which can be used by the simulator or ignored. The benefit of ignoring
timing information is that requests will stream as fast as possible into the memory system and can serve as a good
stress test. To toggle the use of clock cycles, please change the useClockCycle flag in TraceBasedSim.cpp.
If you have a custom trace format you'd like to use, you can modify the parseTraceFileLine() function
ton add support for your own trace formats.
The prefix of the filename determines which type of trace this function will use (ex: k6 foo.trc) will use the k6
format in parseTraceFileLine().

4.2 Library Interface--------------------------------------------------------------------------------

In addition to simulating memory traces, DRAMSim2 can also be built as a dynamic shared library which
is convenient for connecting it to CPU simulators or other custom front ends. A MemorySystem object
encapsulates the functionality of the memory system (i.e., the memory controller and DIMMs). The classes that
comprise DRAMSim2 can be seen in figure 1. A simple example application is provided in the exampleapp/
directory. At this time we have plans to provide code to integrate DRAMSim2 into MARSSx86, SST, and
(eventually) M5.

The verbosity of the DRAMSim2 can be customized in the system.ini file by turning the various debug flags on
or off.
Below, we have provided a detailed explanation of the simulator output. With all DEBUG flags enabled, the
following output is displayed for each cycle executed.
NOTE : BP = Bus Packet, T = Transaction
MC = MemoryController, R# = Rank (index #)
 ----------------- Memory System Update ------------------
 ---------- Memory Controller Update Starting ------------ [8]
 -- R0 Receiving On Bus : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 -- MC Issuing On Data Bus : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
 ++ Adding Read energy to total energy
 -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
== New Transaction - Mapping Address [0x5dec800] (read)
  Rank : 0
  Bank : 0
  Row : 1502
  Col : 800
 ++ Adding IDD3N to total energy [from rank 0]
 ++ Adding IDD3N to total energy [from rank 1]
== Printing transaction queue
  8]T [Read] [0x45bbfa4]
  9]T [Write] [0x55fbfa0] [5439E]
  10]T [Write] [0x55fbfa8] [1111]
== Printing bank states (According to MC)
[idle] [idle] [2029] [1502]
[idle] [idle] [1502] [1502]

== Printing Per Rank, Per Bank Queue
 = Rank 0
    Bank 0 size : 2
       0]BP [ACT] pa[0x5dec800] r[0] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec800] r[0] b[0] row[1502] col[800]
    Bank 1 size : 2
       0]BP [ACT] pa[0x5dec810] r[0] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec810] r[0] b[1] row[1502] col[800]
    Bank 2 size : 2
       0]BP [ACT] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
       1]BP [READ_P] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
    Bank 3 size : 1
       0]BP [READ_P] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 = Rank 1
    Bank 0 size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1 size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2 size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3 size : 0

Anything sent on the bus is encapsulated in an BusPacket (BP) object. When printing, they display the
following information:
BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
The information displayed is (in order): command type, physical address, rank #, bank #, row #, and column
#.


Lines beginning with " -- " indicate bus traffic, ie,
      -- R0 Receiving On Bus : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
      -- MC Issuing On Data Bus : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
      -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]

Sender and receiver are indicated and the packet being sent is detailed.
Lines beginning with " ++ " indicate power calculations, ie,
      ++ Adding Read energy to total energy
      ++ Adding IDD3N to total energy [from rank 0]
      ++ Adding IDD3N to total energy [from rank 1]

The state of the system and the actions taken determine which current draw is used. For further detail about
each current value, see Micron datasheet.
If a pending transaction is in the transaction queue, it will be printed, as seen below:
   == Printing transaction queue
     1]T [Read] [0x45bbfa4]
     2]T [Write] [0x55fbfa0] [5439E]
     3]T [Write] [0x55fbfa8] [1111]

Currently, at the start of every cycle, the head of the transaction queue is removed, broken up into DRAM
commands and placed in the appropriate command queues. To do this, an address mapping scheme is applied
to the transaction's physical address, the output of which is seen below:
  == New Transaction - Mapping Address [0x5dec800] (read)
   Rank : 0
      Bank : 0
      Row : 1502
      Col : 800

If there are pending commands in the command queue, they will be printed. The output is dependent on the
designated structure for the command queue. For example, per-rank/per-bank queues are shown below:
   = Rank 1
     Bank 0 size : 2
         0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
         1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
     Bank 1 size : 2
         0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
         1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
     Bank 2 size : 1
         0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
     Bank 3 size : 0

The state of each bank in the system is also displayed:
     == Printing bank states (According to MC)
     [idle] [idle] [2029] [1502]
     [idle] [idle] [1502] [1502]

Banks can be in many states, including idle, row active (shown with the row that is active), refreshing, or
precharging. These states will update based on the commands being sent by the controller.

6 Results Output--------------------------------------------------------------------------------

In addition to printing memory statistics and debug information to standard out, DRAMSim2 also produces a
'vis' file in the results/ directory. A vis file is essentially a summary of relevant statistics that is generated per
epoch (the number of cycles per epoch can be set by changing the EPOCH_COUNT parameter in the system.ini
file).
We are currently working on DRAMVis, which is a cross-platform viewer which parses the vis file and generates
graphs that can be used to analyze and compare results.





































                                                          6


Figure 1: Block diagram of DRAMSim2. The recv() functions are actually called receiveFromBus() but were
abbreviated to save sapce.





                                                 7


    - cron: '16 22 * * 3'
  workflow_dispatch: 



#include "Rank.h"
#include "MemoryController.h"

using namespace std;
using namespace DRAMSim;

Rank::Rank(ostream &dramsim_log_) :
        id(-1),
        dramsim_log(dramsim_log_),
        isPowerDown(false),
        refreshWaiting(false),
        readReturnCountdown(0),
        banks(NUM_BANKS, Bank(dramsim_log_)),
        bankStates(NUM_BANKS, BankState(dramsim_log_))

{

        memoryController = NULL;
        outgoingDataPacket = NULL;
        dataCyclesLeft = 0;
        currentClockCycle = 0;

#ifndef NO_STORAGE
#endif

}

// mutators
void Rank::setId(int id)
{
        this->id = id;
}

// attachMemoryController() must be called before any other Rank functions
// are called
void Rank::attachMemoryController(MemoryController *memoryController)
{
        this->memoryController = memoryController;
}
Rank::~Rank()
{
        for (size_t i=0; i<readReturnPacket.size(); i++)
        {
                delete readReturnPacket[i];
        }
        readReturnPacket.clear(); 
        delete outgoingDataPacket; 
}
void Rank::receiveFromBus(BusPacket *packet)
{
        if (DEBUG_BUS)
        {
                PRINTN(" -- R" << this->id << " Receiving On Bus    : ");
                packet->print();
        }
        if (VERIFICATION_OUTPUT)
        {
                packet->print(currentClockCycle,false);
        }

        switch (packet->busPacketType)
        {
        case READ:
                //make sure a read is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextRead ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        packet->print();
                        ERROR("== Error - Rank " << id << " received a READ when not allowed");
                        exit(0);
                }

                //update state table
                bankStates[packet->bank].nextPrecharge = max(bankStates[packet->bank].nextPrecharge, currentClockCycle + READ_TO_PRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + max(tCCD, BL/2));
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + READ_TO_WRITE_DELAY);
                }

                //get the read data and put it in the storage which delays until the appropriate time (RL)
#ifndef NO_STORAGE
                banks[packet->bank].read(packet);
#else
                packet->busPacketType = DATA;
#endif
                readReturnPacket.push_back(packet);
                readReturnCountdown.push_back(RL);
                break;
        case READ_P:
                //make sure a read is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextRead ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        ERROR("== Error - Rank " << id << " received a READ_P when not allowed");
                        exit(-1);
                }

                //update state table
                bankStates[packet->bank].currentBankState = Idle;
                bankStates[packet->bank].nextActivate = max(bankStates[packet->bank].nextActivate, currentClockCycle + READ_AUTOPRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        //will set next read/write for all banks - including current (which shouldnt matter since its now idle)
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + max(BL/2, tCCD));
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + READ_TO_WRITE_DELAY);
                }

                //get the read data and put it in the storage which delays until the appropriate time (RL)
#ifndef NO_STORAGE
                banks[packet->bank].read(packet);
#else
                packet->busPacketType = DATA;
#endif

                readReturnPacket.push_back(packet);
                readReturnCountdown.push_back(RL);
                break;
        case WRITE:
                //make sure a write is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextWrite ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        ERROR("== Error - Rank " << id << " received a WRITE when not allowed");
                        bankStates[packet->bank].print();
                        exit(0);
                }

                //update state table
                bankStates[packet->bank].nextPrecharge = max(bankStates[packet->bank].nextPrecharge, currentClockCycle + WRITE_TO_PRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + WRITE_TO_READ_DELAY_B);
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + max(BL/2, tCCD));
                }

                //take note of where data is going when it arrives
                incomingWriteBank = packet->bank;
                incomingWriteRow = packet->row;
                incomingWriteColumn = packet->column;
                delete(packet);
                break;
        case WRITE_P:
                //make sure a write is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextWrite ||
                        packet->row != bankStates[packet->bank].openRowAddress)
                {
                        ERROR("== Error - Rank " << id << " received a WRITE_P when not allowed");
                        exit(0);
                }

                //update state table
                bankStates[packet->bank].currentBankState = Idle;
                bankStates[packet->bank].nextActivate = max(bankStates[packet->bank].nextActivate, currentClockCycle + WRITE_AUTOPRE_DELAY);
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        bankStates[i].nextWrite = max(bankStates[i].nextWrite, currentClockCycle + max(tCCD, BL/2));
                        bankStates[i].nextRead = max(bankStates[i].nextRead, currentClockCycle + WRITE_TO_READ_DELAY_B);
                }

                //take note of where data is going when it arrives
                incomingWriteBank = packet->bank;
                incomingWriteRow = packet->row;
                incomingWriteColumn = packet->column;
                delete(packet);
                break;
        case ACTIVATE:
                //make sure activate is allowed
                if (bankStates[packet->bank].currentBankState != Idle ||
                        currentClockCycle < bankStates[packet->bank].nextActivate)
                {
                        ERROR("== Error - Rank " << id << " received an ACT when not allowed");
                        packet->print();
                        bankStates[packet->bank].print();
                        exit(0);
                }

                bankStates[packet->bank].currentBankState = RowActive;
                bankStates[packet->bank].nextActivate = currentClockCycle + tRC;
                bankStates[packet->bank].openRowAddress = packet->row;

                //if AL is greater than one, then posted-cas is enabled - handle accordingly
                if (AL>0)
                {
                        bankStates[packet->bank].nextWrite = currentClockCycle + (tRCD-AL);
                        bankStates[packet->bank].nextRead = currentClockCycle + (tRCD-AL);
                }
                else
                {
                        bankStates[packet->bank].nextWrite = currentClockCycle + (tRCD-AL);
                        bankStates[packet->bank].nextRead = currentClockCycle + (tRCD-AL);
                }

                bankStates[packet->bank].nextPrecharge = currentClockCycle + tRAS;
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        if (i != packet->bank)
                        {
                                bankStates[i].nextActivate = max(bankStates[i].nextActivate, currentClockCycle + tRRD);
                        }
                }
                delete(packet); 
                break;
        case PRECHARGE:
                //make sure precharge is allowed
                if (bankStates[packet->bank].currentBankState != RowActive ||
                        currentClockCycle < bankStates[packet->bank].nextPrecharge)
                {
                        ERROR("== Error - Rank " << id << " received a PRE when not allowed");
                        exit(0);
                }

                bankStates[packet->bank].currentBankState = Idle;
                bankStates[packet->bank].nextActivate = max(bankStates[packet->bank].nextActivate, currentClockCycle + tRP);
                delete(packet); 
                break;
        case REFRESH:
                refreshWaiting = false;
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        if (bankStates[i].currentBankState != Idle)
                        {
                                ERROR("== Error - Rank " << id << " received a REF when not allowed");
                                exit(0);
                        }
                        bankStates[i].nextActivate = currentClockCycle + tRFC;
                }
                delete(packet); 
                break;
        case DATA:
                // TODO: replace this check with something that works?
                /*
                if(packet->bank != incomingWriteBank ||
                         packet->row != incomingWriteRow ||
                         packet->column != incomingWriteColumn)
                        {
                                cout << "== Error - Rank " << id << " received a DATA packet to the wrong place" << endl;
                                packet->print();
                                bankStates[packet->bank].print();
                                exit(0);
                        }
                */
#ifndef NO_STORAGE
                banks[packet->bank].write(packet);
#else
                // end of the line for the write packet
#endif
                delete(packet);
                break;
        default:
                ERROR("== Error - Unknown BusPacketType trying to be sent to Bank");
                exit(0);
                break;
        }
}

int Rank::getId() const
{
        return this->id;
}

void Rank::update()
{

        // An outgoing packet is one that is currently sending on the bus
        // do the book keeping for the packet's time left on the bus
        if (outgoingDataPacket != NULL)
        {
                dataCyclesLeft--;
                if (dataCyclesLeft == 0)
                {
                        //if the packet is done on the bus, call receiveFromBus and free up the bus
                        memoryController->receiveFromBus(outgoingDataPacket);
                        outgoingDataPacket = NULL;
                }
        }

        // decrement the counter for all packets waiting to be sent back
        for (size_t i=0;i<readReturnCountdown.size();i++)
        {
                readReturnCountdown[i]--;
        }


        if (readReturnCountdown.size() > 0 && readReturnCountdown[0]==0)
        {
                // RL time has passed since the read was issued; this packet is
                // ready to go out on the bus

                outgoingDataPacket = readReturnPacket[0];
                dataCyclesLeft = BL/2;

                // remove the packet from the ranks
                readReturnPacket.erase(readReturnPacket.begin());
                readReturnCountdown.erase(readReturnCountdown.begin());

                if (DEBUG_BUS)
                {
                        PRINTN(" -- R" << this->id << " Issuing On Data Bus : ");
                        outgoingDataPacket->print();
                        PRINT("");
                }

        }
}

//power down the rank
void Rank::powerDown()
{
        //perform checks
        for (size_t i=0;i<NUM_BANKS;i++)
        {
                if (bankStates[i].currentBankState != Idle)
                {
                        ERROR("== Error - Trying to power down rank " << id << " while not all banks are idle");
                        exit(0);
                }

                bankStates[i].nextPowerUp = currentClockCycle + tCKE;
                bankStates[i].currentBankState = PowerDown;
        }

        isPowerDown = true;
}

//power up the rank
void Rank::powerUp()
{
        if (!isPowerDown)
        {
                ERROR("== Error - Trying to power up rank " << id << " while it is not already powered down");
                exit(0);
        }

        isPowerDown = false;

        for (size_t i=0;i<NUM_BANKS;i++)
        {
                if (bankStates[i].nextPowerUp > currentClockCycle)
                {
                        ERROR("== Error - Trying to power up rank " << id << " before we're allowed to");
                        ERROR(bankStates[i].nextPowerUp << "    " << currentClockCycle);
                        exit(0);
                }
                bankStates[i].nextActivate = currentClockCycle + tXP;
                bankStates[i].currentBankState = Idle;
        }
}

jobs: 



#ifndef RANK_H
#define RANK_H

#include "SimulatorObject.h"
#include "BusPacket.h"
#include "SystemConfiguration.h"
#include "Bank.h"
#include "BankState.h"

using namespace std;
using namespace DRAMSim;

namespace DRAMSim
{
class MemoryController; //forward declaration
class Rank : public SimulatorObject
{
private:
        int id;
        ostream &dramsim_log; 
        unsigned incomingWriteBank;
        unsigned incomingWriteRow;
        unsigned incomingWriteColumn;
        bool isPowerDown;

public:
        //functions
        Rank(ostream &dramsim_log_);
        virtual ~Rank(); 
        void receiveFromBus(BusPacket *packet);
        void attachMemoryController(MemoryController *mc);
        int getId() const;
        void setId(int id);
        void update();
        void powerUp();
        void powerDown();

        //fields
        MemoryController *memoryController;
        BusPacket *outgoingDataPacket;
        unsigned dataCyclesLeft;
        bool refreshWaiting;

        //these are vectors so that each element is per-bank
        vector<BusPacket *> readReturnPacket;
        vector<unsigned> readReturnCountdown;
        vector<Bank> banks;
        vector<BankState> bankStates;

};
}
#endif

  Fortify-AST-Scan: 







//SimulatorObject.cpp
//
//Base class for all classes in the simulator
//

#include <cstdlib>
#include "SimulatorObject.h"

using namespace DRAMSim;
using namespace std;

void SimulatorObject::step()
{
        currentClockCycle++;
}


    # Use the appropriate runner for building your source code. Ensure dev tools required to build your code are present and configured appropriately (MSBuild, Python, etc).
    runs-on: ubuntu-latest
    permissions: 







#ifndef SIMULATOROBJ_H
#define SIMULATOROBJ_H

//SimulatorObject.h
//
//Header file for simulator object class
//

#include <stdint.h>

namespace DRAMSim
{
class SimulatorObject
{
public:
        uint64_t currentClockCycle;

        void step();
        virtual void update()=0;
};
}

#endif

      actions: read
      contents: read
      security-events: write

    steps: 


#ifndef SYSCONFIG_H
#define SYSCONFIG_H

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdlib>
#include <stdint.h>
#include "PrintMacros.h"

#ifdef __APPLE__
#include <sys/types.h>
#endif

//SystemConfiguration.h
//
//Configuration values for the current system



//number of latencies per bucket in the latency histogram
//TODO: move to system ini file
#define HISTOGRAM_BIN_SIZE 10

extern std::ofstream cmd_verify_out; //used by BusPacket.cpp if VERIFICATION_OUTPUT is enabled
//extern std::ofstream visDataOut;

//TODO: namespace these to DRAMSim:: 
extern bool VERIFICATION_OUTPUT; // output suitable to feed to modelsim

extern bool DEBUG_TRANS_Q;
extern bool DEBUG_CMD_Q;
extern bool DEBUG_ADDR_MAP;
extern bool DEBUG_BANKSTATE;
extern bool DEBUG_BUS;
extern bool DEBUG_BANKS;
extern bool DEBUG_POWER;
extern bool USE_LOW_POWER;
extern bool VIS_FILE_OUTPUT;

extern uint64_t TOTAL_STORAGE;
extern unsigned NUM_BANKS;
extern unsigned NUM_BANKS_LOG;
extern unsigned NUM_RANKS;
extern unsigned NUM_RANKS_LOG;
extern unsigned NUM_CHANS;
extern unsigned NUM_CHANS_LOG;
extern unsigned NUM_ROWS;
extern unsigned NUM_ROWS_LOG;
extern unsigned NUM_COLS;
extern unsigned NUM_COLS_LOG;
extern unsigned DEVICE_WIDTH;
extern unsigned BYTE_OFFSET_WIDTH;
extern unsigned TRANSACTION_SIZE;
extern unsigned THROW_AWAY_BITS;
extern unsigned COL_LOW_BIT_WIDTH;

//in nanoseconds
extern unsigned REFRESH_PERIOD;
extern float tCK;

extern unsigned CL;
extern unsigned AL;
#define RL (CL+AL)
#define WL (RL-1)
extern unsigned BL;
extern unsigned tRAS;
extern unsigned tRCD;
extern unsigned tRRD;
extern unsigned tRC;
extern unsigned tRP;
extern unsigned tCCD;
extern unsigned tRTP;
extern unsigned tWTR;
extern unsigned tWR;
extern unsigned tRTRS;
extern unsigned tRFC;
extern unsigned tFAW;
extern unsigned tCKE;
extern unsigned tXP;

extern unsigned tCMD;

/* For power parameters (current and voltage), see externs in MemoryController.cpp */ 

extern unsigned NUM_DEVICES;

//same bank
#define READ_TO_PRE_DELAY (AL+BL/2+ max(tRTP,tCCD)-tCCD)
#define WRITE_TO_PRE_DELAY (WL+BL/2+tWR)
#define READ_TO_WRITE_DELAY (RL+BL/2+tRTRS-WL)
#define READ_AUTOPRE_DELAY (AL+tRTP+tRP)
#define WRITE_AUTOPRE_DELAY (WL+BL/2+tWR+tRP)
#define WRITE_TO_READ_DELAY_B (WL+BL/2+tWTR) //interbank
#define WRITE_TO_READ_DELAY_R (WL+BL/2+tRTRS-RL) //interrank

extern unsigned JEDEC_DATA_BUS_BITS;

//Memory Controller related parameters
extern unsigned TRANS_QUEUE_DEPTH;
extern unsigned CMD_QUEUE_DEPTH;

extern unsigned EPOCH_LENGTH;

extern unsigned TOTAL_ROW_ACCESSES;

extern std::string ROW_BUFFER_POLICY;
extern std::string SCHEDULING_POLICY;
extern std::string ADDRESS_MAPPING_SCHEME;
extern std::string QUEUING_STRUCTURE;

enum TraceType
{
        k6,
        mase,
        misc
};

enum AddressMappingScheme
{
        Scheme1,
        Scheme2,
        Scheme3,
        Scheme4,
        Scheme5,
        Scheme6,
        Scheme7
};

// used in MemoryController and CommandQueue
enum RowBufferPolicy
{
        OpenPage,
        ClosePage
};

// Only used in CommandQueue
enum QueuingStructure
{
        PerRank,
        PerRankPerBank
};

enum SchedulingPolicy
{
        RankThenBankRoundRobin,
        BankThenRankRoundRobin
};


// set by IniReader.cpp


namespace DRAMSim
{
typedef void (*returnCallBack_t)(unsigned id, uint64_t addr, uint64_t clockcycle);
typedef void (*powerCallBack_t)(double bgpower, double burstpower, double refreshpower, double actprepower);

extern RowBufferPolicy rowBufferPolicy;
extern SchedulingPolicy schedulingPolicy;
extern AddressMappingScheme addressMappingScheme;
extern QueuingStructure queuingStructure;
//
//FUNCTIONS
//

unsigned inline dramsim_log2(unsigned value)
{
        unsigned logbase2 = 0;
        unsigned orig = value;
        value>>=1;
        while (value>0)
        {
                value >>= 1;
                logbase2++;
        }
        if ((unsigned)1<<logbase2<orig)logbase2++;
        return logbase2;
}
inline bool isPowerOfTwo(unsigned long x)
{
        return (1UL<<dramsim_log2(x)) == x;
}


};

#endif

      # Check out source code
      - name: Check Out Source Code
        uses: actions/checkout@v4

      # Java is required to run the various Fortify utilities. Ensuring proper version is installed on the runner.
      - name: Setup Java
        uses: actions/setup-java@v4
        with: 


//TraceBasedSim.cpp
//
//File to run a trace-based simulation
//

#include <iostream>
#include <fstream>
#include <sstream>
#include <getopt.h>
#include <map>
#include <list>

#include "SystemConfiguration.h"
#include "MemorySystem.h"
#include "MultiChannelMemorySystem.h"
#include "Transaction.h"
#include "IniReader.h"


using namespace DRAMSim;
using namespace std;

//#define RETURN_TRANSACTIONS 1

#ifndef _SIM_
int SHOW_SIM_OUTPUT = 1;
ofstream visDataOut; //mostly used in MemoryController

#ifdef RETURN_TRANSACTIONS
class TransactionReceiver
{
        private: 
                map<uint64_t, list<uint64_t> > pendingReadRequests; 
                map<uint64_t, list<uint64_t> > pendingWriteRequests; 

        public: 
                void add_pending(const Transaction &t, uint64_t cycle)
                {
                        // C++ lists are ordered, so the list will always push to the back and
                        // remove at the front to ensure ordering
                        if (t.transactionType == DATA_READ)
                        {
                                pendingReadRequests[t.address].push_back(cycle); 
                        }
                        else if (t.transactionType == DATA_WRITE)
                        {
                                pendingWriteRequests[t.address].push_back(cycle); 
                        }
                        else
                        {
                                ERROR("This should never happen"); 
                                exit(-1);
                        }
                }

                void read_complete(unsigned id, uint64_t address, uint64_t done_cycle)
                {
                        map<uint64_t, list<uint64_t> >::iterator it;
                        it = pendingReadRequests.find(address); 
                        if (it == pendingReadRequests.end())
                        {
                                ERROR("Cant find a pending read for this one"); 
                                exit(-1);
                        }
                        else
                        {
                                if (it->second.size() == 0)
                                {
                                        ERROR("Nothing here, either"); 
                                        exit(-1); 
                                }
                        }

                        uint64_t added_cycle = pendingReadRequests[address].front();
                        uint64_t latency = done_cycle - added_cycle;

                        pendingReadRequests[address].pop_front();
                        cout << "Read Callback:  0x"<< std::hex << address << std::dec << " latency="<<latency<<"cycles ("<< done_cycle<< "->"<<added_cycle<<")"<<endl;
                }
                void write_complete(unsigned id, uint64_t address, uint64_t done_cycle)
                {
                        map<uint64_t, list<uint64_t> >::iterator it;
                        it = pendingWriteRequests.find(address); 
                        if (it == pendingWriteRequests.end())
                        {
                                ERROR("Cant find a pending read for this one"); 
                                exit(-1);
                        }
                        else
                        {
                                if (it->second.size() == 0)
                                {
                                        ERROR("Nothing here, either"); 
                                        exit(-1); 
                                }
                        }

                        uint64_t added_cycle = pendingWriteRequests[address].front();
                        uint64_t latency = done_cycle - added_cycle;

                        pendingWriteRequests[address].pop_front();
                        cout << "Write Callback: 0x"<< std::hex << address << std::dec << " latency="<<latency<<"cycles ("<< done_cycle<< "->"<<added_cycle<<")"<<endl;
                }
};
#endif

void usage()
{
        cout << "DRAMSim2 Usage: " << endl;
        cout << "DRAMSim -t tracefile -s system.ini -d ini/device.ini [-c #] [-p pwd] [-q] [-S 2048] [-n] [-o OPTION_A=1234,tRC=14,tFAW=19]" <<endl;
        cout << "\t-t, --tracefile=FILENAME \tspecify a tracefile to run  "<<endl;
        cout << "\t-s, --systemini=FILENAME \tspecify an ini file that describes the memory system parameters  "<<endl;
        cout << "\t-d, --deviceini=FILENAME \tspecify an ini file that describes the device-level parameters"<<endl;
        cout << "\t-c, --numcycles=# \t\tspecify number of cycles to run the simulation for [default=30] "<<endl;
        cout << "\t-q, --quiet \t\t\tflag to suppress simulation output (except final stats) [default=no]"<<endl;
        cout << "\t-o, --option=OPTION_A=234,tFAW=14\t\t\toverwrite any ini file option from the command line"<<endl;
        cout << "\t-p, --pwd=DIRECTORY\t\tSet the working directory (i.e. usually DRAMSim directory where ini/ and results/ are)"<<endl;
        cout << "\t-S, --size=# \t\t\tSize of the memory system in megabytes [default=2048M]"<<endl;
        cout << "\t-n, --notiming \t\t\tDo not use the clock cycle information in the trace file"<<endl;
        cout << "\t-v, --visfile \t\t\tVis output filename"<<endl;
}
#endif

void *parseTraceFileLine(string &line, uint64_t &addr, enum TransactionType &transType, uint64_t &clockCycle, TraceType type, bool useClockCycle)
{
        size_t previousIndex=0;
        size_t spaceIndex=0;
        uint64_t *dataBuffer = NULL;
        string addressStr="", cmdStr="", dataStr="", ccStr="";

        switch (type)
        {
        case k6:
        {
                spaceIndex = line.find_first_of(" ", 0);

                addressStr = line.substr(0, spaceIndex);
                previousIndex = spaceIndex;

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                cmdStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);
                previousIndex = line.find_first_of(" ", spaceIndex);

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                ccStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);

                if (cmdStr.compare("P_MEM_WR")==0 ||
                        cmdStr.compare("BOFF")==0)
                {
                        transType = DATA_WRITE;
                }
                else if (cmdStr.compare("P_FETCH")==0 ||
                         cmdStr.compare("P_MEM_RD")==0 ||
                         cmdStr.compare("P_LOCK_RD")==0 ||
                         cmdStr.compare("P_LOCK_WR")==0)
                {
                        transType = DATA_READ;
                }
                else
                {
                        ERROR("== Unknown Command : "<<cmdStr);
                        exit(0);
                }

                istringstream a(addressStr.substr(2));//gets rid of 0x
                a>>hex>>addr;

                //if this is set to false, clockCycle will remain at 0, and every line read from the trace
                //  will be allowed to be issued
                if (useClockCycle)
                {
                        istringstream b(ccStr);
                        b>>clockCycle;
                }
                break;
        }
        case mase:
        {
                spaceIndex = line.find_first_of(" ", 0);

                addressStr = line.substr(0, spaceIndex);
                previousIndex = spaceIndex;

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                cmdStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);
                previousIndex = line.find_first_of(" ", spaceIndex);

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                ccStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);

                if (cmdStr.compare("IFETCH")==0||
                        cmdStr.compare("READ")==0)
                {
                        transType = DATA_READ;
                }
                else if (cmdStr.compare("WRITE")==0)
                {
                        transType = DATA_WRITE;
                }
                else
                {
                        ERROR("== Unknown command in tracefile : "<<cmdStr);
                }

                istringstream a(addressStr.substr(2));//gets rid of 0x
                a>>hex>>addr;

                //if this is set to false, clockCycle will remain at 0, and every line read from the trace
                //  will be allowed to be issued
                if (useClockCycle)
                {
                        istringstream b(ccStr);
                        b>>clockCycle;
                }

                break;
        }
        case misc:
                spaceIndex = line.find_first_of(" ", spaceIndex+1);
                if (spaceIndex == string::npos)
                {
                        ERROR("Malformed line: '"<< line <<"'");
                }

                addressStr = line.substr(previousIndex,spaceIndex);
                previousIndex=spaceIndex;

                spaceIndex = line.find_first_of(" ", spaceIndex+1);
                if (spaceIndex == string::npos)
                {
                        cmdStr = line.substr(previousIndex+1);
                }
                else
                {
                        cmdStr = line.substr(previousIndex+1,spaceIndex-previousIndex-1);
                        dataStr = line.substr(spaceIndex+1);
                }

                //convert address string -> number
                istringstream b(addressStr.substr(2)); //substr(2) chops off 0x characters
                b >>hex>> addr;

                // parse command
                if (cmdStr.compare("read") == 0)
                {
                        transType=DATA_READ;
                }
                else if (cmdStr.compare("write") == 0)
                {
                        transType=DATA_WRITE;
                }
                else
                {
                        ERROR("INVALID COMMAND '"<<cmdStr<<"'");
                        exit(-1);
                }
                if (SHOW_SIM_OUTPUT)
                {
                        DEBUGN("ADDR='"<<hex<<addr<<dec<<"',CMD='"<<transType<<"'");//',DATA='"<<dataBuffer[0]<<"'");
                }

                //parse data
                //if we are running in a no storage mode, don't allocate space, just return NULL
#ifndef NO_STORAGE
                if (dataStr.size() > 0 && transType == DATA_WRITE)
                {
                        // 32 bytes of data per transaction
                        dataBuffer = (uint64_t *)calloc(sizeof(uint64_t),4);
                        size_t strlen = dataStr.size();
                        for (int i=0; i < 4; i++)
                        {
                                size_t startIndex = i*16;
                                if (startIndex > strlen)
                                {
                                        break;
                                }
                                size_t charsLeft = min(((size_t)16), strlen - startIndex + 1);
                                string piece = dataStr.substr(i*16,charsLeft);
                                istringstream iss(piece);
                                iss >> hex >> dataBuffer[i];
                        }
                        PRINTN("\tDATA=");
                        BusPacket::printData(dataBuffer);
                }

                PRINT("");
#endif
                break;
        }
        return dataBuffer;
}

#ifndef _SIM_

void alignTransactionAddress(Transaction &trans)
{
        // zero out the low order bits which correspond to the size of a transaction

        unsigned throwAwayBits = THROW_AWAY_BITS;

        trans.address >>= throwAwayBits;
        trans.address <<= throwAwayBits;
}

/** 
 * Override options can be specified on the command line as -o key1=value1,key2=value2
 * this method should parse the key-value pairs and put them into a map 
 **/ 
IniReader::OverrideMap *parseParamOverrides(const string &kv_str)
{
        IniReader::OverrideMap *kv_map = new IniReader::OverrideMap(); 
        size_t start = 0, comma=0, equal_sign=0;
        // split the commas if they are there
        while (1)
        {
                equal_sign = kv_str.find('=', start); 
                if (equal_sign == string::npos)
                {
                        break;
                }

                comma = kv_str.find(',', equal_sign);
                if (comma == string::npos)
                {
                        comma = kv_str.length();
                }

                string key = kv_str.substr(start, equal_sign-start);
                string value = kv_str.substr(equal_sign+1, comma-equal_sign-1); 

                (*kv_map)[key] = value; 
                start = comma+1;

        }
        return kv_map; 
}

int main(int argc, char **argv)
{
        int c;
        TraceType traceType;
        string traceFileName;
        string systemIniFilename("system.ini");
        string deviceIniFilename;
        string pwdString;
        string *visFilename = NULL;
        unsigned megsOfMemory=2048;
        bool useClockCycle=true;

        IniReader::OverrideMap *paramOverrides = NULL; 

        unsigned numCycles=1000;
        //getopt stuff
        while (1)
        {
                static struct option long_options[] =
                {
                        {"deviceini", required_argument, 0, 'd'},
                        {"tracefile", required_argument, 0, 't'},
                        {"systemini", required_argument, 0, 's'},

                        {"pwd", required_argument, 0, 'p'},
                        {"numcycles",  required_argument,        0, 'c'},
                        {"option",  required_argument,        0, 'o'},
                        {"quiet",  no_argument, &SHOW_SIM_OUTPUT, 'q'},
                        {"help", no_argument, 0, 'h'},
                        {"size", required_argument, 0, 'S'},
                        {"visfile", required_argument, 0, 'v'},
                        {0, 0, 0, 0}
                };
                int option_index=0; //for getopt
                c = getopt_long (argc, argv, "t:s:c:d:o:p:S:v:qn", long_options, &option_index);
                if (c == -1)
                {
                        break;
                }
                switch (c)
                {
                case 0: //TODO: figure out what the hell this does, cuz it never seems to get called
                        if (long_options[option_index].flag != 0) //do nothing on a flag
                        {
                                printf("setting flag\n");
                                break;
                        }
                        printf("option %s",long_options[option_index].name);
                        if (optarg)
                        {
                                printf(" with arg %s", optarg);
                        }
                        printf("\n");
                        break;
                case 'h':
                        usage();
                        exit(0);
                        break;
                case 't':
                        traceFileName = string(optarg);
                        break;
                case 's':
                        systemIniFilename = string(optarg);
                        break;
                case 'd':
                        deviceIniFilename = string(optarg);
                        break;
                case 'c':
                        numCycles = atoi(optarg);
                        break;
                case 'S':
                        megsOfMemory=atoi(optarg);
                        break;
                case 'p':
                        pwdString = string(optarg);
                        break;
                case 'q':
                        SHOW_SIM_OUTPUT=false;
                        break;
                case 'n':
                        useClockCycle=false;
                        break;
                case 'o':
                        paramOverrides = parseParamOverrides(string(optarg)); 
                        break;
                case 'v':
                        visFilename = new string(optarg);
                        break;
                case '?':
                        usage();
                        exit(-1);
                        break;
                }
        }

        // get the trace filename
        string temp = traceFileName.substr(traceFileName.find_last_of("/")+1);

        //get the prefix of the trace name
        temp = temp.substr(0,temp.find_first_of("_"));
        if (temp=="mase")
        {
                traceType = mase;
        }
        else if (temp=="k6")
        {
                traceType = k6;
        }
        else if (temp=="misc")
        {
                traceType = misc;
        }
        else
        {
                ERROR("== Unknown Tracefile Type : "<<temp);
                exit(0);
        }


        // no default value for the default model name
        if (deviceIniFilename.length() == 0)
        {
                ERROR("Please provide a device ini file");
                usage();
                exit(-1);
        }


        //ignore the pwd argument if the argument is an absolute path
        if (pwdString.length() > 0 && traceFileName[0] != '/')
        {
                traceFileName = pwdString + "/" +traceFileName;
        }

        DEBUG("== Loading trace file '"<<traceFileName<<"' == ");

        ifstream traceFile;
        string line;


        MultiChannelMemorySystem *memorySystem = new MultiChannelMemorySystem(deviceIniFilename, systemIniFilename, pwdString, traceFileName, megsOfMemory, visFilename, paramOverrides);
        // set the frequency ratio to 1:1
        memorySystem->setCPUClockSpeed(0); 

        // don't need this anymore 
        delete paramOverrides;


#ifdef RETURN_TRANSACTIONS
        TransactionReceiver transactionReceiver; 
        /* create and register our callback functions */
        Callback_t *read_cb = new Callback<TransactionReceiver, void, unsigned, uint64_t, uint64_t>(&transactionReceiver, &TransactionReceiver::read_complete);
        Callback_t *write_cb = new Callback<TransactionReceiver, void, unsigned, uint64_t, uint64_t>(&transactionReceiver, &TransactionReceiver::write_complete);
        memorySystem->RegisterCallbacks(read_cb, write_cb, NULL);
#endif


        uint64_t addr;
        uint64_t clockCycle=0;
        enum TransactionType transType;

        void *data = NULL;
        int lineNumber = 0;
        Transaction *trans=NULL;
        bool pendingTrans = false;

        traceFile.open(traceFileName.c_str());

        if (!traceFile.is_open())
        {
                cout << "== Error - Could not open trace file"<<endl;
                exit(0);
        }

        for (size_t i=0;i<numCycles;i++)
        {
                if (!pendingTrans)
                {
                        if (!traceFile.eof())
                        {
                                getline(traceFile, line);

                                if (line.size() > 0)
                                {
                                        data = parseTraceFileLine(line, addr, transType,clockCycle, traceType,useClockCycle);
                                        trans = new Transaction(transType, addr, data);
                                        alignTransactionAddress(*trans); 

                                        if (i>=clockCycle)
                                        {
                                                if (!(*memorySystem).addTransaction(trans))
                                                {
                                                        pendingTrans = true;
                                                }
                                                else
                                                {
#ifdef RETURN_TRANSACTIONS
                                                        transactionReceiver.add_pending(trans, i); 
#endif
                                                        // the memory system accepted our request so now it takes ownership of it
                                                        trans = NULL; 
                                                }
                                        }
                                        else
                                        {
                                                pendingTrans = true;
                                        }
                                }
                                else
                                {
                                        DEBUG("WARNING: Skipping line "<<lineNumber<< " ('" << line << "') in tracefile");
                                }
                                lineNumber++;
                        }
                        else
                        {
                                //we're out of trace, set pending=false and let the thing spin without adding transactions
                                pendingTrans = false; 
                        }
                }

                else if (pendingTrans && i >= clockCycle)
                {
                        pendingTrans = !(*memorySystem).addTransaction(trans);
                        if (!pendingTrans)
                        {
#ifdef RETURN_TRANSACTIONS
                                transactionReceiver.add_pending(trans, i); 
#endif
                                trans=NULL;
                        }
                }

                (*memorySystem).update();
        }

        traceFile.close();
        memorySystem->printStats(true);
        // make valgrind happy
        if (trans)
        {
                delete trans;
        }
        delete(memorySystem);
}
#endif
          java-version: 17
          distribution: 'temurin'

      # Perform SAST and optionally SCA scan via Fortify on Demand/Fortify Hosted/Software Security Center, then
      # optionally export SAST results to the GitHub code scanning dashboard. In case further customization is
      # required, you can use sub-actions like fortify/github-action/setup@v1 to set up the various Fortify tools
      # and run them directly from within your pipeline; see https://github.com/fortify/github-action#readme for
      # details.
      - name: Run FoD SAST Scan
        uses: fortify/github-action@a92347297e02391b857e7015792cd1926a4cd418
        with: 
//Transaction.cpp
//
//Class file for transaction object
//        Transaction is considered requests sent from the CPU to
//        the memory controller (read, write, etc.)...

#include "Transaction.h"
#include "PrintMacros.h"

using std::endl;
using std::hex; 
using std::dec; 

namespace DRAMSim {

Transaction::Transaction(TransactionType transType, uint64_t addr, void *dat) :
        transactionType(transType),
        address(addr),
        data(dat)
{}

Transaction::Transaction(const Transaction &t)
        : transactionType(t.transactionType)
          , address(t.address)
          , data(NULL)
          , timeAdded(t.timeAdded)
          , timeReturned(t.timeReturned)
{
        #ifndef NO_STORAGE
        ERROR("Data storage is really outdated and these copies happen in an \n improper way, which will eventually cause problems. Please send an \n email to dramninjas [at] gmail [dot] com if you need data storage");
        abort(); 
        #endif
}

ostream &operator<<(ostream &os, const Transaction &t)
{
        if (t.transactionType == DATA_READ)
        {
                os<<"T [Read] [0x" << hex << t.address << "]" << dec <<endl;
        }
        else if (t.transactionType == DATA_WRITE)
        {
                os<<"T [Write] [0x" << hex << t.address << "] [" << dec << t.data << "]" <<endl;
        }
        else if (t.transactionType == RETURN_DATA)
        {
                os<<"T [Data] [0x" << hex << t.address << "] [" << dec << t.data << "]" <<endl;
        }
        return os; 
}
}

          sast-scan: true
        env: 
#ifndef TRANSACTION_H
#define TRANSACTION_H

//Transaction.h
//
//Header file for transaction object

#include "SystemConfiguration.h"
#include "BusPacket.h"

using std::ostream; 

namespace DRAMSim
{
enum TransactionType
{
        DATA_READ,
        DATA_WRITE,
        RETURN_DATA
};

class Transaction
{
        Transaction();
public:
        //fields
        TransactionType transactionType;
        uint64_t address;
        void *data;
        uint64_t timeAdded;
        uint64_t timeReturned;


        friend ostream &operator<<(ostream &os, const Transaction &t);
        //functions
        Transaction(TransactionType transType, uint64_t addr, void *data);
        Transaction(const Transaction &t);

        BusPacketType getBusPacketType()
        {
                switch (transactionType)
                {
                        case DATA_READ:
                        if (rowBufferPolicy == ClosePage)
                        {
                                return READ_P;
                        }
                        else if (rowBufferPolicy == OpenPage)
                        {
                                return READ; 
                        }
                        else
                        {
                                ERROR("Unknown row buffer policy");
                                abort();
                        }
                        break;
                case DATA_WRITE:
                        if (rowBufferPolicy == ClosePage)
                        {
                                return WRITE_P;
                        }
                        else if (rowBufferPolicy == OpenPage)
                        {
                                return WRITE; 
                        }
                        else
                        {
                                ERROR("Unknown row buffer policy");
                                abort();
                        }
                        break;
                default:
                        ERROR("This transaction type doesn't have a corresponding bus packet type");
                        abort();
                }
        }
};

}

#endif

          ### Required configuration when integrating with Fortify on Demand
          FOD_URL: https://ams.fortify.com
          FOD_TENANT: #!/bin/bash 

#script to add or remove the GPL header from all *.cpp and *.h files
# in a directory. Usage:
#
# ./addgpl.sh [add|remove] directory/


DIRECTORY=$2

if [ -d "$DIRECTORY" ]; then 
        FILES=`find $DIRECTORY -iname '*.h' -or -iname '*.cpp'`
else
        echo "Bad directory"
        exit
fi

if [ "$1" == "add" ] ; then 
        for f in $FILES
        do
                echo "adding to $f"
                mv $f $f.tmp
                cat gpl.txt $f.tmp > $f
        done
elif [ "$1" == "remove" ] ; then 
        NUMLINES=`wc -l gpl.txt | cut -f1 -d' '`
        for f in $FILES
        do 
                HEADER=`head --lines=$NUMLINES $f | diff -w gpl.txt -`
                if [ -z "$HEADER" ] ; then 
                        echo "deleting from $f"
                        mv $f $f.tmp
                        tail --lines=+$NUMLINES $f.tmp > $f
                else 
                        echo "header does not match, skipping $f"
                fi 

        done
fi

 }}
          FOD_USER: #!/usr/bin/python 
"""

This script generates a series of commands to do parameter sweeps. One way to
use this script is to generate a big matrix of configurations and then run them
on different binaries to diff the output.  This can be used as a poor man's
regression test when doing code cleanups (i.e. where functionality is not
supposed to change as a result of a commit.

Or, if you just set a single binary and comment out the diff stuff at the
bottom, it is just a convenient way to do parameter sweeps. 

Since this uses the command line overrides (-o flag), it needs a fairly recent
commit of DRAMSim2
( see: https://github.com/dramninjasUMD/DRAMSim2/commit/e46f525bd274a0b3312002dce3efe83c769ea2ce )

Just redirect the output of this command to a file and then run it in bash. 

"""

import itertools 

parameters = {'QUEUING_STRUCTURE': ['per_rank', 'per_rank_per_bank'],
                                        'ROW_BUFFER_POLICY': ['open_page', 'close_page'],
                                        'SCHEDULING_POLICY': ['rank_then_bank_round_robin','bank_then_rank_round_robin']
                                        }

devices = ['DDR3_micron_64M_8B_x4_sg15.ini', 'DDR2_micron_32M_4B_x4_sg3E.ini'];

traces = ['k6_bsc_vector1.trc', 'k6_video_tracking_128kL2_trace.trc',  'k6_aoe_02_short.trc']
binaries = ['DRAMSim.master', 'DRAMSim.cleanup']

dramsim_flags = '-c 2000000 -n -S 8192 -q '

# get the parameter permutations

master_list = []
for k,v in parameters.iteritems():
#        print v
        master_list.append(v)

paramOverrideList=[]
for i in itertools.product(*master_list):
        tmp=[]
        for j,param in enumerate(i):
                tmp.append("%s=%s"%(parameters.keys()[j],param))
        paramOverrideList.append(",".join(tmp))
#print paramOverrideList

print "#!/bin/bash"
print "rm DRAMSim.*.vis"
i=0
for trace in traces: 
        for device in devices:
                for paramOverrides in paramOverrideList:
                        for executable in binaries:
                                output_file = "%s_%d"%(executable, i)
                                print "./%s -s system.ini -d ini/%s -t traces/%s -o %s %s -v %s &"%(executable, device, trace, paramOverrides, dramsim_flags, output_file)
                        i+=1

print "echo -n waiting"
print "wait"
print "echo OK"
print "echo Starting diff phase"
for x in range(i):
        diff_args="%s_%d.vis %s_%d.vis"%(binaries[0],x,binaries[1],x)
        print "echo %s_%d.vis and %s_%d.vis:"%(binaries[0],x,binaries[1],x)
        print "is_different=`diff -q %s`"%(diff_args)
        print "if [ -n \"$is_different\" ] ; then"        
        print "diff -u %s"%(diff_args); 
        print "fi" }}
          FOD_PASSWORD: ${{secrets.FOD_PAT}}
          ### Optional configuration when integrating with Fortify on Demand
          # EXTRA_PACKAGE_OPTS: -oss                       # Extra 'scancentral package' options, like '-oss'' if
                                                           # Debricked SCA scan is enabled on Fortify on Demand
          # EXTRA_FOD_LOGIN_OPTS: --socket-timeout=60s     # Extra 'fcli fod session login' options
          # FOD_RELEASE: MyApp:MyRelease                   # FoD release name, default: <org>/<repo>:<branch>; may
                                                           # replace app+release name with numeric release ID
          # DO_WAIT: true                                  # Wait for scan completion, implied if 'DO_EXPORT: true'
          # DO_EXPORT: true                                # Export SAST results to GitHub code scanning dashboard
          ### Required configuration when integrating with Fortify Hosted / Software Security Center & ScanCentral
          # SSC_URL: ${{secrets.SSC_URL}}                            # SSC URL
          # SSC_TOKEN: ${{secrets.SSC_TOKEN}}                        # SSC CIToken or AutomationToken
          # SC_SAST_TOKEN: ${{secrets.SC_SAST_TOKEN}}                # ScanCentral SAST client auth token
          # SC_SAST_SENSOR_VERSION: ${{vars.SC_SAST_SENSOR_VERSION}} # Sensor version on which to run the scan;
                                                                     # usually defined as organization or repo variable
          ### Optional configuration when integrating with Fortify Hosted / Software Security Center & ScanCentral
          # EXTRA_SC_SAST_LOGIN_OPTS: --socket-timeout=60s # Extra 'fcli sc-sast session login' options
          # SSC_APPVERSION: MyApp:MyVersion                # SSC application version, default: <org>/<repo>:<branch>
          # EXTRA_PACKAGE_OPTS: -bv myCustomPom.xml        # Extra 'scancentral package' options
          # DO_WAIT: true                                  # Wait for scan completion, implied if 'DO_EXPORT: true'
          # DO_EXPORT: true                                # Export SAST results to GitHub code scanning dashboard

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will download a prebuilt Ruby version, install dependencies and run tests with Rake
# For more information see: https://github.com/marketplace/actions/setup-ruby-jruby-and-truffleruby

name: Ruby

on: keyword = "apache"
template = """
parse "* - * [*] \\"* * *\\" * *" as ip, name, timestamp, method, url, protocol, status, contentlength
"""
  push: keyword = "k8singressnginx"
template = """
parse "* - * [*] \\"* * *\\" * * \\"*\\" \\"*\\" * * [*] [*] * * * * *" as remote_addr, remote_user, timestamp, method, url, protocol, status, body_bytes_sent, http_referer, http_user_agent, request_length, request_time, proxy_upstream_name, proxy_alternative_upstream_name, upstream_addr, upstream_response_length, upstream_response_time, upstream_status, req_id
"""
    branches: [ "main" ]
  pull_request: keyword = "testmultioperator"
template = """
json | count
"""
    branches: [ "main" ]

permissions: keyword = "nginx"
template = """
parse "* - * [*] \\"* * *\\" * * \\"*\\" \\"*\\" \\"*\\"" as addr, user, timestamp, method, url, protocol, status, bytes_sent, http_referer, http_user_agent, gzip_ratio
"""
  contents: read

jobs: use ag::pipeline::{ErrorReporter, OutputMode, Pipeline, QueryContainer};
use annotate_snippets::snippet::Snippet;
use criterion::{black_box, criterion_group, criterion_main, Criterion, Throughput};
use std::fs::File;
use std::io::{BufRead, BufReader, Write};
use std::time::Duration;

/// An ErrorReporter that writes errors related to the query string to the terminal
struct NopErrorReporter {}

impl ErrorReporter for NopErrorReporter {
    fn handle_error(&self, _snippet: Snippet) {}
}

struct NopWriter {}

impl Write for NopWriter {
    fn write(&mut self, buf: &[u8]) -> Result<usize, std::io::Error> {
        Ok(buf.len())
    }

    fn flush(&mut self) -> Result<(), std::io::Error> {
        Ok(())
    }
}

struct E2eTest {
    name: String,
    query: String,
    file: String,
}

pub fn criterion_benchmark(c: &mut Criterion) {
    let tests = vec![
        E2eTest {
            name: "star".to_owned(),
            query: "*".to_owned(),
            file: "benches/10k.inp".to_owned(),
        },
        E2eTest {
            name: "star-parse-count".to_owned(),
            query: "* | parse '*' as k | count by k".to_owned(),
            file: "benches/10k.inp".to_owned(),
        },
        E2eTest {
            name: "star-count-parse-count".to_owned(),
            query: "* | count | parse '*' as k | count by k".to_owned(),
            file: "benches/1k.inp".to_owned(),
        },
    ];
    tests.into_iter().for_each(|test| {
        let query_container = QueryContainer::new(test.query, Box::new(NopErrorReporter {}));
        let mut group = c.benchmark_group("e2e_query");
        let num_elems = BufReader::new(File::open(&test.file).unwrap())
            .lines()
            .count();
        group.measurement_time(Duration::from_secs(25));
        group.throughput(Throughput::Elements(num_elems as u64));

        let name = test.name;
        let file = &test.file;
        group.bench_function(name, |b| {
            b.iter(|| {
                let pipeline =
                    Pipeline::new(&query_container, NopWriter {}, OutputMode::Legacy).unwrap();
                let f = File::open(file).unwrap();
                pipeline.process(black_box(BufReader::new(f)))
            })
        });
        group.finish();
    })
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
  test: use ag::data::Record;
use ag::lang::Keyword;
use ag::operator::UnaryPreAggFunction;

use ag::operator::parse::{Parse, ParseOptions};
use criterion::{criterion_group, criterion_main, BatchSize, Criterion, Throughput};

pub fn criterion_benchmark(c: &mut Criterion) {
    let parser = Parse::new(
        Keyword::new_wildcard("IP * > \"*\": * length *".to_string()).to_regex(),
        vec![
            "sender".to_string(),
            "recip".to_string(),
            "ignore".to_string(),
            "length".to_string(),
        ],
        None,
        ParseOptions {
            drop_nonmatching: true,
        },
    );
    let mut group = c.benchmark_group("parse_operator");
    group.throughput(Throughput::Elements(1));
    group.bench_function("ip query", |b| {
        b.iter_batched(
            || {
                Record::new(
                    "17:12:14.214111 IP 10.0.2.243.53938 > \"taotie.canonical.com.http\": \
             Flags [.], ack 56575, win 2375, options [nop,nop,TS val 13651369 ecr 169698010], \
             length 99",
                )
            },
            |rec| parser.process(rec),
            BatchSize::SmallInput,
        )
    });
    group.finish();
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);

    runs-on: ubuntu-latest
    strategy: #!/usr/bin/env bash
# Script for building your rust projects.
set -e

source ci/common.bash

# $1 {path} = Path to cross/cargo executable
CROSS=$1
# $1 {string} = <Target Triple> e.g. x86_64-pc-windows-msvc
TARGET_TRIPLE=$2
# $3 {boolean} = Are we building for deployment? 
RELEASE_BUILD=$3

required_arg $CROSS 'CROSS'
required_arg $TARGET_TRIPLE '<Target Triple>'

if [ -z "$RELEASE_BUILD" ]; then
    $CROSS build --target $TARGET_TRIPLE
    $CROSS build --target $TARGET_TRIPLE --all-features
else
    $CROSS build --target $TARGET_TRIPLE --all-features --release
fi

      matrix: required_arg() {
    if [ -z "$1" ]; then
        echo "Required argument $2 missing"
        exit 1
    fi
}
        ruby-version: ['2.6', '2.7', '3.0']

    steps: #!/usr/bin/env bash
set -e
rustup default $1
rustup target add $2
    - uses: actions/checkout@v4
    - name: Set up Ruby
    # To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
    # change this to (see https://github.com/ruby/setup-ruby#versioning):
    # uses: ruby/setup-ruby@v1
      uses: ruby/setup-ruby@55283cc23133118229fd3f97f9336ee23a179fcf # v1.146.0
      with: #!/usr/bin/env bash
# Script for building your rust projects.
set -e

source ci/common.bash

# $1 {path} = Path to cross/cargo executable
CROSS=$1
# $1 {string} = <Target Triple>
TARGET_TRIPLE=$2

required_arg $CROSS 'CROSS'
required_arg $TARGET_TRIPLE '<Target Triple>'

$CROSS test --target $TARGET_TRIPLE
$CROSS test --target $TARGET_TRIPLE --all-features
        ruby-version: ${{ class AgrindBin < Formula
  version 'v0.7.3'
  desc "Slice and dice log files on the command-line"
  homepage "https://github.com/rcoh/angle-grinder"

  if OS.mac?
      url "https://github.com/rcoh/angle-grinder/releases/download/#{version}/angle_grinder-#{version}-x86_64-apple-darwin.tar.gz"
      sha256 "d0682656294bc5d764d4110ae93add1442f6420bff49dcc4d49cb635950014fb"
  elsif OS.linux?
      url "https://github.com/rcoh/angle-grinder/releases/download/#{version}/angle_grinder-#{version}-x86_64-unknown-linux-musl.tar.gz"
      sha256 "6dc5438443e653e5d893c6858d0f9279205728314292636c7b5b18706a9aa759"
  end


  def install
    bin.install "agrind"
  end
end }}
        bundler-cache: true # runs 'bundle install' and caches installed gems automatically
    - name: Run tests
      run: bundle exec rake

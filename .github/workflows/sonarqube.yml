# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# This workflow helps you trigger a SonarQube analysis of your code and populates
# GitHub Code Scanning alerts with the vulnerabilities found.
# (this feature is available starting from SonarQube 9.7, Developer Edition and above)

# 1. Make sure you add a valid GitHub configuration to your SonarQube (Administration > DevOps platforms > GitHub)

# 2. Import your project on SonarQube
#     * Add your repository as a new project by clicking "Create project" from your homepage.
#
# 3. Select GitHub Actions as your CI and follow the tutorial
#     * a. Generate a new token and add it to your GitHub repository's secrets using the name SONAR_TOKEN
#          (On SonarQube, click on your avatar on top-right > My account > Security or ask your administrator)
#
#     * b. Copy/paste your SonarQube host URL to your GitHub repository's secrets using the name SONAR_HOST_URL
#
#     * c. Copy/paste the project Key into the args parameter below
#          (You'll find this information in SonarQube by following the tutorial or by clicking on Project Information at the top-right of your project's homepage)

# Feel free to take a look at our documentation (https://docs.sonarqube.org/latest/analysis/github-integration/)
# or reach out to our community forum if you need some help (https://community.sonarsource.com/c/sq/10)

name: SonarQube analysis

on: //SimulatorObject.cpp
//
//Base class for all classes in the simulator
//

#include <cstdlib>
#include "SimulatorObject.h"

using namespace DRAMSim;
using namespace std;

void SimulatorObject::step()
{
        currentClockCycle++;
}


  push: 
#ifndef SIMULATOROBJ_H
#define SIMULATOROBJ_H

//SimulatorObject.h
//
//Header file for simulator object class
//

#include <stdint.h>

namespace DRAMSim
{
class SimulatorObject
{
public:
        uint64_t currentClockCycle;

        void step();
        virtual void update()=0;
};
}

#endif

    branches: [ "main" ]
  pull_request: #ifndef SYSCONFIG_H
#define SYSCONFIG_H

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdlib>
#include <stdint.h>
#include "PrintMacros.h"

#ifdef __APPLE__
#include <sys/types.h>
#endif

//SystemConfiguration.h
//
//Configuration values for the current system



//number of latencies per bucket in the latency histogram
//TODO: move to system ini file
#define HISTOGRAM_BIN_SIZE 10

extern std::ofstream cmd_verify_out; //used by BusPacket.cpp if VERIFICATION_OUTPUT is enabled
//extern std::ofstream visDataOut;

//TODO: namespace these to DRAMSim:: 
extern bool VERIFICATION_OUTPUT; // output suitable to feed to modelsim

extern bool DEBUG_TRANS_Q;
extern bool DEBUG_CMD_Q;
extern bool DEBUG_ADDR_MAP;
extern bool DEBUG_BANKSTATE;
extern bool DEBUG_BUS;
extern bool DEBUG_BANKS;
extern bool DEBUG_POWER;
extern bool USE_LOW_POWER;
extern bool VIS_FILE_OUTPUT;

extern uint64_t TOTAL_STORAGE;
extern unsigned NUM_BANKS;
extern unsigned NUM_BANKS_LOG;
extern unsigned NUM_RANKS;
extern unsigned NUM_RANKS_LOG;
extern unsigned NUM_CHANS;
extern unsigned NUM_CHANS_LOG;
extern unsigned NUM_ROWS;
extern unsigned NUM_ROWS_LOG;
extern unsigned NUM_COLS;
extern unsigned NUM_COLS_LOG;
extern unsigned DEVICE_WIDTH;
extern unsigned BYTE_OFFSET_WIDTH;
extern unsigned TRANSACTION_SIZE;
extern unsigned THROW_AWAY_BITS;
extern unsigned COL_LOW_BIT_WIDTH;

//in nanoseconds
extern unsigned REFRESH_PERIOD;
extern float tCK;

extern unsigned CL;
extern unsigned AL;
#define RL (CL+AL)
#define WL (RL-1)
extern unsigned BL;
extern unsigned tRAS;
extern unsigned tRCD;
extern unsigned tRRD;
extern unsigned tRC;
extern unsigned tRP;
extern unsigned tCCD;
extern unsigned tRTP;
extern unsigned tWTR;
extern unsigned tWR;
extern unsigned tRTRS;
extern unsigned tRFC;
extern unsigned tFAW;
extern unsigned tCKE;
extern unsigned tXP;

extern unsigned tCMD;

/* For power parameters (current and voltage), see externs in MemoryController.cpp */ 

extern unsigned NUM_DEVICES;

//same bank
#define READ_TO_PRE_DELAY (AL+BL/2+ max(tRTP,tCCD)-tCCD)
#define WRITE_TO_PRE_DELAY (WL+BL/2+tWR)
#define READ_TO_WRITE_DELAY (RL+BL/2+tRTRS-WL)
#define READ_AUTOPRE_DELAY (AL+tRTP+tRP)
#define WRITE_AUTOPRE_DELAY (WL+BL/2+tWR+tRP)
#define WRITE_TO_READ_DELAY_B (WL+BL/2+tWTR) //interbank
#define WRITE_TO_READ_DELAY_R (WL+BL/2+tRTRS-RL) //interrank

extern unsigned JEDEC_DATA_BUS_BITS;

//Memory Controller related parameters
extern unsigned TRANS_QUEUE_DEPTH;
extern unsigned CMD_QUEUE_DEPTH;

extern unsigned EPOCH_LENGTH;

extern unsigned TOTAL_ROW_ACCESSES;

extern std::string ROW_BUFFER_POLICY;
extern std::string SCHEDULING_POLICY;
extern std::string ADDRESS_MAPPING_SCHEME;
extern std::string QUEUING_STRUCTURE;

enum TraceType
{
        k6,
        mase,
        misc
};

enum AddressMappingScheme
{
        Scheme1,
        Scheme2,
        Scheme3,
        Scheme4,
        Scheme5,
        Scheme6,
        Scheme7
};

// used in MemoryController and CommandQueue
enum RowBufferPolicy
{
        OpenPage,
        ClosePage
};

// Only used in CommandQueue
enum QueuingStructure
{
        PerRank,
        PerRankPerBank
};

enum SchedulingPolicy
{
        RankThenBankRoundRobin,
        BankThenRankRoundRobin
};


// set by IniReader.cpp


namespace DRAMSim
{
typedef void (*returnCallBack_t)(unsigned id, uint64_t addr, uint64_t clockcycle);
typedef void (*powerCallBack_t)(double bgpower, double burstpower, double refreshpower, double actprepower);

extern RowBufferPolicy rowBufferPolicy;
extern SchedulingPolicy schedulingPolicy;
extern AddressMappingScheme addressMappingScheme;
extern QueuingStructure queuingStructure;
//
//FUNCTIONS
//

unsigned inline dramsim_log2(unsigned value)
{
        unsigned logbase2 = 0;
        unsigned orig = value;
        value>>=1;
        while (value>0)
        {
                value >>= 1;
                logbase2++;
        }
        if ((unsigned)1<<logbase2<orig)logbase2++;
        return logbase2;
}
inline bool isPowerOfTwo(unsigned long x)
{
        return (1UL<<dramsim_log2(x)) == x;
}


};

#endif

    branches: [ "main" ]
  workflow_dispatch: //TraceBasedSim.cpp
//
//File to run a trace-based simulation
//

#include <iostream>
#include <fstream>
#include <sstream>
#include <getopt.h>
#include <map>
#include <list>

#include "SystemConfiguration.h"
#include "MemorySystem.h"
#include "MultiChannelMemorySystem.h"
#include "Transaction.h"
#include "IniReader.h"


using namespace DRAMSim;
using namespace std;

//#define RETURN_TRANSACTIONS 1

#ifndef _SIM_
int SHOW_SIM_OUTPUT = 1;
ofstream visDataOut; //mostly used in MemoryController

#ifdef RETURN_TRANSACTIONS
class TransactionReceiver
{
        private: 
                map<uint64_t, list<uint64_t> > pendingReadRequests; 
                map<uint64_t, list<uint64_t> > pendingWriteRequests; 

        public: 
                void add_pending(const Transaction &t, uint64_t cycle)
                {
                        // C++ lists are ordered, so the list will always push to the back and
                        // remove at the front to ensure ordering
                        if (t.transactionType == DATA_READ)
                        {
                                pendingReadRequests[t.address].push_back(cycle); 
                        }
                        else if (t.transactionType == DATA_WRITE)
                        {
                                pendingWriteRequests[t.address].push_back(cycle); 
                        }
                        else
                        {
                                ERROR("This should never happen"); 
                                exit(-1);
                        }
                }

                void read_complete(unsigned id, uint64_t address, uint64_t done_cycle)
                {
                        map<uint64_t, list<uint64_t> >::iterator it;
                        it = pendingReadRequests.find(address); 
                        if (it == pendingReadRequests.end())
                        {
                                ERROR("Cant find a pending read for this one"); 
                                exit(-1);
                        }
                        else
                        {
                                if (it->second.size() == 0)
                                {
                                        ERROR("Nothing here, either"); 
                                        exit(-1); 
                                }
                        }

                        uint64_t added_cycle = pendingReadRequests[address].front();
                        uint64_t latency = done_cycle - added_cycle;

                        pendingReadRequests[address].pop_front();
                        cout << "Read Callback:  0x"<< std::hex << address << std::dec << " latency="<<latency<<"cycles ("<< done_cycle<< "->"<<added_cycle<<")"<<endl;
                }
                void write_complete(unsigned id, uint64_t address, uint64_t done_cycle)
                {
                        map<uint64_t, list<uint64_t> >::iterator it;
                        it = pendingWriteRequests.find(address); 
                        if (it == pendingWriteRequests.end())
                        {
                                ERROR("Cant find a pending read for this one"); 
                                exit(-1);
                        }
                        else
                        {
                                if (it->second.size() == 0)
                                {
                                        ERROR("Nothing here, either"); 
                                        exit(-1); 
                                }
                        }

                        uint64_t added_cycle = pendingWriteRequests[address].front();
                        uint64_t latency = done_cycle - added_cycle;

                        pendingWriteRequests[address].pop_front();
                        cout << "Write Callback: 0x"<< std::hex << address << std::dec << " latency="<<latency<<"cycles ("<< done_cycle<< "->"<<added_cycle<<")"<<endl;
                }
};
#endif

void usage()
{
        cout << "DRAMSim2 Usage: " << endl;
        cout << "DRAMSim -t tracefile -s system.ini -d ini/device.ini [-c #] [-p pwd] [-q] [-S 2048] [-n] [-o OPTION_A=1234,tRC=14,tFAW=19]" <<endl;
        cout << "\t-t, --tracefile=FILENAME \tspecify a tracefile to run  "<<endl;
        cout << "\t-s, --systemini=FILENAME \tspecify an ini file that describes the memory system parameters  "<<endl;
        cout << "\t-d, --deviceini=FILENAME \tspecify an ini file that describes the device-level parameters"<<endl;
        cout << "\t-c, --numcycles=# \t\tspecify number of cycles to run the simulation for [default=30] "<<endl;
        cout << "\t-q, --quiet \t\t\tflag to suppress simulation output (except final stats) [default=no]"<<endl;
        cout << "\t-o, --option=OPTION_A=234,tFAW=14\t\t\toverwrite any ini file option from the command line"<<endl;
        cout << "\t-p, --pwd=DIRECTORY\t\tSet the working directory (i.e. usually DRAMSim directory where ini/ and results/ are)"<<endl;
        cout << "\t-S, --size=# \t\t\tSize of the memory system in megabytes [default=2048M]"<<endl;
        cout << "\t-n, --notiming \t\t\tDo not use the clock cycle information in the trace file"<<endl;
        cout << "\t-v, --visfile \t\t\tVis output filename"<<endl;
}
#endif

void *parseTraceFileLine(string &line, uint64_t &addr, enum TransactionType &transType, uint64_t &clockCycle, TraceType type, bool useClockCycle)
{
        size_t previousIndex=0;
        size_t spaceIndex=0;
        uint64_t *dataBuffer = NULL;
        string addressStr="", cmdStr="", dataStr="", ccStr="";

        switch (type)
        {
        case k6:
        {
                spaceIndex = line.find_first_of(" ", 0);

                addressStr = line.substr(0, spaceIndex);
                previousIndex = spaceIndex;

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                cmdStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);
                previousIndex = line.find_first_of(" ", spaceIndex);

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                ccStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);

                if (cmdStr.compare("P_MEM_WR")==0 ||
                        cmdStr.compare("BOFF")==0)
                {
                        transType = DATA_WRITE;
                }
                else if (cmdStr.compare("P_FETCH")==0 ||
                         cmdStr.compare("P_MEM_RD")==0 ||
                         cmdStr.compare("P_LOCK_RD")==0 ||
                         cmdStr.compare("P_LOCK_WR")==0)
                {
                        transType = DATA_READ;
                }
                else
                {
                        ERROR("== Unknown Command : "<<cmdStr);
                        exit(0);
                }

                istringstream a(addressStr.substr(2));//gets rid of 0x
                a>>hex>>addr;

                //if this is set to false, clockCycle will remain at 0, and every line read from the trace
                //  will be allowed to be issued
                if (useClockCycle)
                {
                        istringstream b(ccStr);
                        b>>clockCycle;
                }
                break;
        }
        case mase:
        {
                spaceIndex = line.find_first_of(" ", 0);

                addressStr = line.substr(0, spaceIndex);
                previousIndex = spaceIndex;

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                cmdStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);
                previousIndex = line.find_first_of(" ", spaceIndex);

                spaceIndex = line.find_first_not_of(" ", previousIndex);
                ccStr = line.substr(spaceIndex, line.find_first_of(" ", spaceIndex) - spaceIndex);

                if (cmdStr.compare("IFETCH")==0||
                        cmdStr.compare("READ")==0)
                {
                        transType = DATA_READ;
                }
                else if (cmdStr.compare("WRITE")==0)
                {
                        transType = DATA_WRITE;
                }
                else
                {
                        ERROR("== Unknown command in tracefile : "<<cmdStr);
                }

                istringstream a(addressStr.substr(2));//gets rid of 0x
                a>>hex>>addr;

                //if this is set to false, clockCycle will remain at 0, and every line read from the trace
                //  will be allowed to be issued
                if (useClockCycle)
                {
                        istringstream b(ccStr);
                        b>>clockCycle;
                }

                break;
        }
        case misc:
                spaceIndex = line.find_first_of(" ", spaceIndex+1);
                if (spaceIndex == string::npos)
                {
                        ERROR("Malformed line: '"<< line <<"'");
                }

                addressStr = line.substr(previousIndex,spaceIndex);
                previousIndex=spaceIndex;

                spaceIndex = line.find_first_of(" ", spaceIndex+1);
                if (spaceIndex == string::npos)
                {
                        cmdStr = line.substr(previousIndex+1);
                }
                else
                {
                        cmdStr = line.substr(previousIndex+1,spaceIndex-previousIndex-1);
                        dataStr = line.substr(spaceIndex+1);
                }

                //convert address string -> number
                istringstream b(addressStr.substr(2)); //substr(2) chops off 0x characters
                b >>hex>> addr;

                // parse command
                if (cmdStr.compare("read") == 0)
                {
                        transType=DATA_READ;
                }
                else if (cmdStr.compare("write") == 0)
                {
                        transType=DATA_WRITE;
                }
                else
                {
                        ERROR("INVALID COMMAND '"<<cmdStr<<"'");
                        exit(-1);
                }
                if (SHOW_SIM_OUTPUT)
                {
                        DEBUGN("ADDR='"<<hex<<addr<<dec<<"',CMD='"<<transType<<"'");//',DATA='"<<dataBuffer[0]<<"'");
                }

                //parse data
                //if we are running in a no storage mode, don't allocate space, just return NULL
#ifndef NO_STORAGE
                if (dataStr.size() > 0 && transType == DATA_WRITE)
                {
                        // 32 bytes of data per transaction
                        dataBuffer = (uint64_t *)calloc(sizeof(uint64_t),4);
                        size_t strlen = dataStr.size();
                        for (int i=0; i < 4; i++)
                        {
                                size_t startIndex = i*16;
                                if (startIndex > strlen)
                                {
                                        break;
                                }
                                size_t charsLeft = min(((size_t)16), strlen - startIndex + 1);
                                string piece = dataStr.substr(i*16,charsLeft);
                                istringstream iss(piece);
                                iss >> hex >> dataBuffer[i];
                        }
                        PRINTN("\tDATA=");
                        BusPacket::printData(dataBuffer);
                }

                PRINT("");
#endif
                break;
        }
        return dataBuffer;
}

#ifndef _SIM_

void alignTransactionAddress(Transaction &trans)
{
        // zero out the low order bits which correspond to the size of a transaction

        unsigned throwAwayBits = THROW_AWAY_BITS;

        trans.address >>= throwAwayBits;
        trans.address <<= throwAwayBits;
}

/** 
 * Override options can be specified on the command line as -o key1=value1,key2=value2
 * this method should parse the key-value pairs and put them into a map 
 **/ 
IniReader::OverrideMap *parseParamOverrides(const string &kv_str)
{
        IniReader::OverrideMap *kv_map = new IniReader::OverrideMap(); 
        size_t start = 0, comma=0, equal_sign=0;
        // split the commas if they are there
        while (1)
        {
                equal_sign = kv_str.find('=', start); 
                if (equal_sign == string::npos)
                {
                        break;
                }

                comma = kv_str.find(',', equal_sign);
                if (comma == string::npos)
                {
                        comma = kv_str.length();
                }

                string key = kv_str.substr(start, equal_sign-start);
                string value = kv_str.substr(equal_sign+1, comma-equal_sign-1); 

                (*kv_map)[key] = value; 
                start = comma+1;

        }
        return kv_map; 
}

int main(int argc, char **argv)
{
        int c;
        TraceType traceType;
        string traceFileName;
        string systemIniFilename("system.ini");
        string deviceIniFilename;
        string pwdString;
        string *visFilename = NULL;
        unsigned megsOfMemory=2048;
        bool useClockCycle=true;

        IniReader::OverrideMap *paramOverrides = NULL; 

        unsigned numCycles=1000;
        //getopt stuff
        while (1)
        {
                static struct option long_options[] =
                {
                        {"deviceini", required_argument, 0, 'd'},
                        {"tracefile", required_argument, 0, 't'},
                        {"systemini", required_argument, 0, 's'},

                        {"pwd", required_argument, 0, 'p'},
                        {"numcycles",  required_argument,        0, 'c'},
                        {"option",  required_argument,        0, 'o'},
                        {"quiet",  no_argument, &SHOW_SIM_OUTPUT, 'q'},
                        {"help", no_argument, 0, 'h'},
                        {"size", required_argument, 0, 'S'},
                        {"visfile", required_argument, 0, 'v'},
                        {0, 0, 0, 0}
                };
                int option_index=0; //for getopt
                c = getopt_long (argc, argv, "t:s:c:d:o:p:S:v:qn", long_options, &option_index);
                if (c == -1)
                {
                        break;
                }
                switch (c)
                {
                case 0: //TODO: figure out what the hell this does, cuz it never seems to get called
                        if (long_options[option_index].flag != 0) //do nothing on a flag
                        {
                                printf("setting flag\n");
                                break;
                        }
                        printf("option %s",long_options[option_index].name);
                        if (optarg)
                        {
                                printf(" with arg %s", optarg);
                        }
                        printf("\n");
                        break;
                case 'h':
                        usage();
                        exit(0);
                        break;
                case 't':
                        traceFileName = string(optarg);
                        break;
                case 's':
                        systemIniFilename = string(optarg);
                        break;
                case 'd':
                        deviceIniFilename = string(optarg);
                        break;
                case 'c':
                        numCycles = atoi(optarg);
                        break;
                case 'S':
                        megsOfMemory=atoi(optarg);
                        break;
                case 'p':
                        pwdString = string(optarg);
                        break;
                case 'q':
                        SHOW_SIM_OUTPUT=false;
                        break;
                case 'n':
                        useClockCycle=false;
                        break;
                case 'o':
                        paramOverrides = parseParamOverrides(string(optarg)); 
                        break;
                case 'v':
                        visFilename = new string(optarg);
                        break;
                case '?':
                        usage();
                        exit(-1);
                        break;
                }
        }

        // get the trace filename
        string temp = traceFileName.substr(traceFileName.find_last_of("/")+1);

        //get the prefix of the trace name
        temp = temp.substr(0,temp.find_first_of("_"));
        if (temp=="mase")
        {
                traceType = mase;
        }
        else if (temp=="k6")
        {
                traceType = k6;
        }
        else if (temp=="misc")
        {
                traceType = misc;
        }
        else
        {
                ERROR("== Unknown Tracefile Type : "<<temp);
                exit(0);
        }


        // no default value for the default model name
        if (deviceIniFilename.length() == 0)
        {
                ERROR("Please provide a device ini file");
                usage();
                exit(-1);
        }


        //ignore the pwd argument if the argument is an absolute path
        if (pwdString.length() > 0 && traceFileName[0] != '/')
        {
                traceFileName = pwdString + "/" +traceFileName;
        }

        DEBUG("== Loading trace file '"<<traceFileName<<"' == ");

        ifstream traceFile;
        string line;


        MultiChannelMemorySystem *memorySystem = new MultiChannelMemorySystem(deviceIniFilename, systemIniFilename, pwdString, traceFileName, megsOfMemory, visFilename, paramOverrides);
        // set the frequency ratio to 1:1
        memorySystem->setCPUClockSpeed(0); 

        // don't need this anymore 
        delete paramOverrides;


#ifdef RETURN_TRANSACTIONS
        TransactionReceiver transactionReceiver; 
        /* create and register our callback functions */
        Callback_t *read_cb = new Callback<TransactionReceiver, void, unsigned, uint64_t, uint64_t>(&transactionReceiver, &TransactionReceiver::read_complete);
        Callback_t *write_cb = new Callback<TransactionReceiver, void, unsigned, uint64_t, uint64_t>(&transactionReceiver, &TransactionReceiver::write_complete);
        memorySystem->RegisterCallbacks(read_cb, write_cb, NULL);
#endif


        uint64_t addr;
        uint64_t clockCycle=0;
        enum TransactionType transType;

        void *data = NULL;
        int lineNumber = 0;
        Transaction *trans=NULL;
        bool pendingTrans = false;

        traceFile.open(traceFileName.c_str());

        if (!traceFile.is_open())
        {
                cout << "== Error - Could not open trace file"<<endl;
                exit(0);
        }

        for (size_t i=0;i<numCycles;i++)
        {
                if (!pendingTrans)
                {
                        if (!traceFile.eof())
                        {
                                getline(traceFile, line);

                                if (line.size() > 0)
                                {
                                        data = parseTraceFileLine(line, addr, transType,clockCycle, traceType,useClockCycle);
                                        trans = new Transaction(transType, addr, data);
                                        alignTransactionAddress(*trans); 

                                        if (i>=clockCycle)
                                        {
                                                if (!(*memorySystem).addTransaction(trans))
                                                {
                                                        pendingTrans = true;
                                                }
                                                else
                                                {
#ifdef RETURN_TRANSACTIONS
                                                        transactionReceiver.add_pending(trans, i); 
#endif
                                                        // the memory system accepted our request so now it takes ownership of it
                                                        trans = NULL; 
                                                }
                                        }
                                        else
                                        {
                                                pendingTrans = true;
                                        }
                                }
                                else
                                {
                                        DEBUG("WARNING: Skipping line "<<lineNumber<< " ('" << line << "') in tracefile");
                                }
                                lineNumber++;
                        }
                        else
                        {
                                //we're out of trace, set pending=false and let the thing spin without adding transactions
                                pendingTrans = false; 
                        }
                }

                else if (pendingTrans && i >= clockCycle)
                {
                        pendingTrans = !(*memorySystem).addTransaction(trans);
                        if (!pendingTrans)
                        {
#ifdef RETURN_TRANSACTIONS
                                transactionReceiver.add_pending(trans, i); 
#endif
                                trans=NULL;
                        }
                }

                (*memorySystem).update();
        }

        traceFile.close();
        memorySystem->printStats(true);
        // make valgrind happy
        if (trans)
        {
                delete trans;
        }
        delete(memorySystem);
}
#endif

permissions: //Transaction.cpp
//
//Class file for transaction object
//        Transaction is considered requests sent from the CPU to
//        the memory controller (read, write, etc.)...

#include "Transaction.h"
#include "PrintMacros.h"

using std::endl;
using std::hex; 
using std::dec; 

namespace DRAMSim {

Transaction::Transaction(TransactionType transType, uint64_t addr, void *dat) :
        transactionType(transType),
        address(addr),
        data(dat)
{}

Transaction::Transaction(const Transaction &t)
        : transactionType(t.transactionType)
          , address(t.address)
          , data(NULL)
          , timeAdded(t.timeAdded)
          , timeReturned(t.timeReturned)
{
        #ifndef NO_STORAGE
        ERROR("Data storage is really outdated and these copies happen in an \n improper way, which will eventually cause problems. Please send an \n email to dramninjas [at] gmail [dot] com if you need data storage");
        abort(); 
        #endif
}

ostream &operator<<(ostream &os, const Transaction &t)
{
        if (t.transactionType == DATA_READ)
        {
                os<<"T [Read] [0x" << hex << t.address << "]" << dec <<endl;
        }
        else if (t.transactionType == DATA_WRITE)
        {
                os<<"T [Write] [0x" << hex << t.address << "] [" << dec << t.data << "]" <<endl;
        }
        else if (t.transactionType == RETURN_DATA)
        {
                os<<"T [Data] [0x" << hex << t.address << "] [" << dec << t.data << "]" <<endl;
        }
        return os; 
}
}

  pull-requests: read # allows SonarQube to decorate PRs with analysis results

jobs: #!/bin/bash 

#script to add or remove the GPL header from all *.cpp and *.h files
# in a directory. Usage:
#
# ./addgpl.sh [add|remove] directory/


DIRECTORY=$2

if [ -d "$DIRECTORY" ]; then 
        FILES=`find $DIRECTORY -iname '*.h' -or -iname '*.cpp'`
else
        echo "Bad directory"
        exit
fi

if [ "$1" == "add" ] ; then 
        for f in $FILES
        do
                echo "adding to $f"
                mv $f $f.tmp
                cat gpl.txt $f.tmp > $f
        done
elif [ "$1" == "remove" ] ; then 
        NUMLINES=`wc -l gpl.txt | cut -f1 -d' '`
        for f in $FILES
        do 
                HEADER=`head --lines=$NUMLINES $f | diff -w gpl.txt -`
                if [ -z "$HEADER" ] ; then 
                        echo "deleting from $f"
                        mv $f $f.tmp
                        tail --lines=+$NUMLINES $f.tmp > $f
                else 
                        echo "header does not match, skipping $f"
                fi 

        done
fi


  Analysis: #!/usr/bin/python 
"""

This script generates a series of commands to do parameter sweeps. One way to
use this script is to generate a big matrix of configurations and then run them
on different binaries to diff the output.  This can be used as a poor man's
regression test when doing code cleanups (i.e. where functionality is not
supposed to change as a result of a commit.

Or, if you just set a single binary and comment out the diff stuff at the
bottom, it is just a convenient way to do parameter sweeps. 

Since this uses the command line overrides (-o flag), it needs a fairly recent
commit of DRAMSim2
( see: https://github.com/dramninjasUMD/DRAMSim2/commit/e46f525bd274a0b3312002dce3efe83c769ea2ce )

Just redirect the output of this command to a file and then run it in bash. 

"""

import itertools 

parameters = {'QUEUING_STRUCTURE': ['per_rank', 'per_rank_per_bank'],
                                        'ROW_BUFFER_POLICY': ['open_page', 'close_page'],
                                        'SCHEDULING_POLICY': ['rank_then_bank_round_robin','bank_then_rank_round_robin']
                                        }

devices = ['DDR3_micron_64M_8B_x4_sg15.ini', 'DDR2_micron_32M_4B_x4_sg3E.ini'];

traces = ['k6_bsc_vector1.trc', 'k6_video_tracking_128kL2_trace.trc',  'k6_aoe_02_short.trc']
binaries = ['DRAMSim.master', 'DRAMSim.cleanup']

dramsim_flags = '-c 2000000 -n -S 8192 -q '

# get the parameter permutations

master_list = []
for k,v in parameters.iteritems():
#        print v
        master_list.append(v)

paramOverrideList=[]
for i in itertools.product(*master_list):
        tmp=[]
        for j,param in enumerate(i):
                tmp.append("%s=%s"%(parameters.keys()[j],param))
        paramOverrideList.append(",".join(tmp))
#print paramOverrideList

print "#!/bin/bash"
print "rm DRAMSim.*.vis"
i=0
for trace in traces: 
        for device in devices:
                for paramOverrides in paramOverrideList:
                        for executable in binaries:
                                output_file = "%s_%d"%(executable, i)
                                print "./%s -s system.ini -d ini/%s -t traces/%s -o %s %s -v %s &"%(executable, device, trace, paramOverrides, dramsim_flags, output_file)
                        i+=1

print "echo -n waiting"
print "wait"
print "echo OK"
print "echo Starting diff phase"
for x in range(i):
        diff_args="%s_%d.vis %s_%d.vis"%(binaries[0],x,binaries[1],x)
        print "echo %s_%d.vis and %s_%d.vis:"%(binaries[0],x,binaries[1],x)
        print "is_different=`diff -q %s`"%(diff_args)
        print "if [ -n \"$is_different\" ] ; then"        
        print "diff -u %s"%(diff_args); 
        print "fi"
    runs-on: ubuntu-latest

    steps:
      - name: Analyze with SonarQube

        # You can pin the exact commit or the version.
        # uses: SonarSource/sonarqube-scan-action@v1.1.0
        uses: SonarSource/sonarqube-scan-action@7295e71c9583053f5bf40e9d4068a0c974603ec8
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}   # Generate a token on SonarQube, add it to the secrets of this repo with the name SONAR_TOKEN (Settings > Secrets > Actions > add new repository secret)
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}   # add the URL of your instance to the secrets of this repo with the name SONAR_HOST_URL (Settings > Secrets > Actions > add new repository secret)
        with:
          # Additional arguments for the sonarcloud scanner
          args:
            # Unique key of your project. You can find it in SonarQube > [my project] > Project Information (top-right menu)
            # mandatory
            -Dsonar.projectKey=
            # Comma-separated paths to directories containing main source files.
            #-Dsonar.sources= # optional, default is project base directory
            # When you need the analysis to take place in a directory other than the one from which it was launched
            #-Dsonar.projectBaseDir= # optional, default is .
            # Comma-separated paths to directories containing test source files.
            #-Dsonar.tests= # optional. For more info about Code Coverage, please refer to https://docs.sonarcloud.io/enriching/test-coverage/overview/
            # Adds more detail to both client and server-side analysis logs, activating DEBUG mode for the scanner, and adding client-side environment variables and system properties to the server-side log of analysis report processing.
            #-Dsonar.verbose= # optional, default is false

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# This workflow helps you trigger a SonarQube analysis of your code and populates
# GitHub Code Scanning alerts with the vulnerabilities found.
# (this feature is available starting from SonarQube 9.7, Developer Edition and above)

# 1. Make sure you add a valid GitHub configuration to your SonarQube (Administration > DevOps platforms > GitHub)

# 2. Import your project on SonarQube
#     * Add your repository as a new project by clicking "Create project" from your homepage.
#
# 3. Select GitHub Actions as your CI and follow the tutorial
#     * a. Generate a new token and add it to your GitHub repository's secrets using the name SONAR_TOKEN
#          (On SonarQube, click on your avatar on top-right > My account > Security or ask your administrator)
#
#     * b. Copy/paste your SonarQube host URL to your GitHub repository's secrets using the name SONAR_HOST_URL
#
#     * c. Copy/paste the project Key into the args parameter below
#          (You'll find this information in SonarQube by following the tutorial or by clicking on Project Information at the top-right of your project's homepage)

# Feel free to take a look at our documentation (https://docs.sonarqube.org/latest/analysis/github-integration/)
# or reach out to our community forum if you need some help (https://community.sonarsource.com/c/sq/10)

name: SonarQube analysis

on: 







//CommandQueue.cpp
//
//Class file for command queue object
//

#include "CommandQueue.h"
#include "MemoryController.h"
#include <assert.h>

using namespace DRAMSim;

CommandQueue::CommandQueue(vector< vector<BankState> > &states, ostream &dramsim_log_) :
                dramsim_log(dramsim_log_),
                bankStates(states),
                nextBank(0),
                nextRank(0),
                nextBankPRE(0),
                nextRankPRE(0),
                refreshRank(0),
                refreshWaiting(false),
                sendAct(true)
{
        //set here to avoid compile errors
        currentClockCycle = 0;

        //use numBankQueus below to create queue structure
        size_t numBankQueues;
        if (queuingStructure==PerRank)
        {
                numBankQueues = 1;
        }
        else if (queuingStructure==PerRankPerBank)
        {
                numBankQueues = NUM_BANKS;
        }
        else
        {
                ERROR("== Error - Unknown queuing structure");
                exit(0);
        }

        //vector of counters used to ensure rows don't stay open too long
        rowAccessCounters = vector< vector<unsigned> >(NUM_RANKS, vector<unsigned>(NUM_BANKS,0));

        //create queue based on the structure we want
        BusPacket1D actualQueue;
        BusPacket2D perBankQueue = BusPacket2D();
        queues = BusPacket3D();
        for (size_t rank=0; rank<NUM_RANKS; rank++)
        {
                //this loop will run only once for per-rank and NUM_BANKS times for per-rank-per-bank
                for (size_t bank=0; bank<numBankQueues; bank++)
                {
                        actualQueue        = BusPacket1D();
                        perBankQueue.push_back(actualQueue);
                }
                queues.push_back(perBankQueue);
        }


        //FOUR-bank activation window
        //        this will count the number of activations within a given window
        //        (decrementing counter)
        //
        //countdown vector will have decrementing counters starting at tFAW
        //  when the 0th element reaches 0, remove it
        tFAWCountdown.reserve(NUM_RANKS);
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                //init the empty vectors here so we don't seg fault later
                tFAWCountdown.push_back(vector<unsigned>());
        }
}
CommandQueue::~CommandQueue()
{
        //ERROR("COMMAND QUEUE destructor");
        size_t bankMax = NUM_RANKS;
        if (queuingStructure == PerRank) {
                bankMax = 1; 
        }
        for (size_t r=0; r< NUM_RANKS; r++)
        {
                for (size_t b=0; b<bankMax; b++) 
                {
                        for (size_t i=0; i<queues[r][b].size(); i++)
                        {
                                delete(queues[r][b][i]);
                        }
                        queues[r][b].clear();
                }
        }
}
//Adds a command to appropriate queue
void CommandQueue::enqueue(BusPacket *newBusPacket)
{
        unsigned rank = newBusPacket->rank;
        unsigned bank = newBusPacket->bank;
        if (queuingStructure==PerRank)
        {
                queues[rank][0].push_back(newBusPacket);
                if (queues[rank][0].size()>CMD_QUEUE_DEPTH)
                {
                        ERROR("== Error - Enqueued more than allowed in command queue");
                        ERROR("                                                Need to call .hasRoomFor(int numberToEnqueue, unsigned rank, unsigned bank) first");
                        exit(0);
                }
        }
        else if (queuingStructure==PerRankPerBank)
        {
                queues[rank][bank].push_back(newBusPacket);
                if (queues[rank][bank].size()>CMD_QUEUE_DEPTH)
                {
                        ERROR("== Error - Enqueued more than allowed in command queue");
                        ERROR("                                                Need to call .hasRoomFor(int numberToEnqueue, unsigned rank, unsigned bank) first");
                        exit(0);
                }
        }
        else
        {
                ERROR("== Error - Unknown queuing structure");
                exit(0);
        }
}

//Removes the next item from the command queue based on the system's
//command scheduling policy
bool CommandQueue::pop(BusPacket **busPacket)
{
        //this can be done here because pop() is called every clock cycle by the parent MemoryController
        //        figures out the sliding window requirement for tFAW
        //
        //deal with tFAW book-keeping
        //        each rank has it's own counter since the restriction is on a device level
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                //decrement all the counters we have going
                for (size_t j=0;j<tFAWCountdown[i].size();j++)
                {
                        tFAWCountdown[i][j]--;
                }

                //the head will always be the smallest counter, so check if it has reached 0
                if (tFAWCountdown[i].size()>0 && tFAWCountdown[i][0]==0)
                {
                        tFAWCountdown[i].erase(tFAWCountdown[i].begin());
                }
        }

        /* Now we need to find a packet to issue. When the code picks a packet, it will set
                 *busPacket = [some eligible packet]
                 
                 First the code looks if any refreshes need to go
                 Then it looks for data packets
                 Otherwise, it starts looking for rows to close (in open page)
        */

        if (rowBufferPolicy==ClosePage)
        {
                bool sendingREF = false;
                //if the memory controller set the flags signaling that we need to issue a refresh
                if (refreshWaiting)
                {
                        bool foundActiveOrTooEarly = false;
                        //look for an open bank
                        for (size_t b=0;b<NUM_BANKS;b++)
                        {
                                vector<BusPacket *> &queue = getCommandQueue(refreshRank,b);
                                //checks to make sure that all banks are idle
                                if (bankStates[refreshRank][b].currentBankState == RowActive)
                                {
                                        foundActiveOrTooEarly = true;
                                        //if the bank is open, make sure there is nothing else
                                        // going there before we close it
                                        for (size_t j=0;j<queue.size();j++)
                                        {
                                                BusPacket *packet = queue[j];
                                                if (packet->row == bankStates[refreshRank][b].openRowAddress &&
                                                                packet->bank == b)
                                                {
                                                        if (packet->busPacketType != ACTIVATE && isIssuable(packet))
                                                        {
                                                                *busPacket = packet;
                                                                queue.erase(queue.begin() + j);
                                                                sendingREF = true;
                                                        }
                                                        break;
                                                }
                                        }

                                        break;
                                }
                                //        NOTE: checks nextActivate time for each bank to make sure tRP is being
                                //                                satisfied.        the next ACT and next REF can be issued at the same
                                //                                point in the future, so just use nextActivate field instead of
                                //                                creating a nextRefresh field
                                else if (bankStates[refreshRank][b].nextActivate > currentClockCycle)
                                {
                                        foundActiveOrTooEarly = true;
                                        break;
                                }
                        }

                        //if there are no open banks and timing has been met, send out the refresh
                        //        reset flags and rank pointer
                        if (!foundActiveOrTooEarly && bankStates[refreshRank][0].currentBankState != PowerDown)
                        {
                                *busPacket = new BusPacket(REFRESH, 0, 0, 0, refreshRank, 0, 0, dramsim_log);
                                refreshRank = -1;
                                refreshWaiting = false;
                                sendingREF = true;
                        }
                } // refreshWaiting

                //if we're not sending a REF, proceed as normal
                if (!sendingREF)
                {
                        bool foundIssuable = false;
                        unsigned startingRank = nextRank;
                        unsigned startingBank = nextBank;
                        do
                        {
                                vector<BusPacket *> &queue = getCommandQueue(nextRank, nextBank);
                                //make sure there is something in this queue first
                                //        also make sure a rank isn't waiting for a refresh
                                //        if a rank is waiting for a refesh, don't issue anything to it until the
                                //                refresh logic above has sent one out (ie, letting banks close)
                                if (!queue.empty() && !((nextRank == refreshRank) && refreshWaiting))
                                {
                                        if (queuingStructure == PerRank)
                                        {

                                                //search from beginning to find first issuable bus packet
                                                for (size_t i=0;i<queue.size();i++)
                                                {
                                                        if (isIssuable(queue[i]))
                                                        {
                                                                //check to make sure we aren't removing a read/write that is paired with an activate
                                                                if (i>0 && queue[i-1]->busPacketType==ACTIVATE &&
                                                                                queue[i-1]->physicalAddress == queue[i]->physicalAddress)
                                                                        continue;

                                                                *busPacket = queue[i];
                                                                queue.erase(queue.begin()+i);
                                                                foundIssuable = true;
                                                                break;
                                                        }
                                                }
                                        }
                                        else
                                        {
                                                if (isIssuable(queue[0]))
                                                {

                                                        //no need to search because if the front can't be sent,
                                                        // then no chance something behind it can go instead
                                                        *busPacket = queue[0];
                                                        queue.erase(queue.begin());
                                                        foundIssuable = true;
                                                }
                                        }

                                }

                                //if we found something, break out of do-while
                                if (foundIssuable) break;

                                //rank round robin
                                if (queuingStructure == PerRank)
                                {
                                        nextRank = (nextRank + 1) % NUM_RANKS;
                                        if (startingRank == nextRank)
                                        {
                                                break;
                                        }
                                }
                                else 
                                {
                                        nextRankAndBank(nextRank, nextBank);
                                        if (startingRank == nextRank && startingBank == nextBank)
                                        {
                                                break;
                                        }
                                }
                        }
                        while (true);

                        //if we couldn't find anything to send, return false
                        if (!foundIssuable) return false;
                }
        }
        else if (rowBufferPolicy==OpenPage)
        {
                bool sendingREForPRE = false;
                if (refreshWaiting)
                {
                        bool sendREF = true;
                        //make sure all banks idle and timing met for a REF
                        for (size_t b=0;b<NUM_BANKS;b++)
                        {
                                //if a bank is active we can't send a REF yet
                                if (bankStates[refreshRank][b].currentBankState == RowActive)
                                {
                                        sendREF = false;
                                        bool closeRow = true;
                                        //search for commands going to an open row
                                        vector <BusPacket *> &refreshQueue = getCommandQueue(refreshRank,b);

                                        for (size_t j=0;j<refreshQueue.size();j++)
                                        {
                                                BusPacket *packet = refreshQueue[j];
                                                //if a command in the queue is going to the same row . . .
                                                if (bankStates[refreshRank][b].openRowAddress == packet->row &&
                                                                b == packet->bank)
                                                {
                                                        // . . . and is not an activate . . .
                                                        if (packet->busPacketType != ACTIVATE)
                                                        {
                                                                closeRow = false;
                                                                // . . . and can be issued . . .
                                                                if (isIssuable(packet))
                                                                {
                                                                        //send it out
                                                                        *busPacket = packet;
                                                                        refreshQueue.erase(refreshQueue.begin()+j);
                                                                        sendingREForPRE = true;
                                                                }
                                                                break;
                                                        }
                                                        else //command is an activate
                                                        {
                                                                //if we've encountered another act, no other command will be of interest
                                                                break;
                                                        }
                                                }
                                        }

                                        //if the bank is open and we are allowed to close it, then send a PRE
                                        if (closeRow && currentClockCycle >= bankStates[refreshRank][b].nextPrecharge)
                                        {
                                                rowAccessCounters[refreshRank][b]=0;
                                                *busPacket = new BusPacket(PRECHARGE, 0, 0, 0, refreshRank, b, 0, dramsim_log);
                                                sendingREForPRE = true;
                                        }
                                        break;
                                }
                                //        NOTE: the next ACT and next REF can be issued at the same
                                //                                point in the future, so just use nextActivate field instead of
                                //                                creating a nextRefresh field
                                else if (bankStates[refreshRank][b].nextActivate > currentClockCycle) //and this bank doesn't have an open row
                                {
                                        sendREF = false;
                                        break;
                                }
                        }

                        //if there are no open banks and timing has been met, send out the refresh
                        //        reset flags and rank pointer
                        if (sendREF && bankStates[refreshRank][0].currentBankState != PowerDown)
                        {
                                *busPacket = new BusPacket(REFRESH, 0, 0, 0, refreshRank, 0, 0, dramsim_log);
                                refreshRank = -1;
                                refreshWaiting = false;
                                sendingREForPRE = true;
                        }
                }

                if (!sendingREForPRE)
                {
                        unsigned startingRank = nextRank;
                        unsigned startingBank = nextBank;
                        bool foundIssuable = false;
                        do // round robin over queues
                        {
                                vector<BusPacket *> &queue = getCommandQueue(nextRank,nextBank);
                                //make sure there is something there first
                                if (!queue.empty() && !((nextRank == refreshRank) && refreshWaiting))
                                {
                                        //search from the beginning to find first issuable bus packet
                                        for (size_t i=0;i<queue.size();i++)
                                        {
                                                BusPacket *packet = queue[i];
                                                if (isIssuable(packet))
                                                {
                                                        //check for dependencies
                                                        bool dependencyFound = false;
                                                        for (size_t j=0;j<i;j++)
                                                        {
                                                                BusPacket *prevPacket = queue[j];
                                                                if (prevPacket->busPacketType != ACTIVATE &&
                                                                                prevPacket->bank == packet->bank &&
                                                                                prevPacket->row == packet->row)
                                                                {
                                                                        dependencyFound = true;
                                                                        break;
                                                                }
                                                        }
                                                        if (dependencyFound) continue;

                                                        *busPacket = packet;

                                                        //if the bus packet before is an activate, that is the act that was
                                                        //        paired with the column access we are removing, so we have to remove
                                                        //        that activate as well (check i>0 because if i==0 then theres nothing before it)
                                                        if (i>0 && queue[i-1]->busPacketType == ACTIVATE)
                                                        {
                                                                rowAccessCounters[(*busPacket)->rank][(*busPacket)->bank]++;
                                                                // i is being returned, but i-1 is being thrown away, so must delete it here 
                                                                delete (queue[i-1]);

                                                                // remove both i-1 (the activate) and i (we've saved the pointer in *busPacket)
                                                                queue.erase(queue.begin()+i-1,queue.begin()+i+1);
                                                        }
                                                        else // there's no activate before this packet
                                                        {
                                                                //or just remove the one bus packet
                                                                queue.erase(queue.begin()+i);
                                                        }

                                                        foundIssuable = true;
                                                        break;
                                                }
                                        }
                                }

                                //if we found something, break out of do-while
                                if (foundIssuable) break;

                                //rank round robin
                                if (queuingStructure == PerRank)
                                {
                                        nextRank = (nextRank + 1) % NUM_RANKS;
                                        if (startingRank == nextRank)
                                        {
                                                break;
                                        }
                                }
                                else 
                                {
                                        nextRankAndBank(nextRank, nextBank); 
                                        if (startingRank == nextRank && startingBank == nextBank)
                                        {
                                                break;
                                        }
                                }
                        }
                        while (true);

                        //if nothing was issuable, see if we can issue a PRE to an open bank
                        //        that has no other commands waiting
                        if (!foundIssuable)
                        {
                                //search for banks to close
                                bool sendingPRE = false;
                                unsigned startingRank = nextRankPRE;
                                unsigned startingBank = nextBankPRE;

                                do // round robin over all ranks and banks
                                {
                                        vector <BusPacket *> &queue = getCommandQueue(nextRankPRE, nextBankPRE);
                                        bool found = false;
                                        //check if bank is open
                                        if (bankStates[nextRankPRE][nextBankPRE].currentBankState == RowActive)
                                        {
                                                for (size_t i=0;i<queue.size();i++)
                                                {
                                                        //if there is something going to that bank and row, then we don't want to send a PRE
                                                        if (queue[i]->bank == nextBankPRE &&
                                                                        queue[i]->row == bankStates[nextRankPRE][nextBankPRE].openRowAddress)
                                                        {
                                                                found = true;
                                                                break;
                                                        }
                                                }

                                                //if nothing found going to that bank and row or too many accesses have happend, close it
                                                if (!found || rowAccessCounters[nextRankPRE][nextBankPRE]==TOTAL_ROW_ACCESSES)
                                                {
                                                        if (currentClockCycle >= bankStates[nextRankPRE][nextBankPRE].nextPrecharge)
                                                        {
                                                                sendingPRE = true;
                                                                rowAccessCounters[nextRankPRE][nextBankPRE] = 0;
                                                                *busPacket = new BusPacket(PRECHARGE, 0, 0, 0, nextRankPRE, nextBankPRE, 0, dramsim_log);
                                                                break;
                                                        }
                                                }
                                        }
                                        nextRankAndBank(nextRankPRE, nextBankPRE);
                                }
                                while (!(startingRank == nextRankPRE && startingBank == nextBankPRE));

                                //if no PREs could be sent, just return false
                                if (!sendingPRE) return false;
                        }
                }
        }

        //sendAct is flag used for posted-cas
        //  posted-cas is enabled when AL>0
        //  when sendAct is true, when don't want to increment our indexes
        //  so we send the column access that is paid with this act
        if (AL>0 && sendAct)
        {
                sendAct = false;
        }
        else
        {
                sendAct = true;
                nextRankAndBank(nextRank, nextBank);
        }

        //if its an activate, add a tfaw counter
        if ((*busPacket)->busPacketType==ACTIVATE)
        {
                tFAWCountdown[(*busPacket)->rank].push_back(tFAW);
        }

        return true;
}

//check if a rank/bank queue has room for a certain number of bus packets
bool CommandQueue::hasRoomFor(unsigned numberToEnqueue, unsigned rank, unsigned bank)
{
        vector<BusPacket *> &queue = getCommandQueue(rank, bank); 
        return (CMD_QUEUE_DEPTH - queue.size() >= numberToEnqueue);
}

//prints the contents of the command queue
void CommandQueue::print()
{
        if (queuingStructure==PerRank)
        {
                PRINT(endl << "== Printing Per Rank Queue" );
                for (size_t i=0;i<NUM_RANKS;i++)
                {
                        PRINT(" = Rank " << i << "  size : " << queues[i][0].size() );
                        for (size_t j=0;j<queues[i][0].size();j++)
                        {
                                PRINTN("    "<< j << "]");
                                queues[i][0][j]->print();
                        }
                }
        }
        else if (queuingStructure==PerRankPerBank)
        {
                PRINT("\n== Printing Per Rank, Per Bank Queue" );

                for (size_t i=0;i<NUM_RANKS;i++)
                {
                        PRINT(" = Rank " << i );
                        for (size_t j=0;j<NUM_BANKS;j++)
                        {
                                PRINT("    Bank "<< j << "   size : " << queues[i][j].size() );

                                for (size_t k=0;k<queues[i][j].size();k++)
                                {
                                        PRINTN("       " << k << "]");
                                        queues[i][j][k]->print();
                                }
                        }
                }
        }
}

/** 
 * return a reference to the queue for a given rank, bank. Since we
 * don't always have a per bank queuing structure, sometimes the bank
 * argument is ignored (and the 0th index is returned 
 */
vector<BusPacket *> &CommandQueue::getCommandQueue(unsigned rank, unsigned bank)
{
        if (queuingStructure == PerRankPerBank)
        {
                return queues[rank][bank];
        }
        else if (queuingStructure == PerRank)
        {
                return queues[rank][0];
        }
        else
        {
                ERROR("Unknown queue structure");
                abort(); 
        }

}

//checks if busPacket is allowed to be issued
bool CommandQueue::isIssuable(BusPacket *busPacket)
{
        switch (busPacket->busPacketType)
        {
        case REFRESH:

                break;
        case ACTIVATE:
                if ((bankStates[busPacket->rank][busPacket->bank].currentBankState == Idle ||
                        bankStates[busPacket->rank][busPacket->bank].currentBankState == Refreshing) &&
                        currentClockCycle >= bankStates[busPacket->rank][busPacket->bank].nextActivate &&
                        tFAWCountdown[busPacket->rank].size() < 4)
                {
                        return true;
                }
                else
                {
                        return false;
                }
                break;
        case WRITE:
        case WRITE_P:
                if (bankStates[busPacket->rank][busPacket->bank].currentBankState == RowActive &&
                        currentClockCycle >= bankStates[busPacket->rank][busPacket->bank].nextWrite &&
                        busPacket->row == bankStates[busPacket->rank][busPacket->bank].openRowAddress &&
                        rowAccessCounters[busPacket->rank][busPacket->bank] < TOTAL_ROW_ACCESSES)
                {
                        return true;
                }
                else
                {
                        return false;
                }
                break;
        case READ_P:
        case READ:
                if (bankStates[busPacket->rank][busPacket->bank].currentBankState == RowActive &&
                        currentClockCycle >= bankStates[busPacket->rank][busPacket->bank].nextRead &&
                        busPacket->row == bankStates[busPacket->rank][busPacket->bank].openRowAddress &&
                        rowAccessCounters[busPacket->rank][busPacket->bank] < TOTAL_ROW_ACCESSES)
                {
                        return true;
                }
                else
                {
                        return false;
                }
                break;
        case PRECHARGE:
                if (bankStates[busPacket->rank][busPacket->bank].currentBankState == RowActive &&
                        currentClockCycle >= bankStates[busPacket->rank][busPacket->bank].nextPrecharge)
                {
                        return true;
                }
                else
                {
                        return false;
                }
                break;
        default:
                ERROR("== Error - Trying to issue a crazy bus packet type : ");
                busPacket->print();
                exit(0);
        }
        return false;
}

//figures out if a rank's queue is empty
bool CommandQueue::isEmpty(unsigned rank)
{
        if (queuingStructure == PerRank)
        {
                return queues[rank][0].empty();
        }
        else if (queuingStructure == PerRankPerBank)
        {
                for (size_t i=0;i<NUM_BANKS;i++)
                {
                        if (!queues[rank][i].empty()) return false;
                }
                return true;
        }
        else
        {
                DEBUG("Invalid Queueing Stucture");
                abort();
        }
}

//tells the command queue that a particular rank is in need of a refresh
void CommandQueue::needRefresh(unsigned rank)
{
        refreshWaiting = true;
        refreshRank = rank;
}

void CommandQueue::nextRankAndBank(unsigned &rank, unsigned &bank)
{
        if (schedulingPolicy == RankThenBankRoundRobin)
        {
                rank++;
                if (rank == NUM_RANKS)
                {
                        rank = 0;
                        bank++;
                        if (bank == NUM_BANKS)
                        {
                                bank = 0;
                        }
                }
        }
        //bank-then-rank round robin
        else if (schedulingPolicy == BankThenRankRoundRobin)
        {
                bank++;
                if (bank == NUM_BANKS)
                {
                        bank = 0;
                        rank++;
                        if (rank == NUM_RANKS)
                        {
                                rank = 0;
                        }
                }
        }
        else
        {
                ERROR("== Error - Unknown scheduling policy");
                exit(0);
        }

}

void CommandQueue::update()
{
        //do nothing since pop() is effectively update(),
        //needed for SimulatorObject
        //TODO: make CommandQueue not a SimulatorObject
}
  push: 





#ifndef CMDQUEUE_H
#define CMDQUEUE_H

//CommandQueue.h
//
//Header
//

#include "BusPacket.h"
#include "BankState.h"
#include "Transaction.h"
#include "SystemConfiguration.h"
#include "SimulatorObject.h"

using namespace std;

namespace DRAMSim
{
class CommandQueue : public SimulatorObject
{
        CommandQueue();
        ostream &dramsim_log;
public:
        //typedefs
        typedef vector<BusPacket *> BusPacket1D;
        typedef vector<BusPacket1D> BusPacket2D;
        typedef vector<BusPacket2D> BusPacket3D;

        //functions
        CommandQueue(vector< vector<BankState> > &states, ostream &dramsim_log);
        virtual ~CommandQueue(); 

        void enqueue(BusPacket *newBusPacket);
        bool pop(BusPacket **busPacket);
        bool hasRoomFor(unsigned numberToEnqueue, unsigned rank, unsigned bank);
        bool isIssuable(BusPacket *busPacket);
        bool isEmpty(unsigned rank);
        void needRefresh(unsigned rank);
        void print();
        void update(); //SimulatorObject requirement
        vector<BusPacket *> &getCommandQueue(unsigned rank, unsigned bank);

        //fields

        BusPacket3D queues; // 3D array of BusPacket pointers
        vector< vector<BankState> > &bankStates;
private:
        void nextRankAndBank(unsigned &rank, unsigned &bank);
        //fields
        unsigned nextBank;
        unsigned nextRank;

        unsigned nextBankPRE;
        unsigned nextRankPRE;

        unsigned refreshRank;
        bool refreshWaiting;

        vector< vector<unsigned> > tFAWCountdown;
        vector< vector<unsigned> > rowAccessCounters;

        bool sendAct;
};
}

#endif

    branches: [ "main" ]
  pull_request: 

#ifndef DRAMSIM_H
#define DRAMSIM_H
/*
 * This is a public header for DRAMSim including this along with libdramsim.so should
 * provide all necessary functionality to talk to an external simulator
 */
#include "Callback.h"
#include <string>
using std::string;

namespace DRAMSim 
{

        class MultiChannelMemorySystem {
                public: 
                        bool addTransaction(bool isWrite, uint64_t addr);
                        void setCPUClockSpeed(uint64_t cpuClkFreqHz);
                        void update();
                        void printStats(bool finalStats);
                        bool willAcceptTransaction(); 
                        bool willAcceptTransaction(uint64_t addr); 
                        std::ostream &getLogFile();

                        void RegisterCallbacks( 
                                TransactionCompleteCB *readDone,
                                TransactionCompleteCB *writeDone,
                                void (*reportPower)(double bgpower, double burstpower, double refreshpower, double actprepower));
                        int getIniBool(const std::string &field, bool *val);
                        int getIniUint(const std::string &field, unsigned int *val);
                        int getIniUint64(const std::string &field, uint64_t *val);
                        int getIniFloat(const std::string &field, float *val);
        };
        MultiChannelMemorySystem *getMemorySystemInstance(const string &dev, const string &sys, const string &pwd, const string &trc, unsigned megsOfMemory, std::string *visfilename=NULL);
}

#endif
    branches: [ "main" ]
  workflow_dispatch: 







#include "IniReader.h"

using namespace std;

// these are the values that are extern'd in SystemConfig.h so that they
// have global scope even though they are set by IniReader

uint64_t TOTAL_STORAGE;
unsigned NUM_BANKS;
unsigned NUM_BANKS_LOG;
unsigned NUM_CHANS;
unsigned NUM_CHANS_LOG;
unsigned NUM_ROWS;
unsigned NUM_ROWS_LOG;
unsigned NUM_COLS;
unsigned NUM_COLS_LOG;
unsigned DEVICE_WIDTH;
unsigned BYTE_OFFSET_WIDTH;
unsigned TRANSACTION_SIZE;
unsigned THROW_AWAY_BITS;
unsigned COL_LOW_BIT_WIDTH;

unsigned REFRESH_PERIOD;
float tCK;
float Vdd;
unsigned CL;
unsigned AL;
unsigned BL;
unsigned tRAS;
unsigned tRCD;
unsigned tRRD;
unsigned tRC;
unsigned tRP;
unsigned tCCD;
unsigned tRTP;
unsigned tWTR;
unsigned tWR;
unsigned tRTRS;
unsigned tRFC;
unsigned tFAW;
unsigned tCKE;
unsigned tXP;
unsigned tCMD;

unsigned IDD0;
unsigned IDD1;
unsigned IDD2P;
unsigned IDD2Q;
unsigned IDD2N;
unsigned IDD3Pf;
unsigned IDD3Ps;
unsigned IDD3N;
unsigned IDD4W;
unsigned IDD4R;
unsigned IDD5;
unsigned IDD6;
unsigned IDD6L;
unsigned IDD7;


//in bytes
unsigned JEDEC_DATA_BUS_BITS;

//Memory Controller related parameters
unsigned TRANS_QUEUE_DEPTH;
unsigned CMD_QUEUE_DEPTH;

//cycles within an epoch
unsigned EPOCH_LENGTH;

//row accesses allowed before closing (open page)
unsigned TOTAL_ROW_ACCESSES;

// strings and their associated enums
string ROW_BUFFER_POLICY;
string SCHEDULING_POLICY;
string ADDRESS_MAPPING_SCHEME;
string QUEUING_STRUCTURE;

bool DEBUG_TRANS_Q;
bool DEBUG_CMD_Q;
bool DEBUG_ADDR_MAP;
bool DEBUG_BANKSTATE;
bool DEBUG_BUS;
bool DEBUG_BANKS;
bool DEBUG_POWER;
bool USE_LOW_POWER;
bool VIS_FILE_OUTPUT;

bool VERIFICATION_OUTPUT;

bool DEBUG_INI_READER=false;

namespace DRAMSim
{
RowBufferPolicy rowBufferPolicy;
SchedulingPolicy schedulingPolicy;
AddressMappingScheme addressMappingScheme;
QueuingStructure queuingStructure;


//Map the string names to the variables they set
static ConfigMap configMap[] =
{
        //DEFINE_UINT_PARAM -- see IniReader.h
        DEFINE_UINT_PARAM(NUM_BANKS,DEV_PARAM),
        DEFINE_UINT_PARAM(NUM_ROWS,DEV_PARAM),
        DEFINE_UINT_PARAM(NUM_COLS,DEV_PARAM),
        DEFINE_UINT_PARAM(DEVICE_WIDTH,DEV_PARAM),
        DEFINE_UINT_PARAM(REFRESH_PERIOD,DEV_PARAM),
        DEFINE_FLOAT_PARAM(tCK,DEV_PARAM),
        DEFINE_UINT_PARAM(CL,DEV_PARAM),
        DEFINE_UINT_PARAM(AL,DEV_PARAM),
        DEFINE_UINT_PARAM(BL,DEV_PARAM),
        DEFINE_UINT_PARAM(tRAS,DEV_PARAM),
        DEFINE_UINT_PARAM(tRCD,DEV_PARAM),
        DEFINE_UINT_PARAM(tRRD,DEV_PARAM),
        DEFINE_UINT_PARAM(tRC,DEV_PARAM),
        DEFINE_UINT_PARAM(tRP,DEV_PARAM),
        DEFINE_UINT_PARAM(tCCD,DEV_PARAM),
        DEFINE_UINT_PARAM(tRTP,DEV_PARAM),
        DEFINE_UINT_PARAM(tWTR,DEV_PARAM),
        DEFINE_UINT_PARAM(tWR,DEV_PARAM),
        DEFINE_UINT_PARAM(tRTRS,DEV_PARAM),
        DEFINE_UINT_PARAM(tRFC,DEV_PARAM),
        DEFINE_UINT_PARAM(tFAW,DEV_PARAM),
        DEFINE_UINT_PARAM(tCKE,DEV_PARAM),
        DEFINE_UINT_PARAM(tXP,DEV_PARAM),
        DEFINE_UINT_PARAM(tCMD,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD0,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD1,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD2P,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD2Q,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD2N,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD3Pf,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD3Ps,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD3N,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD4W,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD4R,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD5,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD6,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD6L,DEV_PARAM),
        DEFINE_UINT_PARAM(IDD7,DEV_PARAM),
        DEFINE_FLOAT_PARAM(Vdd,DEV_PARAM),

        DEFINE_UINT_PARAM(NUM_CHANS,SYS_PARAM),
        DEFINE_UINT_PARAM(JEDEC_DATA_BUS_BITS,SYS_PARAM),

        //Memory Controller related parameters
        DEFINE_UINT_PARAM(TRANS_QUEUE_DEPTH,SYS_PARAM),
        DEFINE_UINT_PARAM(CMD_QUEUE_DEPTH,SYS_PARAM),

        DEFINE_UINT_PARAM(EPOCH_LENGTH,SYS_PARAM),
        //Power
        DEFINE_BOOL_PARAM(USE_LOW_POWER,SYS_PARAM),

        DEFINE_UINT_PARAM(TOTAL_ROW_ACCESSES,SYS_PARAM),
        DEFINE_STRING_PARAM(ROW_BUFFER_POLICY,SYS_PARAM),
        DEFINE_STRING_PARAM(SCHEDULING_POLICY,SYS_PARAM),
        DEFINE_STRING_PARAM(ADDRESS_MAPPING_SCHEME,SYS_PARAM),
        DEFINE_STRING_PARAM(QUEUING_STRUCTURE,SYS_PARAM),
        // debug flags
        DEFINE_BOOL_PARAM(DEBUG_TRANS_Q,SYS_PARAM),
        DEFINE_BOOL_PARAM(DEBUG_CMD_Q,SYS_PARAM),
        DEFINE_BOOL_PARAM(DEBUG_ADDR_MAP,SYS_PARAM),
        DEFINE_BOOL_PARAM(DEBUG_BANKSTATE,SYS_PARAM),
        DEFINE_BOOL_PARAM(DEBUG_BUS,SYS_PARAM),
        DEFINE_BOOL_PARAM(DEBUG_BANKS,SYS_PARAM),
        DEFINE_BOOL_PARAM(DEBUG_POWER,SYS_PARAM),
        DEFINE_BOOL_PARAM(VIS_FILE_OUTPUT,SYS_PARAM),
        DEFINE_BOOL_PARAM(VERIFICATION_OUTPUT,SYS_PARAM),
        {"", NULL, UINT, SYS_PARAM, false} // tracer value to signify end of list; if you delete it, epic fail will result
};

void IniReader::WriteParams(std::ofstream &visDataOut, paramType type)
{
        for (size_t i=0; configMap[i].variablePtr != NULL; i++)
        {
                if (configMap[i].parameterType == type)
                {
                        visDataOut<<configMap[i].iniKey<<"=";
                        switch (configMap[i].variableType)
                        {
                                //parse and set each type of variable
                        case UINT:
                                visDataOut << *((unsigned *)configMap[i].variablePtr);
                                break;
                        case UINT64:
                                visDataOut << *((uint64_t *)configMap[i].variablePtr);
                                break;
                        case FLOAT:
                                visDataOut << *((float *)configMap[i].variablePtr);
                                break;
                        case STRING:
                                visDataOut << *((string *)configMap[i].variablePtr);
                                break;
                        case BOOL:
                                if (*((bool *)configMap[i].variablePtr))
                                {
                                        visDataOut <<"true";
                                }
                                else
                                {
                                        visDataOut <<"false";
                                }
                                break;
                        }
                        visDataOut << endl;
                }
        }
        if (type == SYS_PARAM)
        {
                visDataOut<<"NUM_RANKS="<<NUM_RANKS <<"\n";
        }
}
void IniReader::WriteValuesOut(std::ofstream &visDataOut)
{
        visDataOut<<"!!SYSTEM_INI"<<endl;

        WriteParams(visDataOut, SYS_PARAM); 
        visDataOut<<"!!DEVICE_INI"<<endl;

        WriteParams(visDataOut, DEV_PARAM); 
        visDataOut<<"!!EPOCH_DATA"<<endl;

}

void IniReader::SetKey(string key, string valueString, bool isSystemParam, size_t lineNumber)
{
        size_t i;
        unsigned intValue;
        uint64_t int64Value;
        float floatValue;

        for (i=0; configMap[i].variablePtr != NULL; i++)
        {
                istringstream iss(valueString);
                // match up the string in the config map with the key we parsed
                if (key.compare(configMap[i].iniKey) == 0)
                {
                        switch (configMap[i].variableType)
                        {
                                //parse and set each type of variable
                        case UINT:
                                if ((iss >> dec >> intValue).fail())
                                {
                                        ERROR("could not parse line "<<lineNumber<<" (non-numeric value '"<<valueString<<"')?");
                                }
                                *((unsigned *)configMap[i].variablePtr) = intValue;
                                if (DEBUG_INI_READER)
                                {
                                        DEBUG("\t - SETTING "<<configMap[i].iniKey<<"="<<intValue);
                                }
                                break;
                        case UINT64:
                                if ((iss >> dec >> int64Value).fail())
                                {
                                        ERROR("could not parse line "<<lineNumber<<" (non-numeric value '"<<valueString<<"')?");
                                }
                                *((uint64_t *)configMap[i].variablePtr) = int64Value;
                                if (DEBUG_INI_READER)
                                {
                                        DEBUG("\t - SETTING "<<configMap[i].iniKey<<"="<<int64Value);
                                }
                                break;
                        case FLOAT:
                                if ((iss >> dec >> floatValue).fail())
                                {
                                        ERROR("could not parse line "<<lineNumber<<" (non-numeric value '"<<valueString<<"')?");
                                }
                                *((float *)configMap[i].variablePtr) = floatValue;
                                if (DEBUG_INI_READER)
                                {
                                        DEBUG("\t - SETTING "<<configMap[i].iniKey<<"="<<floatValue);
                                }
                                break;
                        case STRING:
                                *((string *)configMap[i].variablePtr) = string(valueString);
                                if (DEBUG_INI_READER)
                                {
                                        DEBUG("\t - SETTING "<<configMap[i].iniKey<<"="<<valueString);
                                }

                                break;
                        case BOOL:
                                if (valueString == "true" || valueString == "1")
                                {
                                        *((bool *)configMap[i].variablePtr) = true;
                                }
                                else
                                {
                                        *((bool *)configMap[i].variablePtr) = false;
                                }
                        }
                        // lineNumber == 0 implies that this is an override parameter from the command line, so don't bother doing these checks
                        if (lineNumber > 0)
                        {
                                if (isSystemParam && configMap[i].parameterType == DEV_PARAM)
                                {
                                        DEBUG("WARNING: Found device parameter "<<configMap[i].iniKey<<" in system config file");
                                }
                                else if (!isSystemParam && configMap[i].parameterType == SYS_PARAM)
                                {
                                        DEBUG("WARNING: Found system parameter "<<configMap[i].iniKey<<" in device config file");
                                }
                        }
                        // use the pointer stored in the config map to set the value of the variable
                        // to make sure all parameters are in the ini file
                        configMap[i].wasSet = true;
                        break;
                }
        }

        if (configMap[i].variablePtr == NULL)
        {
                DEBUG("WARNING: UNKNOWN KEY '"<<key<<"' IN INI FILE");
        }
}

void IniReader::ReadIniFile(string filename, bool isSystemFile)
{
        ifstream iniFile;
        string line;
        string key,valueString;

        size_t commentIndex, equalsIndex;
        size_t lineNumber=0;

        iniFile.open(filename.c_str());
        if (iniFile.is_open())
        {
                while (!iniFile.eof())
                {
                        lineNumber++;
                        getline(iniFile, line);
                        //this can happen if the filename is actually a directory
                        if (iniFile.bad())
                        {
                                ERROR("Cannot read ini file '"<<filename<<"'");
                                exit(-1);
                        }
                        // skip zero-length lines
                        if (line.size() == 0)
                        {
//                                        DEBUG("Skipping blank line "<<lineNumber);
                                continue;
                        }
                        //search for a comment char
                        if ((commentIndex = line.find_first_of(";")) != string::npos)
                        {
                                //if the comment char is the first char, ignore the whole line
                                if (commentIndex == 0)
                                {
//                                                DEBUG("Skipping comment line "<<lineNumber);
                                        continue;
                                }
//                                        DEBUG("Truncating line at comment"<<line[commentIndex-1]);
                                //truncate the line at first comment before going on
                                line = line.substr(0,commentIndex);
                        }
                        // trim off the end spaces that might have been between the value and comment char
                        size_t whiteSpaceEndIndex;
                        if ((whiteSpaceEndIndex = line.find_last_not_of(" \t")) != string::npos)
                        {
                                line = line.substr(0,whiteSpaceEndIndex+1);
                        }

                        // at this point line should be a valid, commentless string

                        // a line has to have an equals sign
                        if ((equalsIndex = line.find_first_of("=")) == string::npos)
                        {
                                ERROR("Malformed Line "<<lineNumber<<" (missing equals)");
                                abort();
                        }
                        size_t strlen = line.size();
                        // all characters before the equals are the key
                        key = line.substr(0, equalsIndex);
                        // all characters after the equals are the value
                        valueString = line.substr(equalsIndex+1,strlen-equalsIndex);

                        IniReader::SetKey(key, valueString, isSystemFile, lineNumber);
                        // got to the end of the config map without finding the key
                }
        }
        else
        {
                ERROR ("Unable to load ini file "<<filename);
                abort();
        }
        /* precompute frequently used values */
        NUM_BANKS_LOG                = dramsim_log2(NUM_BANKS);
        NUM_CHANS_LOG                = dramsim_log2(NUM_CHANS);
        NUM_ROWS_LOG                = dramsim_log2(NUM_ROWS);
        NUM_COLS_LOG                = dramsim_log2(NUM_COLS);
        BYTE_OFFSET_WIDTH        = dramsim_log2(JEDEC_DATA_BUS_BITS / 8);
        TRANSACTION_SIZE        = JEDEC_DATA_BUS_BITS / 8 * BL;
        THROW_AWAY_BITS                = dramsim_log2(TRANSACTION_SIZE);
        COL_LOW_BIT_WIDTH        = THROW_AWAY_BITS - BYTE_OFFSET_WIDTH;
}

void IniReader::OverrideKeys(const OverrideMap *map)
{
        if (!map)
                return; 

        OverrideIterator it = map->begin();
        DEBUG("Key overrides from command line:"); 
        for (it=map->begin(); it != map->end(); it++)
        {
                string key = it->first; 
                string value = it->second; 
                DEBUG("\t'"<< key <<"'->'"<< value<< "'"); 
                IniReader::SetKey(key,value);
        }
}

bool IniReader::CheckIfAllSet()
{
        // check to make sure all parameters that we exepected were set
        for (size_t i=0; configMap[i].variablePtr != NULL; i++)
        {
                if (!configMap[i].wasSet)
                {
                        DEBUG("WARNING: KEY "<<configMap[i].iniKey<<" NOT FOUND IN INI FILE.");
                        switch (configMap[i].variableType)
                        {
                                //the string and bool values can be defaulted, but generally we need all the numeric values to be set to continue
                        case UINT:
                        case UINT64:
                        case FLOAT:
                                ERROR("Cannot continue without key '"<<configMap[i].iniKey<<"' set.");
                                return false;
                                break;
                        case BOOL:
                                *((bool *)configMap[i].variablePtr) = false;
                                DEBUG("\tSetting Default: "<<configMap[i].iniKey<<"=false");
                                break;
                        case STRING:
                                break;
                        }
                }
        }
        return true;
}

/*
 * There is probably a way of doing this with templates, but since
 * we have the types defined as an enum, doing this with macros is trivial.
 *
 * Return value: 0 on success, -1 on error
 */
#define DEF_GETTER(_funcname, _type, _typename)                                \
        int _funcname(const std::string& field, _type *val)                \
        {                                                                \
                int i;                                                        \
                                                                        \
                for (i=0; configMap[i].variablePtr != NULL; i++)        \
                {                                                        \
                        if (field.compare(configMap[i].iniKey))                \
                                continue;                                \
                        if (configMap[i].variableType != _typename)        \
                                return -1;                                \
                        *val = *(_type *)configMap[i].variablePtr;        \
                        return 0;                                        \
                }                                                        \
                return -1;                                                \
        }

/* TODO: getter for strings is missing. Probably not that useful though */
DEF_GETTER(IniReader::getBool, bool, BOOL)
DEF_GETTER(IniReader::getUint, unsigned int, UINT)
DEF_GETTER(IniReader::getUint64, uint64_t, UINT64)
DEF_GETTER(IniReader::getFloat, float, FLOAT)

void IniReader::InitEnumsFromStrings()
{
        if (ADDRESS_MAPPING_SCHEME == "scheme1")
        {
                addressMappingScheme = Scheme1;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("ADDR SCHEME: 1");
                }
        }
        else if (ADDRESS_MAPPING_SCHEME == "scheme2")
        {
                addressMappingScheme = Scheme2;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("ADDR SCHEME: 2");
                }
        }
        else if (ADDRESS_MAPPING_SCHEME == "scheme3")
        {
                addressMappingScheme = Scheme3;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("ADDR SCHEME: 3");
                }
        }
        else if (ADDRESS_MAPPING_SCHEME == "scheme4")
        {
                addressMappingScheme = Scheme4;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("ADDR SCHEME: 4");
                }
        }
        else if (ADDRESS_MAPPING_SCHEME == "scheme5")
        {
                addressMappingScheme = Scheme5;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("ADDR SCHEME: 5");
                }
        }
        else if (ADDRESS_MAPPING_SCHEME == "scheme6")
        {
                addressMappingScheme = Scheme6;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("ADDR SCHEME: 6");
                }
        }
        else if (ADDRESS_MAPPING_SCHEME == "scheme7")
        {
                addressMappingScheme = Scheme7;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("ADDR SCHEME: 7");
                }
        }
        else
        {
                cout << "WARNING: unknown address mapping scheme '"<<ADDRESS_MAPPING_SCHEME<<"'; valid values are 'scheme1'...'scheme7'. Defaulting to scheme1"<<endl;
                addressMappingScheme = Scheme1;
        }

        if (ROW_BUFFER_POLICY == "open_page")
        {
                rowBufferPolicy = OpenPage;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("ROW BUFFER: open page");
                }
        }
        else if (ROW_BUFFER_POLICY == "close_page")
        {
                rowBufferPolicy = ClosePage;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("ROW BUFFER: close page");
                }
        }
        else
        {
                cout << "WARNING: unknown row buffer policy '"<<ROW_BUFFER_POLICY<<"'; valid values are 'open_page' or 'close_page', Defaulting to Close Page."<<endl;
                rowBufferPolicy = ClosePage;
        }

        if (QUEUING_STRUCTURE == "per_rank_per_bank")
        {
                queuingStructure = PerRankPerBank;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("QUEUING STRUCT: per rank per bank");
                }
        }
        else if (QUEUING_STRUCTURE == "per_rank")
        {
                queuingStructure = PerRank;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("QUEUING STRUCT: per rank");
                }
        }
        else
        {
                cout << "WARNING: Unknown queueing structure '"<<QUEUING_STRUCTURE<<"'; valid options are 'per_rank' and 'per_rank_per_bank', defaulting to Per Rank Per Bank"<<endl;
                queuingStructure = PerRankPerBank;
        }

        if (SCHEDULING_POLICY == "rank_then_bank_round_robin")
        {
                schedulingPolicy = RankThenBankRoundRobin;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("SCHEDULING: Rank Then Bank");
                }
        }
        else if (SCHEDULING_POLICY == "bank_then_rank_round_robin")
        {
                schedulingPolicy = BankThenRankRoundRobin;
                if (DEBUG_INI_READER) 
                {
                        DEBUG("SCHEDULING: Bank Then Rank");
                }
        }
        else
        {
                cout << "WARNING: Unknown scheduling policy '"<<SCHEDULING_POLICY<<"'; valid options are 'rank_then_bank_round_robin' or 'bank_then_rank_round_robin'; defaulting to Bank Then Rank Round Robin" << endl;
                schedulingPolicy = BankThenRankRoundRobin;
        }

}

} // namespace DRAMSim

permissions: 
#ifndef INIREADER_H
#define INIREADER_H

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <map> 
#include "SystemConfiguration.h"

using namespace std;

#define DEFINE_UINT_PARAM(name, paramtype) {#name, &name, UINT, paramtype, false}
#define DEFINE_STRING_PARAM(name, paramtype) {#name, &name, STRING, paramtype, false}
#define DEFINE_FLOAT_PARAM(name,paramtype) {#name, &name, FLOAT, paramtype, false}
#define DEFINE_BOOL_PARAM(name, paramtype) {#name, &name, BOOL, paramtype, false}
#define DEFINE_UINT64_PARAM(name, paramtype) {#name, &name, UINT64, paramtype, false}

namespace DRAMSim
{

typedef enum _variableType {STRING, UINT, UINT64, FLOAT, BOOL} varType;
typedef enum _paramType {SYS_PARAM, DEV_PARAM} paramType;
typedef struct _configMap
{
        string iniKey; //for example "tRCD"

        void *variablePtr;
        varType variableType;
        paramType parameterType;
        bool wasSet;
} ConfigMap;

class IniReader
{

public:
        typedef std::map<string, string> OverrideMap;
        typedef OverrideMap::const_iterator OverrideIterator; 

        static void SetKey(string key, string value, bool isSystemParam = false, size_t lineNumber = 0);
        static void OverrideKeys(const OverrideMap *map);
        static void ReadIniFile(string filename, bool isSystemParam);
        static void InitEnumsFromStrings();
        static bool CheckIfAllSet();
        static void WriteValuesOut(std::ofstream &visDataOut);
        static int getBool(const std::string &field, bool *val);
        static int getUint(const std::string &field, unsigned int *val);
        static int getUint64(const std::string &field, uint64_t *val);
        static int getFloat(const std::string &field, float *val);

private:
        static void WriteParams(std::ofstream &visDataOut, paramType t);
        static void Trim(string &str);
};
}


#endif
  pull-requests: read # allows SonarQube to decorate PRs with analysis results

jobs: CXXFLAGS=-DNO_STORAGE -Wall -DDEBUG_BUILD 
OPTFLAGS=-O3 


ifdef DEBUG
ifeq ($(DEBUG), 1)
OPTFLAGS= -O0 -g
endif
endif
CXXFLAGS+=$(OPTFLAGS)

EXE_NAME=DRAMSim
STATIC_LIB_NAME := libdramsim.a
LIB_NAME=libdramsim.so
LIB_NAME_MACOS=libdramsim.dylib

SRC = $(wildcard *.cpp)
OBJ = $(addsuffix .o, $(basename $(SRC)))

LIB_SRC := $(filter-out TraceBasedSim.cpp,$(SRC))
LIB_OBJ := $(addsuffix .o, $(basename $(LIB_SRC)))

#build portable objects (i.e. with -fPIC)
POBJ = $(addsuffix .po, $(basename $(LIB_SRC)))

REBUILDABLES=$(OBJ) ${POBJ} $(EXE_NAME) $(LIB_NAME) $(STATIC_LIB_NAME)

all: ${EXE_NAME}

#   $@ target name, $^ target deps, $< matched pattern
$(EXE_NAME): $(OBJ)
        $(CXX) $(CXXFLAGS) -o $@ $^ 
        @echo "Built $@ successfully" 

$(LIB_NAME): $(POBJ)
        g++ -g -shared -Wl,-soname,$@ -o $@ $^
        @echo "Built $@ successfully"

$(STATIC_LIB_NAME): $(LIB_OBJ)
        $(AR) crs $@ $^

$(LIB_NAME_MACOS): $(POBJ)
        g++ -dynamiclib -o $@ $^
        @echo "Built $@ successfully"

#include the autogenerated dependency files for each .o file
-include $(OBJ:.o=.dep)
-include $(POBJ:.po=.deppo)

# build dependency list via gcc -M and save to a .dep file
%.dep : %.cpp
        @$(CXX) -M $(CXXFLAGS) $< > $@

%.deppo : %.cpp
        @$(CXX) -M $(CXXFLAGS) -MT"$*.po" $< > $@

# build all .cpp files to .o files
%.o : %.cpp
        g++ $(CXXFLAGS) -o $@ -c $<

#po = portable object .. for lack of a better term
%.po : %.cpp
        g++ $(CXXFLAGS) -DLOG_OUTPUT -fPIC -o $@ -c $<

clean: 
        -rm -f $(REBUILDABLES) *.dep *.deppo
  Analysis: 


//MemoryController.cpp
//
//Class file for memory controller object
//

#include "MemoryController.h"
#include "MemorySystem.h"
#include "AddressMapping.h"

#define SEQUENTIAL(rank,bank) (rank*NUM_BANKS)+bank

/* Power computations are localized to MemoryController.cpp */ 
extern unsigned IDD0;
extern unsigned IDD1;
extern unsigned IDD2P;
extern unsigned IDD2Q;
extern unsigned IDD2N;
extern unsigned IDD3Pf;
extern unsigned IDD3Ps;
extern unsigned IDD3N;
extern unsigned IDD4W;
extern unsigned IDD4R;
extern unsigned IDD5;
extern unsigned IDD6;
extern unsigned IDD6L;
extern unsigned IDD7;
extern float Vdd; 

using namespace DRAMSim;

MemoryController::MemoryController(MemorySystem *parent, CSVWriter &csvOut_, ostream &dramsim_log_) :
                dramsim_log(dramsim_log_),
                bankStates(NUM_RANKS, vector<BankState>(NUM_BANKS, dramsim_log)),
                commandQueue(bankStates, dramsim_log_),
                poppedBusPacket(NULL),
                csvOut(csvOut_),
                totalTransactions(0),
                refreshRank(0)
{
        //get handle on parent
        parentMemorySystem = parent;


        //bus related fields
        outgoingCmdPacket = NULL;
        outgoingDataPacket = NULL;
        dataCyclesLeft = 0;
        cmdCyclesLeft = 0;

        //set here to avoid compile errors
        currentClockCycle = 0;

        //reserve memory for vectors
        transactionQueue.reserve(TRANS_QUEUE_DEPTH);
        powerDown = vector<bool>(NUM_RANKS,false);
        grandTotalBankAccesses = vector<uint64_t>(NUM_RANKS*NUM_BANKS,0);
        totalReadsPerBank = vector<uint64_t>(NUM_RANKS*NUM_BANKS,0);
        totalWritesPerBank = vector<uint64_t>(NUM_RANKS*NUM_BANKS,0);
        totalReadsPerRank = vector<uint64_t>(NUM_RANKS,0);
        totalWritesPerRank = vector<uint64_t>(NUM_RANKS,0);

        writeDataCountdown.reserve(NUM_RANKS);
        writeDataToSend.reserve(NUM_RANKS);
        refreshCountdown.reserve(NUM_RANKS);

        //Power related packets
        backgroundEnergy = vector <uint64_t >(NUM_RANKS,0);
        burstEnergy = vector <uint64_t> (NUM_RANKS,0);
        actpreEnergy = vector <uint64_t> (NUM_RANKS,0);
        refreshEnergy = vector <uint64_t> (NUM_RANKS,0);

        totalEpochLatency = vector<uint64_t> (NUM_RANKS*NUM_BANKS,0);

        //staggers when each rank is due for a refresh
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                refreshCountdown.push_back((int)((REFRESH_PERIOD/tCK)/NUM_RANKS)*(i+1));
        }
}

//get a bus packet from either data or cmd bus
void MemoryController::receiveFromBus(BusPacket *bpacket)
{
        if (bpacket->busPacketType != DATA)
        {
                ERROR("== Error - Memory Controller received a non-DATA bus packet from rank");
                bpacket->print();
                exit(0);
        }

        if (DEBUG_BUS)
        {
                PRINTN(" -- MC Receiving From Data Bus : ");
                bpacket->print();
        }

        //add to return read data queue
        returnTransaction.push_back(new Transaction(RETURN_DATA, bpacket->physicalAddress, bpacket->data));
        totalReadsPerBank[SEQUENTIAL(bpacket->rank,bpacket->bank)]++;

        // this delete statement saves a mindboggling amount of memory
        delete(bpacket);
}

//sends read data back to the CPU
void MemoryController::returnReadData(const Transaction *trans)
{
        if (parentMemorySystem->ReturnReadData!=NULL)
        {
                (*parentMemorySystem->ReturnReadData)(parentMemorySystem->systemID, trans->address, currentClockCycle);
        }
}

//gives the memory controller a handle on the rank objects
void MemoryController::attachRanks(vector<Rank *> *ranks)
{
        this->ranks = ranks;
}

//memory controller update
void MemoryController::update()
{

        //PRINT(" ------------------------- [" << currentClockCycle << "] -------------------------");

        //update bank states
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                for (size_t j=0;j<NUM_BANKS;j++)
                {
                        if (bankStates[i][j].stateChangeCountdown>0)
                        {
                                //decrement counters
                                bankStates[i][j].stateChangeCountdown--;

                                //if counter has reached 0, change state
                                if (bankStates[i][j].stateChangeCountdown == 0)
                                {
                                        switch (bankStates[i][j].lastCommand)
                                        {
                                                //only these commands have an implicit state change
                                        case WRITE_P:
                                        case READ_P:
                                                bankStates[i][j].currentBankState = Precharging;
                                                bankStates[i][j].lastCommand = PRECHARGE;
                                                bankStates[i][j].stateChangeCountdown = tRP;
                                                break;

                                        case REFRESH:
                                        case PRECHARGE:
                                                bankStates[i][j].currentBankState = Idle;
                                                break;
                                        default:
                                                break;
                                        }
                                }
                        }
                }
        }


        //check for outgoing command packets and handle countdowns
        if (outgoingCmdPacket != NULL)
        {
                cmdCyclesLeft--;
                if (cmdCyclesLeft == 0) //packet is ready to be received by rank
                {
                        (*ranks)[outgoingCmdPacket->rank]->receiveFromBus(outgoingCmdPacket);
                        outgoingCmdPacket = NULL;
                }
        }

        //check for outgoing data packets and handle countdowns
        if (outgoingDataPacket != NULL)
        {
                dataCyclesLeft--;
                if (dataCyclesLeft == 0)
                {
                        //inform upper levels that a write is done
                        if (parentMemorySystem->WriteDataDone!=NULL)
                        {
                                (*parentMemorySystem->WriteDataDone)(parentMemorySystem->systemID,outgoingDataPacket->physicalAddress, currentClockCycle);
                        }

                        (*ranks)[outgoingDataPacket->rank]->receiveFromBus(outgoingDataPacket);
                        outgoingDataPacket=NULL;
                }
        }


        //if any outstanding write data needs to be sent
        //and the appropriate amount of time has passed (WL)
        //then send data on bus
        //
        //write data held in fifo vector along with countdowns
        if (writeDataCountdown.size() > 0)
        {
                for (size_t i=0;i<writeDataCountdown.size();i++)
                {
                        writeDataCountdown[i]--;
                }

                if (writeDataCountdown[0]==0)
                {
                        //send to bus and print debug stuff
                        if (DEBUG_BUS)
                        {
                                PRINTN(" -- MC Issuing On Data Bus    : ");
                                writeDataToSend[0]->print();
                        }

                        // queue up the packet to be sent
                        if (outgoingDataPacket != NULL)
                        {
                                ERROR("== Error - Data Bus Collision");
                                exit(-1);
                        }

                        outgoingDataPacket = writeDataToSend[0];
                        dataCyclesLeft = BL/2;

                        totalTransactions++;
                        totalWritesPerBank[SEQUENTIAL(writeDataToSend[0]->rank,writeDataToSend[0]->bank)]++;

                        writeDataCountdown.erase(writeDataCountdown.begin());
                        writeDataToSend.erase(writeDataToSend.begin());
                }
        }

        //if its time for a refresh issue a refresh
        // else pop from command queue if it's not empty
        if (refreshCountdown[refreshRank]==0)
        {
                commandQueue.needRefresh(refreshRank);
                (*ranks)[refreshRank]->refreshWaiting = true;
                refreshCountdown[refreshRank] =         REFRESH_PERIOD/tCK;
                refreshRank++;
                if (refreshRank == NUM_RANKS)
                {
                        refreshRank = 0;
                }
        }
        //if a rank is powered down, make sure we power it up in time for a refresh
        else if (powerDown[refreshRank] && refreshCountdown[refreshRank] <= tXP)
        {
                (*ranks)[refreshRank]->refreshWaiting = true;
        }

        //pass a pointer to a poppedBusPacket

        //function returns true if there is something valid in poppedBusPacket
        if (commandQueue.pop(&poppedBusPacket))
        {
                if (poppedBusPacket->busPacketType == WRITE || poppedBusPacket->busPacketType == WRITE_P)
                {

                        writeDataToSend.push_back(new BusPacket(DATA, poppedBusPacket->physicalAddress, poppedBusPacket->column,
                                                            poppedBusPacket->row, poppedBusPacket->rank, poppedBusPacket->bank,
                                                            poppedBusPacket->data, dramsim_log));
                        writeDataCountdown.push_back(WL);
                }

                //
                //update each bank's state based on the command that was just popped out of the command queue
                //
                //for readability's sake
                unsigned rank = poppedBusPacket->rank;
                unsigned bank = poppedBusPacket->bank;
                switch (poppedBusPacket->busPacketType)
                {
                        case READ_P:
                        case READ:
                                //add energy to account for total
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding Read energy to total energy");
                                }
                                burstEnergy[rank] += (IDD4R - IDD3N) * BL/2 * NUM_DEVICES;
                                if (poppedBusPacket->busPacketType == READ_P) 
                                {
                                        //Don't bother setting next read or write times because the bank is no longer active
                                        //bankStates[rank][bank].currentBankState = Idle;
                                        bankStates[rank][bank].nextActivate = max(currentClockCycle + READ_AUTOPRE_DELAY,
                                                        bankStates[rank][bank].nextActivate);
                                        bankStates[rank][bank].lastCommand = READ_P;
                                        bankStates[rank][bank].stateChangeCountdown = READ_TO_PRE_DELAY;
                                }
                                else if (poppedBusPacket->busPacketType == READ)
                                {
                                        bankStates[rank][bank].nextPrecharge = max(currentClockCycle + READ_TO_PRE_DELAY,
                                                        bankStates[rank][bank].nextPrecharge);
                                        bankStates[rank][bank].lastCommand = READ;

                                }

                                for (size_t i=0;i<NUM_RANKS;i++)
                                {
                                        for (size_t j=0;j<NUM_BANKS;j++)
                                        {
                                                if (i!=poppedBusPacket->rank)
                                                {
                                                        //check to make sure it is active before trying to set (save's time?)
                                                        if (bankStates[i][j].currentBankState == RowActive)
                                                        {
                                                                bankStates[i][j].nextRead = max(currentClockCycle + BL/2 + tRTRS, bankStates[i][j].nextRead);
                                                                bankStates[i][j].nextWrite = max(currentClockCycle + READ_TO_WRITE_DELAY,
                                                                                bankStates[i][j].nextWrite);
                                                        }
                                                }
                                                else
                                                {
                                                        bankStates[i][j].nextRead = max(currentClockCycle + max(tCCD, BL/2), bankStates[i][j].nextRead);
                                                        bankStates[i][j].nextWrite = max(currentClockCycle + READ_TO_WRITE_DELAY,
                                                                        bankStates[i][j].nextWrite);
                                                }
                                        }
                                }

                                if (poppedBusPacket->busPacketType == READ_P)
                                {
                                        //set read and write to nextActivate so the state table will prevent a read or write
                                        //  being issued (in cq.isIssuable())before the bank state has been changed because of the
                                        //  auto-precharge associated with this command
                                        bankStates[rank][bank].nextRead = bankStates[rank][bank].nextActivate;
                                        bankStates[rank][bank].nextWrite = bankStates[rank][bank].nextActivate;
                                }

                                break;
                        case WRITE_P:
                        case WRITE:
                                if (poppedBusPacket->busPacketType == WRITE_P) 
                                {
                                        bankStates[rank][bank].nextActivate = max(currentClockCycle + WRITE_AUTOPRE_DELAY,
                                                        bankStates[rank][bank].nextActivate);
                                        bankStates[rank][bank].lastCommand = WRITE_P;
                                        bankStates[rank][bank].stateChangeCountdown = WRITE_TO_PRE_DELAY;
                                }
                                else if (poppedBusPacket->busPacketType == WRITE)
                                {
                                        bankStates[rank][bank].nextPrecharge = max(currentClockCycle + WRITE_TO_PRE_DELAY,
                                                        bankStates[rank][bank].nextPrecharge);
                                        bankStates[rank][bank].lastCommand = WRITE;
                                }


                                //add energy to account for total
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding Write energy to total energy");
                                }
                                burstEnergy[rank] += (IDD4W - IDD3N) * BL/2 * NUM_DEVICES;

                                for (size_t i=0;i<NUM_RANKS;i++)
                                {
                                        for (size_t j=0;j<NUM_BANKS;j++)
                                        {
                                                if (i!=poppedBusPacket->rank)
                                                {
                                                        if (bankStates[i][j].currentBankState == RowActive)
                                                        {
                                                                bankStates[i][j].nextWrite = max(currentClockCycle + BL/2 + tRTRS, bankStates[i][j].nextWrite);
                                                                bankStates[i][j].nextRead = max(currentClockCycle + WRITE_TO_READ_DELAY_R,
                                                                                bankStates[i][j].nextRead);
                                                        }
                                                }
                                                else
                                                {
                                                        bankStates[i][j].nextWrite = max(currentClockCycle + max(BL/2, tCCD), bankStates[i][j].nextWrite);
                                                        bankStates[i][j].nextRead = max(currentClockCycle + WRITE_TO_READ_DELAY_B,
                                                                        bankStates[i][j].nextRead);
                                                }
                                        }
                                }

                                //set read and write to nextActivate so the state table will prevent a read or write
                                //  being issued (in cq.isIssuable())before the bank state has been changed because of the
                                //  auto-precharge associated with this command
                                if (poppedBusPacket->busPacketType == WRITE_P)
                                {
                                        bankStates[rank][bank].nextRead = bankStates[rank][bank].nextActivate;
                                        bankStates[rank][bank].nextWrite = bankStates[rank][bank].nextActivate;
                                }

                                break;
                        case ACTIVATE:
                                //add energy to account for total
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding Activate and Precharge energy to total energy");
                                }
                                actpreEnergy[rank] += ((IDD0 * tRC) - ((IDD3N * tRAS) + (IDD2N * (tRC - tRAS)))) * NUM_DEVICES;

                                bankStates[rank][bank].currentBankState = RowActive;
                                bankStates[rank][bank].lastCommand = ACTIVATE;
                                bankStates[rank][bank].openRowAddress = poppedBusPacket->row;
                                bankStates[rank][bank].nextActivate = max(currentClockCycle + tRC, bankStates[rank][bank].nextActivate);
                                bankStates[rank][bank].nextPrecharge = max(currentClockCycle + tRAS, bankStates[rank][bank].nextPrecharge);

                                //if we are using posted-CAS, the next column access can be sooner than normal operation

                                bankStates[rank][bank].nextRead = max(currentClockCycle + (tRCD-AL), bankStates[rank][bank].nextRead);
                                bankStates[rank][bank].nextWrite = max(currentClockCycle + (tRCD-AL), bankStates[rank][bank].nextWrite);

                                for (size_t i=0;i<NUM_BANKS;i++)
                                {
                                        if (i!=poppedBusPacket->bank)
                                        {
                                                bankStates[rank][i].nextActivate = max(currentClockCycle + tRRD, bankStates[rank][i].nextActivate);
                                        }
                                }

                                break;
                        case PRECHARGE:
                                bankStates[rank][bank].currentBankState = Precharging;
                                bankStates[rank][bank].lastCommand = PRECHARGE;
                                bankStates[rank][bank].stateChangeCountdown = tRP;
                                bankStates[rank][bank].nextActivate = max(currentClockCycle + tRP, bankStates[rank][bank].nextActivate);

                                break;
                        case REFRESH:
                                //add energy to account for total
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding Refresh energy to total energy");
                                }
                                refreshEnergy[rank] += (IDD5 - IDD3N) * tRFC * NUM_DEVICES;

                                for (size_t i=0;i<NUM_BANKS;i++)
                                {
                                        bankStates[rank][i].nextActivate = currentClockCycle + tRFC;
                                        bankStates[rank][i].currentBankState = Refreshing;
                                        bankStates[rank][i].lastCommand = REFRESH;
                                        bankStates[rank][i].stateChangeCountdown = tRFC;
                                }

                                break;
                        default:
                                ERROR("== Error - Popped a command we shouldn't have of type : " << poppedBusPacket->busPacketType);
                                exit(0);
                }

                //issue on bus and print debug
                if (DEBUG_BUS)
                {
                        PRINTN(" -- MC Issuing On Command Bus : ");
                        poppedBusPacket->print();
                }

                //check for collision on bus
                if (outgoingCmdPacket != NULL)
                {
                        ERROR("== Error - Command Bus Collision");
                        exit(-1);
                }
                outgoingCmdPacket = poppedBusPacket;
                cmdCyclesLeft = tCMD;

        }

        for (size_t i=0;i<transactionQueue.size();i++)
        {
                //pop off top transaction from queue
                //
                //        assuming simple scheduling at the moment
                //        will eventually add policies here
                Transaction *transaction = transactionQueue[i];

                //map address to rank,bank,row,col
                unsigned newTransactionChan, newTransactionRank, newTransactionBank, newTransactionRow, newTransactionColumn;

                // pass these in as references so they get set by the addressMapping function
                addressMapping(transaction->address, newTransactionChan, newTransactionRank, newTransactionBank, newTransactionRow, newTransactionColumn);

                //if we have room, break up the transaction into the appropriate commands
                //and add them to the command queue
                if (commandQueue.hasRoomFor(2, newTransactionRank, newTransactionBank))
                {
                        if (DEBUG_ADDR_MAP) 
                        {
                                PRINTN("== New Transaction - Mapping Address [0x" << hex << transaction->address << dec << "]");
                                if (transaction->transactionType == DATA_READ) 
                                {
                                        PRINT(" (Read)");
                                }
                                else
                                {
                                        PRINT(" (Write)");
                                }
                                PRINT("  Rank : " << newTransactionRank);
                                PRINT("  Bank : " << newTransactionBank);
                                PRINT("  Row  : " << newTransactionRow);
                                PRINT("  Col  : " << newTransactionColumn);
                        }



                        //now that we know there is room in the command queue, we can remove from the transaction queue
                        transactionQueue.erase(transactionQueue.begin()+i);

                        //create activate command to the row we just translated
                        BusPacket *ACTcommand = new BusPacket(ACTIVATE, transaction->address,
                                        newTransactionColumn, newTransactionRow, newTransactionRank,
                                        newTransactionBank, 0, dramsim_log);

                        //create read or write command and enqueue it
                        BusPacketType bpType = transaction->getBusPacketType();
                        BusPacket *command = new BusPacket(bpType, transaction->address,
                                        newTransactionColumn, newTransactionRow, newTransactionRank,
                                        newTransactionBank, transaction->data, dramsim_log);



                        commandQueue.enqueue(ACTcommand);
                        commandQueue.enqueue(command);

                        // If we have a read, save the transaction so when the data comes back
                        // in a bus packet, we can staple it back into a transaction and return it
                        if (transaction->transactionType == DATA_READ)
                        {
                                pendingReadTransactions.push_back(transaction);
                        }
                        else
                        {
                                // just delete the transaction now that it's a buspacket
                                delete transaction; 
                        }
                        /* only allow one transaction to be scheduled per cycle -- this should
                         * be a reasonable assumption considering how much logic would be
                         * required to schedule multiple entries per cycle (parallel data
                         * lines, switching logic, decision logic)
                         */
                        break;
                }
                else // no room, do nothing this cycle
                {
                        //PRINT( "== Warning - No room in command queue" << endl;
                }
        }


        //calculate power
        //  this is done on a per-rank basis, since power characterization is done per device (not per bank)
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                if (USE_LOW_POWER)
                {
                        //if there are no commands in the queue and that particular rank is not waiting for a refresh...
                        if (commandQueue.isEmpty(i) && !(*ranks)[i]->refreshWaiting)
                        {
                                //check to make sure all banks are idle
                                bool allIdle = true;
                                for (size_t j=0;j<NUM_BANKS;j++)
                                {
                                        if (bankStates[i][j].currentBankState != Idle)
                                        {
                                                allIdle = false;
                                                break;
                                        }
                                }

                                //if they ARE all idle, put in power down mode and set appropriate fields
                                if (allIdle)
                                {
                                        powerDown[i] = true;
                                        (*ranks)[i]->powerDown();
                                        for (size_t j=0;j<NUM_BANKS;j++)
                                        {
                                                bankStates[i][j].currentBankState = PowerDown;
                                                bankStates[i][j].nextPowerUp = currentClockCycle + tCKE;
                                        }
                                }
                        }
                        //if there IS something in the queue or there IS a refresh waiting (and we can power up), do it
                        else if (currentClockCycle >= bankStates[i][0].nextPowerUp && powerDown[i]) //use 0 since theyre all the same
                        {
                                powerDown[i] = false;
                                (*ranks)[i]->powerUp();
                                for (size_t j=0;j<NUM_BANKS;j++)
                                {
                                        bankStates[i][j].currentBankState = Idle;
                                        bankStates[i][j].nextActivate = currentClockCycle + tXP;
                                }
                        }
                }

                //check for open bank
                bool bankOpen = false;
                for (size_t j=0;j<NUM_BANKS;j++)
                {
                        if (bankStates[i][j].currentBankState == Refreshing ||
                                bankStates[i][j].currentBankState == RowActive)
                        {
                                bankOpen = true;
                                break;
                        }
                }

                //background power is dependent on whether or not a bank is open or not
                if (bankOpen)
                {
                        if (DEBUG_POWER)
                        {
                                PRINT(" ++ Adding IDD3N to total energy [from rank "<< i <<"]");
                        }
                        backgroundEnergy[i] += IDD3N * NUM_DEVICES;
                }
                else
                {
                        //if we're in power-down mode, use the correct current
                        if (powerDown[i])
                        {
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding IDD2P to total energy [from rank " << i << "]");
                                }
                                backgroundEnergy[i] += IDD2P * NUM_DEVICES;
                        }
                        else
                        {
                                if (DEBUG_POWER)
                                {
                                        PRINT(" ++ Adding IDD2N to total energy [from rank " << i << "]");
                                }
                                backgroundEnergy[i] += IDD2N * NUM_DEVICES;
                        }
                }
        }

        //check for outstanding data to return to the CPU
        if (returnTransaction.size()>0)
        {
                if (DEBUG_BUS)
                {
                        PRINTN(" -- MC Issuing to CPU bus : " << *returnTransaction[0]);
                }
                totalTransactions++;

                bool foundMatch=false;
                //find the pending read transaction to calculate latency
                for (size_t i=0;i<pendingReadTransactions.size();i++)
                {
                        if (pendingReadTransactions[i]->address == returnTransaction[0]->address)
                        {
                                //if(currentClockCycle - pendingReadTransactions[i]->timeAdded > 2000)
                                //        {
                                //                pendingReadTransactions[i]->print();
                                //                exit(0);
                                //        }
                                unsigned chan,rank,bank,row,col;
                                addressMapping(returnTransaction[0]->address,chan,rank,bank,row,col);
                                insertHistogram(currentClockCycle-pendingReadTransactions[i]->timeAdded,rank,bank);
                                //return latency
                                returnReadData(pendingReadTransactions[i]);

                                delete pendingReadTransactions[i];
                                pendingReadTransactions.erase(pendingReadTransactions.begin()+i);
                                foundMatch=true; 
                                break;
                        }
                }
                if (!foundMatch)
                {
                        ERROR("Can't find a matching transaction for 0x"<<hex<<returnTransaction[0]->address<<dec);
                        abort(); 
                }
                delete returnTransaction[0];
                returnTransaction.erase(returnTransaction.begin());
        }

        //decrement refresh counters
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                refreshCountdown[i]--;
        }

        //
        //print debug
        //
        if (DEBUG_TRANS_Q)
        {
                PRINT("== Printing transaction queue");
                for (size_t i=0;i<transactionQueue.size();i++)
                {
                        PRINTN("  " << i << "] "<< *transactionQueue[i]);
                }
        }

        if (DEBUG_BANKSTATE)
        {
                //TODO: move this to BankState.cpp
                PRINT("== Printing bank states (According to MC)");
                for (size_t i=0;i<NUM_RANKS;i++)
                {
                        for (size_t j=0;j<NUM_BANKS;j++)
                        {
                                if (bankStates[i][j].currentBankState == RowActive)
                                {
                                        PRINTN("[" << bankStates[i][j].openRowAddress << "] ");
                                }
                                else if (bankStates[i][j].currentBankState == Idle)
                                {
                                        PRINTN("[idle] ");
                                }
                                else if (bankStates[i][j].currentBankState == Precharging)
                                {
                                        PRINTN("[pre] ");
                                }
                                else if (bankStates[i][j].currentBankState == Refreshing)
                                {
                                        PRINTN("[ref] ");
                                }
                                else if (bankStates[i][j].currentBankState == PowerDown)
                                {
                                        PRINTN("[lowp] ");
                                }
                        }
                        PRINT(""); // effectively just cout<<endl;
                }
        }

        if (DEBUG_CMD_Q)
        {
                commandQueue.print();
        }

        commandQueue.step();

}

bool MemoryController::WillAcceptTransaction()
{
        return transactionQueue.size() < TRANS_QUEUE_DEPTH;
}

//allows outside source to make request of memory system
bool MemoryController::addTransaction(Transaction *trans)
{
        if (WillAcceptTransaction())
        {
                trans->timeAdded = currentClockCycle;
                transactionQueue.push_back(trans);
                return true;
        }
        else 
        {
                return false;
        }
}

void MemoryController::resetStats()
{
        for (size_t i=0; i<NUM_RANKS; i++)
        {
                for (size_t j=0; j<NUM_BANKS; j++)
                {
                        //XXX: this means the bank list won't be printed for partial epochs
                        grandTotalBankAccesses[SEQUENTIAL(i,j)] += totalReadsPerBank[SEQUENTIAL(i,j)] + totalWritesPerBank[SEQUENTIAL(i,j)];
                        totalReadsPerBank[SEQUENTIAL(i,j)] = 0;
                        totalWritesPerBank[SEQUENTIAL(i,j)] = 0;
                        totalEpochLatency[SEQUENTIAL(i,j)] = 0;
                }

                burstEnergy[i] = 0;
                actpreEnergy[i] = 0;
                refreshEnergy[i] = 0;
                backgroundEnergy[i] = 0;
                totalReadsPerRank[i] = 0;
                totalWritesPerRank[i] = 0;
        }
}
//prints statistics at the end of an epoch or  simulation
void MemoryController::printStats(bool finalStats)
{
        unsigned myChannel = parentMemorySystem->systemID;

        //if we are not at the end of the epoch, make sure to adjust for the actual number of cycles elapsed

        uint64_t cyclesElapsed = (currentClockCycle % EPOCH_LENGTH == 0) ? EPOCH_LENGTH : currentClockCycle % EPOCH_LENGTH;
        unsigned bytesPerTransaction = (JEDEC_DATA_BUS_BITS*BL)/8;
        uint64_t totalBytesTransferred = totalTransactions * bytesPerTransaction;
        double secondsThisEpoch = (double)cyclesElapsed * tCK * 1E-9;

        // only per rank
        vector<double> backgroundPower = vector<double>(NUM_RANKS,0.0);
        vector<double> burstPower = vector<double>(NUM_RANKS,0.0);
        vector<double> refreshPower = vector<double>(NUM_RANKS,0.0);
        vector<double> actprePower = vector<double>(NUM_RANKS,0.0);
        vector<double> averagePower = vector<double>(NUM_RANKS,0.0);

        // per bank variables
        vector<double> averageLatency = vector<double>(NUM_RANKS*NUM_BANKS,0.0);
        vector<double> bandwidth = vector<double>(NUM_RANKS*NUM_BANKS,0.0);

        double totalBandwidth=0.0;
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                for (size_t j=0; j<NUM_BANKS; j++)
                {
                        bandwidth[SEQUENTIAL(i,j)] = (((double)(totalReadsPerBank[SEQUENTIAL(i,j)]+totalWritesPerBank[SEQUENTIAL(i,j)]) * (double)bytesPerTransaction)/(1024.0*1024.0*1024.0)) / secondsThisEpoch;
                        averageLatency[SEQUENTIAL(i,j)] = ((float)totalEpochLatency[SEQUENTIAL(i,j)] / (float)(totalReadsPerBank[SEQUENTIAL(i,j)])) * tCK;
                        totalBandwidth+=bandwidth[SEQUENTIAL(i,j)];
                        totalReadsPerRank[i] += totalReadsPerBank[SEQUENTIAL(i,j)];
                        totalWritesPerRank[i] += totalWritesPerBank[SEQUENTIAL(i,j)];
                }
        }
#ifdef LOG_OUTPUT
        dramsim_log.precision(3);
        dramsim_log.setf(ios::fixed,ios::floatfield);
#else
        cout.precision(3);
        cout.setf(ios::fixed,ios::floatfield);
#endif

        PRINT( " =======================================================" );
        PRINT( " ============== Printing Statistics [id:"<<parentMemorySystem->systemID<<"]==============" );
        PRINTN( "   Total Return Transactions : " << totalTransactions );
        PRINT( " ("<<totalBytesTransferred <<" bytes) aggregate average bandwidth "<<totalBandwidth<<"GB/s");

        double totalAggregateBandwidth = 0.0;        
        for (size_t r=0;r<NUM_RANKS;r++)
        {

                PRINT( "      -Rank   "<<r<<" : ");
                PRINTN( "        -Reads  : " << totalReadsPerRank[r]);
                PRINT( " ("<<totalReadsPerRank[r] * bytesPerTransaction<<" bytes)");
                PRINTN( "        -Writes : " << totalWritesPerRank[r]);
                PRINT( " ("<<totalWritesPerRank[r] * bytesPerTransaction<<" bytes)");
                for (size_t j=0;j<NUM_BANKS;j++)
                {
                        PRINT( "        -Bandwidth / Latency  (Bank " <<j<<"): " <<bandwidth[SEQUENTIAL(r,j)] << " GB/s\t\t" <<averageLatency[SEQUENTIAL(r,j)] << " ns");
                }

                // factor of 1000 at the end is to account for the fact that totalEnergy is accumulated in mJ since IDD values are given in mA
                backgroundPower[r] = ((double)backgroundEnergy[r] / (double)(cyclesElapsed)) * Vdd / 1000.0;
                burstPower[r] = ((double)burstEnergy[r] / (double)(cyclesElapsed)) * Vdd / 1000.0;
                refreshPower[r] = ((double) refreshEnergy[r] / (double)(cyclesElapsed)) * Vdd / 1000.0;
                actprePower[r] = ((double)actpreEnergy[r] / (double)(cyclesElapsed)) * Vdd / 1000.0;
                averagePower[r] = ((backgroundEnergy[r] + burstEnergy[r] + refreshEnergy[r] + actpreEnergy[r]) / (double)cyclesElapsed) * Vdd / 1000.0;

                if ((*parentMemorySystem->ReportPower)!=NULL)
                {
                        (*parentMemorySystem->ReportPower)(backgroundPower[r],burstPower[r],refreshPower[r],actprePower[r]);
                }

                PRINT( " == Power Data for Rank        " << r );
                PRINT( "   Average Power (watts)     : " << averagePower[r] );
                PRINT( "     -Background (watts)     : " << backgroundPower[r] );
                PRINT( "     -Act/Pre    (watts)     : " << actprePower[r] );
                PRINT( "     -Burst      (watts)     : " << burstPower[r]);
                PRINT( "     -Refresh    (watts)     : " << refreshPower[r] );

                if (VIS_FILE_OUTPUT)
                {
                //        cout << "c="<<myChannel<< " r="<<r<<"writing to csv out on cycle "<< currentClockCycle<<endl;
                        // write the vis file output
                        csvOut << CSVWriter::IndexedName("Background_Power",myChannel,r) <<backgroundPower[r];
                        csvOut << CSVWriter::IndexedName("ACT_PRE_Power",myChannel,r) << actprePower[r];
                        csvOut << CSVWriter::IndexedName("Burst_Power",myChannel,r) << burstPower[r];
                        csvOut << CSVWriter::IndexedName("Refresh_Power",myChannel,r) << refreshPower[r];
                        double totalRankBandwidth=0.0;
                        for (size_t b=0; b<NUM_BANKS; b++)
                        {
                                csvOut << CSVWriter::IndexedName("Bandwidth",myChannel,r,b) << bandwidth[SEQUENTIAL(r,b)];
                                totalRankBandwidth += bandwidth[SEQUENTIAL(r,b)];
                                totalAggregateBandwidth += bandwidth[SEQUENTIAL(r,b)];
                                csvOut << CSVWriter::IndexedName("Average_Latency",myChannel,r,b) << averageLatency[SEQUENTIAL(r,b)];
                        }
                        csvOut << CSVWriter::IndexedName("Rank_Aggregate_Bandwidth",myChannel,r) << totalRankBandwidth; 
                        csvOut << CSVWriter::IndexedName("Rank_Average_Bandwidth",myChannel,r) << totalRankBandwidth/NUM_RANKS; 
                }
        }
        if (VIS_FILE_OUTPUT)
        {
                csvOut << CSVWriter::IndexedName("Aggregate_Bandwidth",myChannel) << totalAggregateBandwidth;
                csvOut << CSVWriter::IndexedName("Average_Bandwidth",myChannel) << totalAggregateBandwidth / (NUM_RANKS*NUM_BANKS);
        }

        // only print the latency histogram at the end of the simulation since it clogs the output too much to print every epoch
        if (finalStats)
        {
                PRINT( " ---  Latency list ("<<latencies.size()<<")");
                PRINT( "       [lat] : #");
                if (VIS_FILE_OUTPUT)
                {
                        csvOut.getOutputStream() << "!!HISTOGRAM_DATA"<<endl;
                }

                map<unsigned,unsigned>::iterator it; //
                for (it=latencies.begin(); it!=latencies.end(); it++)
                {
                        PRINT( "       ["<< it->first <<"-"<<it->first+(HISTOGRAM_BIN_SIZE-1)<<"] : "<< it->second );
                        if (VIS_FILE_OUTPUT)
                        {
                                csvOut.getOutputStream() << it->first <<"="<< it->second << endl;
                        }
                }
                if (currentClockCycle % EPOCH_LENGTH == 0)
                {
                        PRINT( " --- Grand Total Bank usage list");
                        for (size_t i=0;i<NUM_RANKS;i++)
                        {
                                PRINT("Rank "<<i<<":"); 
                                for (size_t j=0;j<NUM_BANKS;j++)
                                {
                                        PRINT( "  b"<<j<<": "<<grandTotalBankAccesses[SEQUENTIAL(i,j)]);
                                }
                        }
                }

        }


        PRINT(endl<< " == Pending Transactions : "<<pendingReadTransactions.size()<<" ("<<currentClockCycle<<")==");
        /*
        for(size_t i=0;i<pendingReadTransactions.size();i++)
                {
                        PRINT( i << "] I've been waiting for "<<currentClockCycle-pendingReadTransactions[i].timeAdded<<endl;
                }
        */
#ifdef LOG_OUTPUT
        dramsim_log.flush();
#endif

        resetStats();
}
MemoryController::~MemoryController()
{
        //ERROR("MEMORY CONTROLLER DESTRUCTOR");
        //abort();
        for (size_t i=0; i<pendingReadTransactions.size(); i++)
        {
                delete pendingReadTransactions[i];
        }
        for (size_t i=0; i<returnTransaction.size(); i++)
        {
                delete returnTransaction[i];
        }

}
//inserts a latency into the latency histogram
void MemoryController::insertHistogram(unsigned latencyValue, unsigned rank, unsigned bank)
{
        totalEpochLatency[SEQUENTIAL(rank,bank)] += latencyValue;
        //poor man's way to bin things.
        latencies[(latencyValue/HISTOGRAM_BIN_SIZE)*HISTOGRAM_BIN_SIZE]++;
}
    runs-on: ubuntu-latest

    steps: 

#ifndef MEMORYCONTROLLER_H
#define MEMORYCONTROLLER_H

//MemoryController.h
//
//Header file for memory controller object
//

#include "SimulatorObject.h"
#include "Transaction.h"
#include "SystemConfiguration.h"
#include "CommandQueue.h"
#include "BusPacket.h"
#include "BankState.h"
#include "Rank.h"
#include "CSVWriter.h"
#include <map>

using namespace std;

namespace DRAMSim
{
class MemorySystem;
class MemoryController : public SimulatorObject
{

public:
        //functions
        MemoryController(MemorySystem* ms, CSVWriter &csvOut_, ostream &dramsim_log_);
        virtual ~MemoryController();

        bool addTransaction(Transaction *trans);
        bool WillAcceptTransaction();
        void returnReadData(const Transaction *trans);
        void receiveFromBus(BusPacket *bpacket);
        void attachRanks(vector<Rank *> *ranks);
        void update();
        void printStats(bool finalStats = false);
        void resetStats(); 


        //fields
        vector<Transaction *> transactionQueue;
private:
        ostream &dramsim_log;
        vector< vector <BankState> > bankStates;
        //functions
        void insertHistogram(unsigned latencyValue, unsigned rank, unsigned bank);

        //fields
        MemorySystem *parentMemorySystem;

        CommandQueue commandQueue;
        BusPacket *poppedBusPacket;
        vector<unsigned>refreshCountdown;
        vector<BusPacket *> writeDataToSend;
        vector<unsigned> writeDataCountdown;
        vector<Transaction *> returnTransaction;
        vector<Transaction *> pendingReadTransactions;
        map<unsigned,unsigned> latencies; // latencyValue -> latencyCount
        vector<bool> powerDown;

        vector<Rank *> *ranks;

        //output file
        CSVWriter &csvOut; 

        // these packets are counting down waiting to be transmitted on the "bus"
        BusPacket *outgoingCmdPacket;
        unsigned cmdCyclesLeft;
        BusPacket *outgoingDataPacket;
        unsigned dataCyclesLeft;

        uint64_t totalTransactions;
        vector<uint64_t> grandTotalBankAccesses; 
        vector<uint64_t> totalReadsPerBank;
        vector<uint64_t> totalWritesPerBank;

        vector<uint64_t> totalReadsPerRank;
        vector<uint64_t> totalWritesPerRank;


        vector< uint64_t > totalEpochLatency;

        unsigned channelBitWidth;
        unsigned rankBitWidth;
        unsigned bankBitWidth;
        unsigned rowBitWidth;
        unsigned colBitWidth;
        unsigned byteOffsetWidth;


        unsigned refreshRank;

public:
        // energy values are per rank -- SST uses these directly, so make these public 
        vector< uint64_t > backgroundEnergy;
        vector< uint64_t > burstEnergy;
        vector< uint64_t > actpreEnergy;
        vector< uint64_t > refreshEnergy;

};
}

#endif

      - name: Analyze with SonarQube

        # You can pin the exact commit or the version.
        # uses: SonarSource/sonarqube-scan-action@v1.1.0
        uses: SonarSource/sonarqube-scan-action@7295e71c9583053f5bf40e9d4068a0c974603ec8
        env: 



//MemorySystem.cpp
//
//Class file for JEDEC memory system wrapper
//

#include "MemorySystem.h"
#include "IniReader.h"
#include <unistd.h>

using namespace std;


ofstream cmd_verify_out; //used in Rank.cpp and MemoryController.cpp if VERIFICATION_OUTPUT is set

unsigned NUM_DEVICES;
unsigned NUM_RANKS;
unsigned NUM_RANKS_LOG;

namespace DRAMSim {

powerCallBack_t MemorySystem::ReportPower = NULL;

MemorySystem::MemorySystem(unsigned id, unsigned int megsOfMemory, CSVWriter &csvOut_, ostream &dramsim_log_) :
                dramsim_log(dramsim_log_),
                ReturnReadData(NULL),
                WriteDataDone(NULL),
                systemID(id),
                csvOut(csvOut_)
{
        currentClockCycle = 0;

        DEBUG("===== MemorySystem "<<systemID<<" =====");


        //calculate the total storage based on the devices the user selected and the number of

        //calculate number of devices
        /************************
          This code has always been problematic even though it's pretty simple. I'll try to explain it 
          for my own sanity. 

          There are two main variables here that we could let the user choose:
          NUM_RANKS or TOTAL_STORAGE.  Since the density and width of the part is
          fixed by the device ini file, the only variable that is really
          controllable is the number of ranks. Users care more about choosing the
          total amount of storage, but with a fixed device they might choose a total
          storage that isn't possible. In that sense it's not as good to allow them
          to choose TOTAL_STORAGE (because any NUM_RANKS value >1 will be valid).

          However, users don't care (or know) about ranks, they care about total
          storage, so maybe it's better to let them choose and just throw an error
          if they choose something invalid. 

          A bit of background: 

          Each column contains DEVICE_WIDTH bits. A row contains NUM_COLS columns.
          Each bank contains NUM_ROWS rows. Therefore, the total storage per DRAM device is: 
                          PER_DEVICE_STORAGE = NUM_ROWS*NUM_COLS*DEVICE_WIDTH*NUM_BANKS (in bits)

         A rank *must* have a 64 bit output bus (JEDEC standard), so each rank must have:
                          NUM_DEVICES_PER_RANK = 64/DEVICE_WIDTH  
                        (note: if you have multiple channels ganged together, the bus width is 
                        effectively NUM_CHANS * 64/DEVICE_WIDTH)
         
        If we multiply these two numbers to get the storage per rank (in bits), we get:
                        PER_RANK_STORAGE = PER_DEVICE_STORAGE*NUM_DEVICES_PER_RANK = NUM_ROWS*NUM_COLS*NUM_BANKS*64 

        Finally, to get TOTAL_STORAGE, we need to multiply by NUM_RANKS
                        TOTAL_STORAGE = PER_RANK_STORAGE*NUM_RANKS (total storage in bits)

        So one could compute this in reverse -- compute NUM_DEVICES,
        PER_DEVICE_STORAGE, and PER_RANK_STORAGE first since all these parameters
        are set by the device ini. Then, TOTAL_STORAGE/PER_RANK_STORAGE = NUM_RANKS 

        The only way this could run into problems is if TOTAL_STORAGE < PER_RANK_STORAGE,
        which could happen for very dense parts.
        *********************/

        // number of bytes per rank
        unsigned long megsOfStoragePerRank = ((((long long)NUM_ROWS * (NUM_COLS * DEVICE_WIDTH) * NUM_BANKS) * ((long long)JEDEC_DATA_BUS_BITS / DEVICE_WIDTH)) / 8) >> 20;

        // If this is set, effectively override the number of ranks
        if (megsOfMemory != 0)
        {
                NUM_RANKS = megsOfMemory / megsOfStoragePerRank;
                NUM_RANKS_LOG = dramsim_log2(NUM_RANKS);
                if (NUM_RANKS == 0)
                {
                        PRINT("WARNING: Cannot create memory system with "<<megsOfMemory<<"MB, defaulting to minimum size of "<<megsOfStoragePerRank<<"MB");
                        NUM_RANKS=1;
                }
        }

        NUM_DEVICES = JEDEC_DATA_BUS_BITS/DEVICE_WIDTH;
        TOTAL_STORAGE = (NUM_RANKS * megsOfStoragePerRank); 

        DEBUG("CH. " <<systemID<<" TOTAL_STORAGE : "<< TOTAL_STORAGE << "MB | "<<NUM_RANKS<<" Ranks | "<< NUM_DEVICES <<" Devices per rank");


        memoryController = new MemoryController(this, csvOut, dramsim_log);

        // TODO: change to other vector constructor?
        ranks = new vector<Rank *>();

        for (size_t i=0; i<NUM_RANKS; i++)
        {
                Rank *r = new Rank(dramsim_log);
                r->setId(i);
                r->attachMemoryController(memoryController);
                ranks->push_back(r);
        }

        memoryController->attachRanks(ranks);

}



MemorySystem::~MemorySystem()
{
        /* the MemorySystem should exist for all time, nothing should be destroying it */  
//        ERROR("MEMORY SYSTEM DESTRUCTOR with ID "<<systemID);
//        abort();

        delete(memoryController);

        for (size_t i=0; i<NUM_RANKS; i++)
        {
                delete (*ranks)[i];
        }
        ranks->clear();
        delete(ranks);

        if (VERIFICATION_OUTPUT)
        {
                cmd_verify_out.flush();
                cmd_verify_out.close();
        }
}

bool MemorySystem::WillAcceptTransaction()
{
        return memoryController->WillAcceptTransaction();
}

bool MemorySystem::addTransaction(bool isWrite, uint64_t addr)
{
        TransactionType type = isWrite ? DATA_WRITE : DATA_READ;
        Transaction *trans = new Transaction(type,addr,NULL);
        // push_back in memoryController will make a copy of this during
        // addTransaction so it's kosher for the reference to be local 

        if (memoryController->WillAcceptTransaction()) 
        {
                return memoryController->addTransaction(trans);
        }
        else
        {
                pendingTransactions.push_back(trans);
                return true;
        }
}

bool MemorySystem::addTransaction(Transaction *trans)
{
        return memoryController->addTransaction(trans);
}

//prints statistics
void MemorySystem::printStats(bool finalStats)
{
        memoryController->printStats(finalStats);
}


//update the memory systems state
void MemorySystem::update()
{

        //PRINT(" ----------------- Memory System Update ------------------");

        //updates the state of each of the objects
        // NOTE - do not change order
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                (*ranks)[i]->update();
        }

        //pendingTransactions will only have stuff in it if MARSS is adding stuff
        if (pendingTransactions.size() > 0 && memoryController->WillAcceptTransaction())
        {
                memoryController->addTransaction(pendingTransactions.front());
                pendingTransactions.pop_front();
        }
        memoryController->update();

        //simply increments the currentClockCycle field for each object
        for (size_t i=0;i<NUM_RANKS;i++)
        {
                (*ranks)[i]->step();
        }
        memoryController->step();
        this->step();

        //PRINT("\n"); // two new lines
}

void MemorySystem::RegisterCallbacks( Callback_t* readCB, Callback_t* writeCB,
                                      void (*reportPower)(double bgpower, double burstpower,
                                                          double refreshpower, double actprepower))
{
        ReturnReadData = readCB;
        WriteDataDone = writeCB;
        ReportPower = reportPower;
}

} /*namespace DRAMSim */



// This function can be used by autoconf AC_CHECK_LIB since
// apparently it can't detect C++ functions.
// Basically just an entry in the symbol table
extern "C"
{
        void libdramsim_is_present(void)
        {
                ;
        }
}

          GITHUB_TOKEN: ${{ 


#ifndef MEMORYSYSTEM_H
#define MEMORYSYSTEM_H

//MemorySystem.h
//
//Header file for JEDEC memory system wrapper
//

#include "SimulatorObject.h"
#include "SystemConfiguration.h"
#include "MemoryController.h"
#include "Rank.h"
#include "Transaction.h"
#include "Callback.h"
#include "CSVWriter.h"
#include <deque>

namespace DRAMSim
{
typedef CallbackBase<void,unsigned,uint64_t,uint64_t> Callback_t;
class MemorySystem : public SimulatorObject
{
        ostream &dramsim_log;
public:
        //functions
        MemorySystem(unsigned id, unsigned megsOfMemory, CSVWriter &csvOut_, ostream &dramsim_log_);
        virtual ~MemorySystem();
        void update();
        bool addTransaction(Transaction *trans);
        bool addTransaction(bool isWrite, uint64_t addr);
        void printStats(bool finalStats);
        bool WillAcceptTransaction();
        void RegisterCallbacks(
            Callback_t *readDone,
            Callback_t *writeDone,
            void (*reportPower)(double bgpower, double burstpower, double refreshpower, double actprepower));

        //fields
        MemoryController *memoryController;
        vector<Rank *> *ranks;
        deque<Transaction *> pendingTransactions; 


        //function pointers
        Callback_t* ReturnReadData;
        Callback_t* WriteDataDone;
        //TODO: make this a functor as well?
        static powerCallBack_t ReportPower;
        unsigned systemID;

private:
        CSVWriter &csvOut;
};
}

#endif
 }}  # Needed to get PR information
          SONAR_TOKEN: ${{ #include <errno.h> 
#include <sstream> //stringstream
#include <stdlib.h> // getenv()
// for directory operations 
#include <sys/stat.h>
#include <sys/types.h>

#include "MultiChannelMemorySystem.h"
#include "AddressMapping.h"
#include "IniReader.h"



using namespace DRAMSim; 


MultiChannelMemorySystem::MultiChannelMemorySystem(const string &deviceIniFilename_, const string &systemIniFilename_, const string &pwd_, const string &traceFilename_, unsigned megsOfMemory_, string *visFilename_, const IniReader::OverrideMap *paramOverrides)
        :megsOfMemory(megsOfMemory_), deviceIniFilename(deviceIniFilename_),
        systemIniFilename(systemIniFilename_), traceFilename(traceFilename_),
        pwd(pwd_), visFilename(visFilename_), 
        clockDomainCrosser(new ClockDomain::Callback<MultiChannelMemorySystem, void>(this, &MultiChannelMemorySystem::actual_update)),
        csvOut(new CSVWriter(visDataOut))
{
        currentClockCycle=0; 
        if (visFilename)
                printf("CC VISFILENAME=%s\n",visFilename->c_str());

        if (!isPowerOfTwo(megsOfMemory))
        {
                ERROR("Please specify a power of 2 memory size"); 
                abort(); 
        }

        if (pwd.length() > 0)
        {
                //ignore the pwd argument if the argument is an absolute path
                if (deviceIniFilename[0] != '/')
                {
                        deviceIniFilename = pwd + "/" + deviceIniFilename;
                }

                if (systemIniFilename[0] != '/')
                {
                        systemIniFilename = pwd + "/" + systemIniFilename;
                }
        }

        DEBUG("== Loading device model file '"<<deviceIniFilename<<"' == ");
        IniReader::ReadIniFile(deviceIniFilename, false);
        DEBUG("== Loading system model file '"<<systemIniFilename<<"' == ");
        IniReader::ReadIniFile(systemIniFilename, true);

        // If we have any overrides, set them now before creating all of the memory objects
        if (paramOverrides)
                IniReader::OverrideKeys(paramOverrides);

        IniReader::InitEnumsFromStrings();
        if (!IniReader::CheckIfAllSet())
        {
                exit(-1);
        }

        if (NUM_CHANS == 0) 
        {
                ERROR("Zero channels"); 
                abort(); 
        }
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                MemorySystem *channel = new MemorySystem(i, megsOfMemory/NUM_CHANS, (*csvOut), dramsim_log);
                channels.push_back(channel);
        }
}
/* Initialize the ClockDomainCrosser to use the CPU speed 
        If cpuClkFreqHz == 0, then assume a 1:1 ratio (like for TraceBasedSim)
        */
void MultiChannelMemorySystem::setCPUClockSpeed(uint64_t cpuClkFreqHz)
{

        uint64_t dramsimClkFreqHz = (uint64_t)(1.0/(tCK*1e-9));
        clockDomainCrosser.clock1 = dramsimClkFreqHz; 
        clockDomainCrosser.clock2 = (cpuClkFreqHz == 0) ? dramsimClkFreqHz : cpuClkFreqHz; 
}

bool fileExists(string &path)
{
        struct stat stat_buf;
        if (stat(path.c_str(), &stat_buf) != 0) 
        {
                if (errno == ENOENT)
                {
                        return false; 
                }
                ERROR("Warning: some other kind of error happened with stat(), should probably check that"); 
        }
        return true;
}

string FilenameWithNumberSuffix(const string &filename, const string &extension, unsigned maxNumber=100)
{
        string currentFilename = filename+extension;
        if (!fileExists(currentFilename))
        {
                return currentFilename;
        }

        // otherwise, add the suffixes and test them out until we find one that works
        stringstream tmpNum; 
        tmpNum<<"."<<1; 
        for (unsigned i=1; i<maxNumber; i++)
        {
                currentFilename = filename+tmpNum.str()+extension;
                if (fileExists(currentFilename))
                {
                        currentFilename = filename; 
                        tmpNum.seekp(0);
                        tmpNum << "." << i;
                }
                else 
                {
                        return currentFilename;
                }
        }
        // if we can't find one, just give up and return whatever is the current filename
        ERROR("Warning: Couldn't find a suitable suffix for "<<filename); 
        return currentFilename; 
}
/**
 * This function creates up to 3 output files: 
 *         - The .log file if LOG_OUTPUT is set
 *         - the .vis file where csv data for each epoch will go
 *         - the .tmp file if verification output is enabled
 * The results directory is setup to be in PWD/TRACEFILENAME.[SIM_DESC]/DRAM_PARTNAME/PARAMS.vis
 * The environment variable SIM_DESC is also appended to output files/directories
 *
 * TODO: verification info needs to be generated per channel so it has to be
 * moved back to MemorySystem
 **/
void MultiChannelMemorySystem::InitOutputFiles(string traceFilename)
{
        size_t lastSlash;
        size_t deviceIniFilenameLength = deviceIniFilename.length();
        string sim_description_str;
        string deviceName;

        char *sim_description = getenv("SIM_DESC");
        if (sim_description)
        {
                        sim_description_str = string(sim_description);
        }


        // create a properly named verification output file if need be and open it
        // as the stream 'cmd_verify_out'
        if (VERIFICATION_OUTPUT)
        {
                string basefilename = deviceIniFilename.substr(deviceIniFilename.find_last_of("/")+1);
                string verify_filename =  "sim_out_"+basefilename;
                if (sim_description != NULL)
                {
                        verify_filename += "."+sim_description_str;
                }
                verify_filename += ".tmp";
                cmd_verify_out.open(verify_filename.c_str());
                if (!cmd_verify_out)
                {
                        ERROR("Cannot open "<< verify_filename);
                        abort(); 
                }
        }
        // This sets up the vis file output along with the creating the result
        // directory structure if it doesn't exist
        if (VIS_FILE_OUTPUT)
        {
                stringstream out,tmpNum;
                string path;
                string filename;

                if (!visFilename)
                {
                        path = "results/";
                        // chop off the .ini if it's there
                        if (deviceIniFilename.substr(deviceIniFilenameLength-4) == ".ini")
                        {
                                deviceName = deviceIniFilename.substr(0,deviceIniFilenameLength-4);
                                deviceIniFilenameLength -= 4;
                        }

                        // chop off everything past the last / (i.e. leave filename only)
                        if ((lastSlash = deviceName.find_last_of("/")) != string::npos)
                        {
                                deviceName = deviceName.substr(lastSlash+1,deviceIniFilenameLength-lastSlash-1);
                        }

                string rest;
                        // working backwards, chop off the next piece of the directory
                        if ((lastSlash = traceFilename.find_last_of("/")) != string::npos)
                        {
                                traceFilename = traceFilename.substr(lastSlash+1,traceFilename.length()-lastSlash-1);
                        }
                        if (sim_description != NULL)
                        {
                                traceFilename += "."+sim_description_str;
                        }

                        if (pwd.length() > 0)
                        {
                                path = pwd + "/" + path;
                        }

                        // create the directories if they don't exist 
                        mkdirIfNotExist(path);
                        path = path + traceFilename + "/";
                        mkdirIfNotExist(path);
                        path = path + deviceName + "/";
                        mkdirIfNotExist(path);

                        // finally, figure out the filename
                        string sched = "BtR";
                        string queue = "pRank";
                        if (schedulingPolicy == RankThenBankRoundRobin)
                        {
                                sched = "RtB";
                        }
                        if (queuingStructure == PerRankPerBank)
                        {
                                queue = "pRankpBank";
                        }

                        /* I really don't see how "the C++ way" is better than snprintf()  */
                        out << (TOTAL_STORAGE>>10) << "GB." << NUM_CHANS << "Ch." << NUM_RANKS <<"R." <<ADDRESS_MAPPING_SCHEME<<"."<<ROW_BUFFER_POLICY<<"."<< TRANS_QUEUE_DEPTH<<"TQ."<<CMD_QUEUE_DEPTH<<"CQ."<<sched<<"."<<queue;
                }
                else //visFilename given
                {
                        out << *visFilename;
                }
                if (sim_description)
                {
                        out << "." << sim_description;
                }

                //filename so far, without extension, see if it exists already
                filename = out.str();


                filename = FilenameWithNumberSuffix(filename, ".vis"); 
                path.append(filename);
                cerr << "writing vis file to " <<path<<endl;


                visDataOut.open(path.c_str());
                if (!visDataOut)
                {
                        ERROR("Cannot open '"<<path<<"'");
                        exit(-1);
                }
                //write out the ini config values for the visualizer tool
                IniReader::WriteValuesOut(visDataOut);

        }
        else
        {
                // cerr << "vis file output disabled\n";
        }
#ifdef LOG_OUTPUT
        string dramsimLogFilename("dramsim");
        if (sim_description != NULL)
        {
                dramsimLogFilename += "."+sim_description_str; 
        }

        dramsimLogFilename = FilenameWithNumberSuffix(dramsimLogFilename, ".log"); 

        dramsim_log.open(dramsimLogFilename.c_str(), ios_base::out | ios_base::trunc );

        if (!dramsim_log) 
        {
        ERROR("Cannot open "<< dramsimLogFilename);
        //        exit(-1); 
        }
#endif

}


void MultiChannelMemorySystem::mkdirIfNotExist(string path)
{
        struct stat stat_buf;
        // check if the directory exists
        if (stat(path.c_str(), &stat_buf) != 0) // nonzero return value on error, check errno
        {
                if (errno == ENOENT) 
                {
//                        DEBUG("\t directory doesn't exist, trying to create ...");

                        // set permissions dwxr-xr-x on the results directories
                        mode_t mode = (S_IXOTH | S_IXGRP | S_IXUSR | S_IROTH | S_IRGRP | S_IRUSR | S_IWUSR) ;
                        if (mkdir(path.c_str(), mode) != 0)
                        {
                                perror("Error Has occurred while trying to make directory: ");
                                cerr << path << endl;
                                abort();
                        }
                }
                else
                {
                        perror("Something else when wrong: "); 
                        abort();
                }
        }
        else // directory already exists
        {
                if (!S_ISDIR(stat_buf.st_mode))
                {
                        ERROR(path << "is not a directory");
                        abort();
                }
        }
}


MultiChannelMemorySystem::~MultiChannelMemorySystem()
{
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                delete channels[i];
        }
        channels.clear(); 

// flush our streams and close them up
#ifdef LOG_OUTPUT
        dramsim_log.flush();
        dramsim_log.close();
#endif
        if (VIS_FILE_OUTPUT) 
        {        
                visDataOut.flush();
                visDataOut.close();
        }
}
void MultiChannelMemorySystem::update()
{
        clockDomainCrosser.update(); 
}
void MultiChannelMemorySystem::actual_update() 
{
        if (currentClockCycle == 0)
        {
                InitOutputFiles(traceFilename);
                DEBUG("DRAMSim2 Clock Frequency ="<<clockDomainCrosser.clock1<<"Hz, CPU Clock Frequency="<<clockDomainCrosser.clock2<<"Hz"); 
        }

        if (currentClockCycle % EPOCH_LENGTH == 0)
        {
                (*csvOut) << "ms" <<currentClockCycle * tCK * 1E-6; 
                for (size_t i=0; i<NUM_CHANS; i++)
                {
                        channels[i]->printStats(false); 
                }
                csvOut->finalize();
        }

        for (size_t i=0; i<NUM_CHANS; i++)
        {
                channels[i]->update(); 
        }


        currentClockCycle++; 
}
unsigned MultiChannelMemorySystem::findChannelNumber(uint64_t addr)
{
        // Single channel case is a trivial shortcut case 
        if (NUM_CHANS == 1)
        {
                return 0; 
        }

        if (!isPowerOfTwo(NUM_CHANS))
        {
                ERROR("We can only support power of two # of channels.\n" <<
                                "I don't know what Intel was thinking, but trying to address map half a bit is a neat trick that we're not sure how to do"); 
                abort(); 
        }

        // only chan is used from this set 
        unsigned channelNumber,rank,bank,row,col;
        addressMapping(addr, channelNumber, rank, bank, row, col); 
        if (channelNumber >= NUM_CHANS)
        {
                ERROR("Got channel index "<<channelNumber<<" but only "<<NUM_CHANS<<" exist"); 
                abort();
        }
        //DEBUG("Channel idx = "<<channelNumber<<" totalbits="<<totalBits<<" channelbits="<<channelBits); 

        return channelNumber;

}
ostream &MultiChannelMemorySystem::getLogFile()
{
        return dramsim_log; 
}
bool MultiChannelMemorySystem::addTransaction(const Transaction &trans)
{
        // copy the transaction and send the pointer to the new transaction 
        return addTransaction(new Transaction(trans)); 
}

bool MultiChannelMemorySystem::addTransaction(Transaction *trans)
{
        unsigned channelNumber = findChannelNumber(trans->address); 
        return channels[channelNumber]->addTransaction(trans); 
}

bool MultiChannelMemorySystem::addTransaction(bool isWrite, uint64_t addr)
{
        unsigned channelNumber = findChannelNumber(addr); 
        return channels[channelNumber]->addTransaction(isWrite, addr); 
}

/*
        This function has two flavors: one with and without the address. 
        If the simulator won't give us an address and we have multiple channels, 
        we have to assume the worst and return false if any channel won't accept. 

        However, if the address is given, we can just map the channel and check just
        that memory controller
*/

bool MultiChannelMemorySystem::willAcceptTransaction(uint64_t addr)
{
        unsigned chan, rank,bank,row,col; 
        addressMapping(addr, chan, rank, bank, row, col); 
        return channels[chan]->WillAcceptTransaction(); 
}

bool MultiChannelMemorySystem::willAcceptTransaction()
{
        for (size_t c=0; c<NUM_CHANS; c++) {
                if (!channels[c]->WillAcceptTransaction())
                {
                        return false; 
                }
        }
        return true; 
}



void MultiChannelMemorySystem::printStats(bool finalStats) {

        (*csvOut) << "ms" <<currentClockCycle * tCK * 1E-6; 
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                PRINT("==== Channel ["<<i<<"] ====");
                channels[i]->printStats(finalStats); 
                PRINT("//// Channel ["<<i<<"] ////");
        }
        csvOut->finalize();
}
void MultiChannelMemorySystem::RegisterCallbacks( 
                TransactionCompleteCB *readDone,
                TransactionCompleteCB *writeDone,
                void (*reportPower)(double bgpower, double burstpower, double refreshpower, double actprepower))
{
        for (size_t i=0; i<NUM_CHANS; i++)
        {
                channels[i]->RegisterCallbacks(readDone, writeDone, reportPower); 
        }
}

/*
 * The getters below are useful to external simulators interfacing with DRAMSim
 *
 * Return value: 0 on success, -1 on error
 */
int MultiChannelMemorySystem::getIniBool(const std::string& field, bool *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getBool(field, val);
}

int MultiChannelMemorySystem::getIniUint(const std::string& field, unsigned int *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getUint(field, val);
}

int MultiChannelMemorySystem::getIniUint64(const std::string& field, uint64_t *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getUint64(field, val);
}

int MultiChannelMemorySystem::getIniFloat(const std::string& field, float *val)
{
        if (!IniReader::CheckIfAllSet())
                exit(-1);
        return IniReader::getFloat(field, val);
}

namespace DRAMSim {
MultiChannelMemorySystem *getMemorySystemInstance(const string &dev, const string &sys, const string &pwd, const string &trc, unsigned megsOfMemory, string *visfilename) 
{
        return new MultiChannelMemorySystem(dev, sys, pwd, trc, megsOfMemory, visfilename);
}
} }}   # Generate a token on SonarQube, add it to the secrets of this repo with the name SONAR_TOKEN (Settings > Secrets > Actions > add new repository secret)
          SONAR_HOST_URL: ${{ #include "SimulatorObject.h"
#include "Transaction.h"
#include "SystemConfiguration.h"
#include "MemorySystem.h"
#include "IniReader.h"
#include "ClockDomain.h"
#include "CSVWriter.h"


namespace DRAMSim {


class MultiChannelMemorySystem : public SimulatorObject 
{
        public: 

        MultiChannelMemorySystem(const string &dev, const string &sys, const string &pwd, const string &trc, unsigned megsOfMemory, string *visFilename=NULL, const IniReader::OverrideMap *paramOverrides=NULL);
                virtual ~MultiChannelMemorySystem();
                        bool addTransaction(Transaction *trans);
                        bool addTransaction(const Transaction &trans);
                        bool addTransaction(bool isWrite, uint64_t addr);
                        bool willAcceptTransaction(); 
                        bool willAcceptTransaction(uint64_t addr); 
                        void update();
                        void printStats(bool finalStats=false);
                        ostream &getLogFile();
                        void RegisterCallbacks( 
                                TransactionCompleteCB *readDone,
                                TransactionCompleteCB *writeDone,
                                void (*reportPower)(double bgpower, double burstpower, double refreshpower, double actprepower));
                        int getIniBool(const std::string &field, bool *val);
                        int getIniUint(const std::string &field, unsigned int *val);
                        int getIniUint64(const std::string &field, uint64_t *val);
                        int getIniFloat(const std::string &field, float *val);

        void InitOutputFiles(string tracefilename);
        void setCPUClockSpeed(uint64_t cpuClkFreqHz);

        //output file
        std::ofstream visDataOut;
        ofstream dramsim_log; 

        private:
                unsigned findChannelNumber(uint64_t addr);
                void actual_update(); 
                vector<MemorySystem*> channels; 
                unsigned megsOfMemory; 
                string deviceIniFilename;
                string systemIniFilename;
                string traceFilename;
                string pwd;
                string *visFilename;
                ClockDomain::ClockDomainCrosser clockDomainCrosser; 
                static void mkdirIfNotExist(string path);
                static bool fileExists(string path); 
                CSVWriter *csvOut; 


        };
} }}   # add the URL of your instance to the secrets of this repo with the name SONAR_HOST_URL (Settings > Secrets > Actions > add new repository secret)
        with: #include "PrintMacros.h"

/*
 * Enable or disable PRINT() statements.
 *
 * Set by flag in TraceBasedSim.cpp when compiling standalone DRAMSim tool.
 *
 * The DRAMSim libraries do not include the TraceBasedSim object and thus
 * library users can optionally override the weak definition below.
 */
int __attribute__((weak)) SHOW_SIM_OUTPUT = false;
          # Additional arguments for the sonarcloud scanner
          args: 




#ifndef PRINT_MACROS_H
#define PRINT_MACROS_H

#include <iostream>

extern int SHOW_SIM_OUTPUT;

#define ERROR(str) std::cerr<<"[ERROR ("<<__FILE__<<":"<<__LINE__<<")]: "<<str<<std::endl;

using std::ostream;

#ifdef DEBUG_BUILD
        #define DEBUG(str)  std::cerr<< str <<std::endl;
        #define DEBUGN(str) std::cerr<< str;
#else
        #define DEBUG(str) ;
        #define DEBUGN(str) ;
#endif

#ifdef NO_OUTPUT
        #undef DEBUG
        #undef DEBUGN
        #define DEBUG(str) ;
        #define DEBUGN(str) ;
        #define PRINT(str) ;
        #define PRINTN(str) ;
#else
        #ifdef LOG_OUTPUT
                #define PRINT(str)  { dramsim_log <<str<<std::endl; }
                #define PRINTN(str) { dramsim_log <<str; }
        #else
                #define PRINT(str)  if(SHOW_SIM_OUTPUT) { std::cout <<str<<std::endl; }
                #define PRINTN(str) if(SHOW_SIM_OUTPUT) { std::cout <<str; }
        #endif
#endif

#endif /*PRINT_MACROS_H*/
            # Unique key of your project. You can find it in SonarQube > [my project] > Project Information (top-right menu)
            # mandatory
            -Dsonar.projectKey=
            # Comma-separated paths to directories containing main source files.
            #-Dsonar.sources= # optional, default is project base directory
            # When you need the analysis to take place in a directory other than the one from which it was launched
            #-Dsonar.projectBaseDir= # optional, default is .
            # Comma-separated paths to directories containing test source files.
            #-Dsonar.tests= # optional. For more info about Code Coverage, please refer to https://docs.sonarcloud.io/enriching/test-coverage/overview/
            # Adds more detail to both client and server-side analysis logs, activating DEBUG mode for the scanner, and adding client-side environment variables and system properties to the server-side log of analysis report processing.
            #-Dsonar.verbose= # optional, default is false

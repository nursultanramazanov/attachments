# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# This workflow checks out code, performs a Codacy security scan
# and integrates the results with the
# GitHub Advanced Security code scanning feature.  For more information on
# the Codacy security scan action usage and parameters, see
# https://github.com/codacy/codacy-analysis-cli-action.
# For more information on Codacy Analysis CLI in general, see
# https://github.com/codacy/codacy-analysis-cli.

name: Codacy Security Scan

on: #include "ClockDomain.h"
  push: using namespace std;
    branches: [ "main" ]
  pull_request: namespace ClockDomain
{
	// "Default" crosser with a 1:1 ratio
	ClockDomainCrosser::ClockDomainCrosser(ClockUpdateCB *_callback)
		: callback(_callback), clock1(1UL), clock2(1UL), counter1(0UL), counter2(0UL)
	{
	}
    # The branches below must be a subset of the branches above
    branches: [ "main" ]
  schedule: ClockDomainCrosser::ClockDomainCrosser(uint64_t _clock1, uint64_t _clock2, ClockUpdateCB *_callback) 
		: callback(_callback), clock1(_clock1), clock2(_clock2), counter1(0), counter2(0)
	{
		//cout << "CTOR: callback address: " << (uint64_t)(this->callback) << "\t ratio="<<clock1<<"/"<<clock2<< endl;
	}
    - cron: '30 20 * * 5'

permissions: ClockDomainCrosser::ClockDomainCrosser(double ratio, ClockUpdateCB *_callback)
		: callback(_callback), counter1(0), counter2(0)
	{
		// Compute numerator and denominator for ratio, then pass that to other constructor.
		double x = ratio;

		const int MAX_ITER = 15;
		size_t i;
		unsigned ns[MAX_ITER], ds[MAX_ITER];
		double zs[MAX_ITER];
		ds[0] = 0;
		ds[1] = 1;
		zs[1] = x;
		ns[1] = (int)x; 

		for (i = 1; i<MAX_ITER-1; i++)
		{
			if (fabs(x - (double)ns[i]/(double)ds[i]) < 0.00005)
			{
				//printf("ANSWER= %u/%d\n",ns[i],ds[i]);
				break;
			}
			//TODO: or, if the answers are the same as the last iteration, stop 

			zs[i+1] = 1.0f/(zs[i]-(int)floor(zs[i])); // 1/(fractional part of z_i)
			ds[i+1] = ds[i]*(int)floor(zs[i+1])+ds[i-1];
			double tmp = x*ds[i+1];
			double tmp2 = tmp - (int)tmp;
			ns[i+1] = tmp2 >= 0.5 ? ceil(tmp) : floor(tmp); // ghetto implementation of a rounding function
			//printf("i=%lu, z=%20f n=%5u d=%5u\n",i,zs[i],ns[i],ds[i]);
		}

		//printf("APPROXIMATION= %u/%d\n",ns[i],ds[i]);
		this->clock1=ns[i];
		this->clock2=ds[i];

		//cout << "CTOR: callback address: " << (uint64_t)(this->callback) << "\t ratio="<<clock1<<"/"<<clock2<< endl;
	}
  contents: read

jobs: void ClockDomainCrosser::update()
	{
		//short circuit case for 1:1 ratios
		if (clock1 == clock2 && callback)
		{
			(*callback)();
			return; 
		}

		// Update counter 1.
		counter1 += clock1;

		while (counter2 < counter1)
		{
			counter2 += clock2;
			//cout << "CALLBACK: counter1= " << counter1 << "; counter2= " << counter2 << "; " << endl;
			//cout << "callback address: " << (uint64_t)callback << endl;
			if (callback)
			{
				//cout << "Callback() " << (uint64_t)callback<< "Counters: 1="<<counter1<<", 2="<<counter2 <<endl;
				(*callback)();
			}
		}

		if (counter1 == counter2)
		{
			counter1 = 0;
			counter2 = 0;
		}
	}



	void TestObj::cb()
	{
			cout << "In Callback\n";
	}
  codacy-security-scan: int TestObj::test()
	{
		ClockUpdateCB *callback = new Callback<TestObj, void>(this, &TestObj::cb);

		//ClockDomainCrosser x(5,2,&cb);
		//ClockDomainCrosser x(2,5,NULL);
		//ClockDomainCrosser x(37,41,NULL);
		//ClockDomainCrosser x(41,37,NULL);
		//cout << "(main) callback address: " << (uint64_t)&cb << endl;
		ClockDomainCrosser x(0.5, callback);
		cout <<"------------------------------------------\n";
		ClockDomainCrosser y(0.3333, callback);
		cout <<"------------------------------------------\n";
		ClockDomainCrosser z(0.9, callback);
		cout <<"------------------------------------------\n";


		for (int i=0; i<10; i++)
		{
			
			x.update();
			cout << "UPDATE: counter1= " << x.counter1 << "; counter2= " << x.counter2 << "; " << endl;
		}

		return 0;
	}


}
    permissions:
      contents: read # for actions/checkout to fetch code
      security-events: write # for github/codeql-action/upload-sarif to upload SARIF results
      actions: read # only required for a private repository by github/codeql-action/upload-sarif to get the Action run status
    name: Codacy Security Scan
    runs-on: ubuntu-latest
    steps:
      # Checkout the repository to the GitHub Actions runner
      - name: Checkout code
        uses: actions/checkout@v4

      # Execute Codacy Analysis CLI and generate a SARIF output with the security issues identified during the analysis
      - name: Run Codacy Analysis CLI
        uses: codacy/codacy-analysis-cli-action@d840f886c4bd4edc059706d09c6a1586111c540b
        with:
          # Check https://github.com/codacy/codacy-analysis-cli#project-token to get your project token from your Codacy repository
          # You can also omit the token and run the tools that support default configurations
          project-token: ${{ secrets.CODACY_PROJECT_TOKEN }}
          verbose: true
          output: results.sarif
          format: sarif
          # Adjust severity of non-security issues
          gh-code-scanning-compat: true
          # Force 0 exit code to allow SARIF file generation
          # This will handover control about PR rejection to the GitHub side
          max-allowed-issues: 2147483647

      # Upload the SARIF file generated in the previous step
      - name: Upload SARIF results file
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: results.sarif
